/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/js/controller/index.js":
/*!************************************!*\
  !*** ./app/js/controller/index.js ***!
  \************************************/
/*! exports provided: app */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"app\", function() { return app; });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model */ \"./app/js/model/index.js\");\n/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../view */ \"./app/js/view/index.js\");\n\n\nvar app = {\n  init: function init() {\n    this.initOSB();\n    this.pah();\n    this.ip(); // this.test()\n    // this.slt()\n  },\n  initOSB: function initOSB() {\n    Object(_model__WEBPACK_IMPORTED_MODULE_0__[\"initOverlayScrollbars\"])(_view__WEBPACK_IMPORTED_MODULE_1__[\"sidebarWrapper\"]);\n  },\n  // slt(){\n  // \tsidebarListsToggle(sidebarListItems)\n  // }\n  pah: function pah() {\n    Object(_model__WEBPACK_IMPORTED_MODULE_0__[\"playAudioHover\"])(_view__WEBPACK_IMPORTED_MODULE_1__[\"rows\"]);\n  },\n  ip: function ip() {\n    Object(_model__WEBPACK_IMPORTED_MODULE_0__[\"initPopups\"])();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvY29udHJvbGxlci9pbmRleC5qcz9kZmM2Il0sIm5hbWVzIjpbImFwcCIsImluaXQiLCJpbml0T1NCIiwicGFoIiwiaXAiLCJpbml0T3ZlcmxheVNjcm9sbGJhcnMiLCJzaWRlYmFyV3JhcHBlciIsInBsYXlBdWRpb0hvdmVyIiwicm93cyIsImluaXRQb3B1cHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQVFBLElBQU1BLEdBQUcsR0FBRztBQUNYQyxNQURXLGtCQUNKO0FBQ04sU0FBS0MsT0FBTDtBQUNBLFNBQUtDLEdBQUw7QUFDQSxTQUFLQyxFQUFMLEdBSE0sQ0FJTjtBQUNBO0FBQ0EsR0FQVTtBQVNYRixTQVRXLHFCQVNGO0FBQ1JHLHdFQUFxQixDQUFDQyxvREFBRCxDQUFyQjtBQUNBLEdBWFU7QUFZWDtBQUNBO0FBQ0E7QUFDQUgsS0FmVyxpQkFlTjtBQUNKSSxpRUFBYyxDQUFDQywwQ0FBRCxDQUFkO0FBQ0EsR0FqQlU7QUFtQlhKLElBbkJXLGdCQW1CUDtBQUNISyw2REFBVTtBQUNWO0FBckJVLENBQVoiLCJmaWxlIjoiLi9hcHAvanMvY29udHJvbGxlci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcblxyXG5cdGluaXRPdmVybGF5U2Nyb2xsYmFycyxcclxuXHQvLyBzaWRlYmFyTGlzdHNUb2dnbGUsXHJcblx0cGxheUF1ZGlvSG92ZXIsXHJcblx0aW5pdFBvcHVwc1xyXG5cclxufSBmcm9tICcuLi9tb2RlbCdcclxuXHJcblxyXG5pbXBvcnQge1xyXG5cclxuXHRzaWRlYmFyV3JhcHBlcixcclxuXHRzaWRlYmFyTGlzdEl0ZW1zLFxyXG5cdHJvd3NcclxuXHJcbn0gZnJvbSAnLi4vdmlldydcclxuXHJcbmNvbnN0IGFwcCA9IHtcclxuXHRpbml0KCkge1xyXG5cdFx0dGhpcy5pbml0T1NCKClcclxuXHRcdHRoaXMucGFoKClcclxuXHRcdHRoaXMuaXAoKVxyXG5cdFx0Ly8gdGhpcy50ZXN0KClcclxuXHRcdC8vIHRoaXMuc2x0KClcclxuXHR9LFxyXG5cclxuXHRpbml0T1NCKCl7XHJcblx0XHRpbml0T3ZlcmxheVNjcm9sbGJhcnMoc2lkZWJhcldyYXBwZXIpXHJcblx0fSxcclxuXHQvLyBzbHQoKXtcclxuXHQvLyBcdHNpZGViYXJMaXN0c1RvZ2dsZShzaWRlYmFyTGlzdEl0ZW1zKVxyXG5cdC8vIH1cclxuXHRwYWgoKXtcclxuXHRcdHBsYXlBdWRpb0hvdmVyKHJvd3MpXHJcblx0fSxcclxuXHJcblx0aXAoKXtcclxuXHRcdGluaXRQb3B1cHMoKVxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQge1xyXG5cdGFwcFxyXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./app/js/controller/index.js\n");

/***/ }),

/***/ "./app/js/main.js":
/*!************************!*\
  !*** ./app/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controller */ \"./app/js/controller/index.js\");\n;\n\n\nif (document.readyState !== 'loading') {\n  _controller__WEBPACK_IMPORTED_MODULE_0__[\"app\"].init();\n} else {\n  document.addEventListener('DOMContentLoaded', function () {\n    _controller__WEBPACK_IMPORTED_MODULE_0__[\"app\"].init();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbWFpbi5qcz80M2M0Il0sIm5hbWVzIjpbImRvY3VtZW50IiwicmVhZHlTdGF0ZSIsImFwcCIsImluaXQiLCJhZGRFdmVudExpc3RlbmVyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQzs7QUFFRCxJQUFJQSxRQUFRLENBQUNDLFVBQVQsS0FBd0IsU0FBNUIsRUFBd0M7QUFDcENDLGlEQUFHLENBQUNDLElBQUo7QUFDSCxDQUZELE1BRU87QUFDSEgsVUFBUSxDQUFDSSxnQkFBVCxDQUEwQixrQkFBMUIsRUFBOEMsWUFBWTtBQUN0REYsbURBQUcsQ0FBQ0MsSUFBSjtBQUNILEdBRkQ7QUFHSCIsImZpbGUiOiIuL2FwcC9qcy9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiO2ltcG9ydCB7YXBwfSBmcm9tICcuL2NvbnRyb2xsZXInXHJcblxyXG5pZiggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnICkge1xyXG4gICAgYXBwLmluaXQoKTtcclxufSBlbHNlIHtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYXBwLmluaXQoKTtcclxuICAgIH0pO1xyXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./app/js/main.js\n");

/***/ }),

/***/ "./app/js/model/OverlayScrollbarsInit.js":
/*!***********************************************!*\
  !*** ./app/js/model/OverlayScrollbarsInit.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _libs_libs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../libs/libs */ \"./app/libs/libs.js\");\n\n\nvar initOverlayScrollbars = function initOverlayScrollbars(node) {\n  var instance = Object(_libs_libs__WEBPACK_IMPORTED_MODULE_0__[\"OverlayScrollbars\"])(node, {\n    className: \"os-theme-dark\",\n    sizeAutoCapable: true,\n    paddingAbsolute: true,\n    scrollbars: {\n      clickScrolling: true,\n      autoHide: 'leave',\n      autoHideDelay: 50\n    }\n  });\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (initOverlayScrollbars);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbW9kZWwvT3ZlcmxheVNjcm9sbGJhcnNJbml0LmpzP2YzYzYiXSwibmFtZXMiOlsiaW5pdE92ZXJsYXlTY3JvbGxiYXJzIiwibm9kZSIsImluc3RhbmNlIiwiT3ZlcmxheVNjcm9sbGJhcnMiLCJjbGFzc05hbWUiLCJzaXplQXV0b0NhcGFibGUiLCJwYWRkaW5nQWJzb2x1dGUiLCJzY3JvbGxiYXJzIiwiY2xpY2tTY3JvbGxpbmciLCJhdXRvSGlkZSIsImF1dG9IaWRlRGVsYXkiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTs7QUFJQSxJQUFNQSxxQkFBcUIsR0FBRyxTQUF4QkEscUJBQXdCLENBQUNDLElBQUQsRUFBUztBQUN0QyxNQUFJQyxRQUFRLEdBQUdDLG9FQUFpQixDQUFDRixJQUFELEVBQU87QUFDdkNHLGFBQVMsRUFBUyxlQURxQjtBQUV2Q0MsbUJBQWUsRUFBRyxJQUZxQjtBQUd2Q0MsbUJBQWUsRUFBRyxJQUhxQjtBQUl2Q0MsY0FBVSxFQUFHO0FBQ1pDLG9CQUFjLEVBQUcsSUFETDtBQUVaQyxjQUFRLEVBQUcsT0FGQztBQUdaQyxtQkFBYSxFQUFFO0FBSEg7QUFKMEIsR0FBUCxDQUFoQztBQVVBLENBWEQ7O0FBZ0JlVixvRkFBZiIsImZpbGUiOiIuL2FwcC9qcy9tb2RlbC9PdmVybGF5U2Nyb2xsYmFyc0luaXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge092ZXJsYXlTY3JvbGxiYXJzfSBmcm9tICcuLi8uLi9saWJzL2xpYnMnXHJcblxyXG5cclxuXHJcbmNvbnN0IGluaXRPdmVybGF5U2Nyb2xsYmFycyA9IChub2RlKT0+IHtcclxuXHRsZXQgaW5zdGFuY2UgPSBPdmVybGF5U2Nyb2xsYmFycyhub2RlLCB7XHJcblx0Y2xhc3NOYW1lICAgICAgIDogXCJvcy10aGVtZS1kYXJrXCIsXHJcblx0c2l6ZUF1dG9DYXBhYmxlIDogdHJ1ZSxcclxuXHRwYWRkaW5nQWJzb2x1dGUgOiB0cnVlLFxyXG5cdHNjcm9sbGJhcnMgOiB7XHJcblx0XHRjbGlja1Njcm9sbGluZyA6IHRydWUsXHJcblx0XHRhdXRvSGlkZSA6ICdsZWF2ZScsXHJcblx0XHRhdXRvSGlkZURlbGF5OiA1MFxyXG5cdH1cclxufSk7IFxyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBpbml0T3ZlcmxheVNjcm9sbGJhcnNcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./app/js/model/OverlayScrollbarsInit.js\n");

/***/ }),

/***/ "./app/js/model/index.js":
/*!*******************************!*\
  !*** ./app/js/model/index.js ***!
  \*******************************/
/*! exports provided: initOverlayScrollbars, sidebarListsToggle, playAudioHover, initPopups */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _OverlayScrollbarsInit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OverlayScrollbarsInit */ \"./app/js/model/OverlayScrollbarsInit.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"initOverlayScrollbars\", function() { return _OverlayScrollbarsInit__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _sidebarListsToggle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sidebarListsToggle */ \"./app/js/model/sidebarListsToggle.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"sidebarListsToggle\", function() { return _sidebarListsToggle__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _playAudioHover__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./playAudioHover */ \"./app/js/model/playAudioHover.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"playAudioHover\", function() { return _playAudioHover__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _initPopups__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./initPopups */ \"./app/js/model/initPopups.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"initPopups\", function() { return _initPopups__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbW9kZWwvaW5kZXguanM/YzgzZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vYXBwL2pzL21vZGVsL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGluaXRPdmVybGF5U2Nyb2xsYmFycyBmcm9tICcuL092ZXJsYXlTY3JvbGxiYXJzSW5pdCdcclxuaW1wb3J0IHNpZGViYXJMaXN0c1RvZ2dsZSBmcm9tICcuL3NpZGViYXJMaXN0c1RvZ2dsZSdcclxuaW1wb3J0IHBsYXlBdWRpb0hvdmVyIGZyb20gJy4vcGxheUF1ZGlvSG92ZXInXHJcbmltcG9ydCBpbml0UG9wdXBzIGZyb20gJy4vaW5pdFBvcHVwcydcclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQge1xyXG5cdGluaXRPdmVybGF5U2Nyb2xsYmFycyxcclxuXHRzaWRlYmFyTGlzdHNUb2dnbGUsXHJcblx0cGxheUF1ZGlvSG92ZXIsXHJcblx0aW5pdFBvcHVwc1xyXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./app/js/model/index.js\n");

/***/ }),

/***/ "./app/js/model/initPopups.js":
/*!************************************!*\
  !*** ./app/js/model/initPopups.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _popup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./popup */ \"./app/js/model/popup.js\");\n/* harmony import */ var _libs_libs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../libs/libs */ \"./app/libs/libs.js\");\n\n\n\nvar initPopups = function initPopups() {\n  var countryPopup = new _popup__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('.country-filter-wrapper', {\n    view: true,\n    contents: \"#country-popup\" // pointerPosition: 'right',\n    // size_pointer_position: 20,\n\n  });\n  var typeManufacturyPopup = new _popup__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('.type-manufactury-filter-wrapper', {\n    view: true,\n    contents: \"#type-manufactury-popup\" // pointerPosition: 'right',\n    // size_pointer_position: 20,\n\n  });\n  var contaxtPopup = new _popup__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('.contact-filter-wrapper', {\n    view: true,\n    contents: \"#contact-popup\" // pointerPosition: 'right',\n    // size_pointer_position: 20,\n\n  });\n  console.log(countryPopup); // document.querySelectorAll('.sidebar__filter-item').forEach(el => {\n  // \tel.addEventListener('click', function(){\n  // \t\tMicroModal.show('modal-1')\n  // \t})\n  // })\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (initPopups);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbW9kZWwvaW5pdFBvcHVwcy5qcz8wZjU4Il0sIm5hbWVzIjpbImluaXRQb3B1cHMiLCJjb3VudHJ5UG9wdXAiLCJQb3B1cE1EIiwidmlldyIsImNvbnRlbnRzIiwidHlwZU1hbnVmYWN0dXJ5UG9wdXAiLCJjb250YXh0UG9wdXAiLCJjb25zb2xlIiwibG9nIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOztBQUlBLElBQU1BLFVBQVUsR0FBRyxTQUFiQSxVQUFhLEdBQUs7QUFDdkIsTUFBSUMsWUFBWSxHQUFHLElBQUlDLDhDQUFKLENBQVkseUJBQVosRUFBc0M7QUFDeERDLFFBQUksRUFBRSxJQURrRDtBQUV4REMsWUFBUSxrQkFGZ0QsQ0FHeEQ7QUFDQTs7QUFKd0QsR0FBdEMsQ0FBbkI7QUFTQSxNQUFJQyxvQkFBb0IsR0FBRyxJQUFJSCw4Q0FBSixDQUFZLGtDQUFaLEVBQStDO0FBQ3pFQyxRQUFJLEVBQUUsSUFEbUU7QUFFekVDLFlBQVEsMkJBRmlFLENBR3pFO0FBQ0E7O0FBSnlFLEdBQS9DLENBQTNCO0FBU0EsTUFBSUUsWUFBWSxHQUFHLElBQUlKLDhDQUFKLENBQVkseUJBQVosRUFBc0M7QUFDeERDLFFBQUksRUFBRSxJQURrRDtBQUV4REMsWUFBUSxrQkFGZ0QsQ0FHeEQ7QUFDQTs7QUFKd0QsR0FBdEMsQ0FBbkI7QUFRQUcsU0FBTyxDQUFDQyxHQUFSLENBQVlQLFlBQVosRUEzQnVCLENBNkJ2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FuQ0Q7O0FBc0NlRCx5RUFBZiIsImZpbGUiOiIuL2FwcC9qcy9tb2RlbC9pbml0UG9wdXBzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBvcHVwTUQgZnJvbSAnLi9wb3B1cCdcclxuXHJcbmltcG9ydCB7TWljcm9Nb2RhbH0gZnJvbSAnLi4vLi4vbGlicy9saWJzJ1xyXG5cclxuXHJcblxyXG5jb25zdCBpbml0UG9wdXBzID0gKCk9PiB7XHJcblx0bGV0IGNvdW50cnlQb3B1cCA9IG5ldyBQb3B1cE1EKCcuY291bnRyeS1maWx0ZXItd3JhcHBlcicse1xyXG5cdFx0dmlldzogdHJ1ZSxcclxuXHRcdGNvbnRlbnRzOiBgI2NvdW50cnktcG9wdXBgLFxyXG5cdFx0Ly8gcG9pbnRlclBvc2l0aW9uOiAncmlnaHQnLFxyXG5cdFx0Ly8gc2l6ZV9wb2ludGVyX3Bvc2l0aW9uOiAyMCxcclxuXHJcblx0fSlcclxuXHJcblxyXG5cdGxldCB0eXBlTWFudWZhY3R1cnlQb3B1cCA9IG5ldyBQb3B1cE1EKCcudHlwZS1tYW51ZmFjdHVyeS1maWx0ZXItd3JhcHBlcicse1xyXG5cdFx0dmlldzogdHJ1ZSxcclxuXHRcdGNvbnRlbnRzOiBgI3R5cGUtbWFudWZhY3R1cnktcG9wdXBgLFxyXG5cdFx0Ly8gcG9pbnRlclBvc2l0aW9uOiAncmlnaHQnLFxyXG5cdFx0Ly8gc2l6ZV9wb2ludGVyX3Bvc2l0aW9uOiAyMCxcclxuXHJcblx0fSlcclxuXHJcblxyXG5cdGxldCBjb250YXh0UG9wdXAgPSBuZXcgUG9wdXBNRCgnLmNvbnRhY3QtZmlsdGVyLXdyYXBwZXInLHtcclxuXHRcdHZpZXc6IHRydWUsXHJcblx0XHRjb250ZW50czogYCNjb250YWN0LXBvcHVwYCxcclxuXHRcdC8vIHBvaW50ZXJQb3NpdGlvbjogJ3JpZ2h0JyxcclxuXHRcdC8vIHNpemVfcG9pbnRlcl9wb3NpdGlvbjogMjAsXHJcblxyXG5cdH0pXHJcblxyXG5cdGNvbnNvbGUubG9nKGNvdW50cnlQb3B1cClcclxuXHJcblx0Ly8gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNpZGViYXJfX2ZpbHRlci1pdGVtJykuZm9yRWFjaChlbCA9PiB7XHJcblx0Ly8gXHRlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCl7XHJcblx0Ly8gXHRcdE1pY3JvTW9kYWwuc2hvdygnbW9kYWwtMScpXHJcblx0Ly8gXHR9KVxyXG5cdC8vIH0pXHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgaW5pdFBvcHVwcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app/js/model/initPopups.js\n");

/***/ }),

/***/ "./app/js/model/playAudioHover.js":
/*!****************************************!*\
  !*** ./app/js/model/playAudioHover.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// import {sidebarWrapper} from '../view'\nvar playAudioHover = function playAudioHover(items) {\n  var audio = document.createElement('audio'); // let source = document.createElement('source')\n  // let source2 = document.createElement('source')\n  // source.setAttribute('src', 'audio/click.mp3')\n  // source2.setAttribute('src', 'audio/click.ogg')\n\n  audio.innerHTML = \"\\n\\t<source src=\\\"audio/1.mp3\\\"><source>\\n\\n\\t\";\n  audio.volume = 0.04;\n  items.forEach(function (item) {\n    item.addEventListener('mouseenter', function () {\n      audio.play();\n    }); // item.addEventListener('mouseleave', function(){\n    // \taudio.pause();\n    // })\n  });\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (playAudioHover);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbW9kZWwvcGxheUF1ZGlvSG92ZXIuanM/ZmEzYSJdLCJuYW1lcyI6WyJwbGF5QXVkaW9Ib3ZlciIsIml0ZW1zIiwiYXVkaW8iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJ2b2x1bWUiLCJmb3JFYWNoIiwiaXRlbSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwbGF5Il0sIm1hcHBpbmdzIjoiQUFDQTtBQUFBO0FBRUEsSUFBTUEsY0FBYyxHQUFHLFNBQWpCQSxjQUFpQixDQUFDQyxLQUFELEVBQVc7QUFDakMsTUFBSUMsS0FBSyxHQUFHQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBWixDQURpQyxDQUVqQztBQUNBO0FBRUE7QUFDQTs7QUFHQUYsT0FBSyxDQUFDRyxTQUFOO0FBS0FILE9BQUssQ0FBQ0ksTUFBTixHQUFlLElBQWY7QUFFQUwsT0FBSyxDQUFDTSxPQUFOLENBQWMsVUFBQUMsSUFBSSxFQUFHO0FBQ3BCQSxRQUFJLENBQUNDLGdCQUFMLENBQXNCLFlBQXRCLEVBQW9DLFlBQVU7QUFDN0NQLFdBQUssQ0FBQ1EsSUFBTjtBQUNBLEtBRkQsRUFEb0IsQ0FJcEI7QUFDQTtBQUNBO0FBQ0EsR0FQRDtBQVFBLENBeEJEOztBQTJCZVYsNkVBQWYiLCJmaWxlIjoiLi9hcHAvanMvbW9kZWwvcGxheUF1ZGlvSG92ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLy8gaW1wb3J0IHtzaWRlYmFyV3JhcHBlcn0gZnJvbSAnLi4vdmlldydcclxuXHJcbmNvbnN0IHBsYXlBdWRpb0hvdmVyID0gKGl0ZW1zKSA9PiB7XHJcblx0bGV0IGF1ZGlvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKVxyXG5cdC8vIGxldCBzb3VyY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKVxyXG5cdC8vIGxldCBzb3VyY2UyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJylcclxuXHJcblx0Ly8gc291cmNlLnNldEF0dHJpYnV0ZSgnc3JjJywgJ2F1ZGlvL2NsaWNrLm1wMycpXHJcblx0Ly8gc291cmNlMi5zZXRBdHRyaWJ1dGUoJ3NyYycsICdhdWRpby9jbGljay5vZ2cnKVxyXG5cclxuXHJcblx0YXVkaW8uaW5uZXJIVE1MID0gYFxyXG5cdDxzb3VyY2Ugc3JjPVwiYXVkaW8vMS5tcDNcIj48c291cmNlPlxyXG5cclxuXHRgXHJcblxyXG5cdGF1ZGlvLnZvbHVtZSA9IDAuMDRcclxuXHJcblx0aXRlbXMuZm9yRWFjaChpdGVtPT4ge1xyXG5cdFx0aXRlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oKXtcclxuXHRcdFx0YXVkaW8ucGxheSgpO1xyXG5cdFx0fSlcclxuXHRcdC8vIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCl7XHJcblx0XHQvLyBcdGF1ZGlvLnBhdXNlKCk7XHJcblx0XHQvLyB9KVxyXG5cdH0pXHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBwbGF5QXVkaW9Ib3ZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app/js/model/playAudioHover.js\n");

/***/ }),

/***/ "./app/js/model/popup.js":
/*!*******************************!*\
  !*** ./app/js/model/popup.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nvar PopupMD = /*#__PURE__*/function () {\n  function PopupMD(element) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, PopupMD);\n\n    //модальное окно\n    this.modal = '<div class=\"modal_short\">\\n' + '    <svg>\\n' + '        <polygon points=\"0 10 10 0 10 20\"></polygon>\\n' + '    </svg>\\n' + '</div>'; //--------------------------------------------------------setting popup (поля модального окна)\n    //контейнер для содержимого (контент )\n\n    this.contents = ''; //позиция указателя. Возможные варианты: left, right, center.\n\n    this.pointer_position = 'center'; //размер отступа пипки от края. По умолчанию 0 //center\n\n    this.size_pointer_position = 0; //размер отступа модального окна. По умолчанию 0\n\n    this.size_position = 0; //сторона указателя. Возможные варианты: left, right, top, bottom.\n\n    this.modal_side = 'right'; //закрывать ли модальное окно, после вызова другого. Возможные варианты: true, false.\n\n    this.only_one = true; //дополнительные елементы при клике на которые не закрывать модальное окно. Передавать нужно название класса\n\n    this.element_off_close = []; //отображение попап окна. Возможные варианты: true, false.\n\n    this.view = false; //елемент по клику на который будет вылазить модальное окно\n\n    this.element = undefined; //стили елемента\n\n    this.style = ''; //отступ от позиционируемого елемента\n\n    this.margin_element = 0; //клонировать содержимое для модального окна или вырезать. Возможные варианты: true, false.\n\n    this.clone_contents = true; //уникальный атрибут елемента, при клике на который будет закрываться модальное окно. Не сработает без контента.\n\n    this.close_button = '.modal_close'; //закрывать ли модальное окно при кликах вне его границы. Возможные варианты: true, false.\n\n    this.close_auto = true; //-------------------------------------------------------начало работы\n\n    var indexOldElement = PopupMD.checkIndex(element);\n\n    if (indexOldElement === -1) {\n      //Метод преобразования строки в объект DOM\n      var DOMElement = document.createElement('div');\n      DOMElement.innerHTML = this.modal;\n      this.modal = DOMElement.children[0]; // console.log(DOMElement.innerHTML)\n      //вызов базовой настройки\n\n      this.firstSetting(data); //вызов метода проверки на то, стоит ли закрывать предыдущее модальное окно. Объязательный вызов перед методом setListObject()\n\n      PopupMD.checkPreviousModal(); //вызов отображение модального окна\n\n      if (this.view) {\n        this.popupView(element);\n      } //вызов метода который прицепит событие закрытия модального окна на кнопку\n\n\n      this.closeButton(element); //вызов добавления в список только что созданых объектов\n\n      this.setListObject(element); //вызов автозакрытия модального окна, при мисскликах или же спецом вне окна\n\n      if (this.close_auto) {\n        this.addEventDocument(element);\n      }\n    } else {\n      //console.log('This object isset ' + indexOldElement);\n      //console.log(PopupMD.list_object);\n      PopupMD.closeModal(indexOldElement);\n    }\n  } //Базовая настройка\n\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(PopupMD, [{\n    key: \"firstSetting\",\n    value: function firstSetting(data) {\n      if (data['pointerPosition'] !== undefined) {\n        if (['left', 'right', 'center'].indexOf(data['pointerPosition']) !== -1) {\n          this.pointer_position = data['pointerPosition'];\n        }\n      }\n\n      if (data['sizePointerPosition'] !== undefined) {\n        this.size_pointer_position = data['sizePointerPosition'];\n      }\n\n      if (data['modalSide'] !== undefined) {\n        if (['left', 'right', 'top', 'bottom'].indexOf(data['modalSide']) !== -1) {\n          this.modal_side = data['modalSide'];\n        }\n      }\n\n      if (data['onlyOne'] !== undefined) {\n        if (typeof data['onlyOne'] === 'boolean') {\n          this.only_one = data['onlyOne'];\n        }\n      }\n\n      if (data['elementOffClose'] !== undefined) {\n        if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(data['elementOffClose']) === 'object') {\n          this.element_off_close = data['elementOffClose'];\n        }\n      }\n\n      if (data['view'] !== undefined) {\n        if (typeof data['view'] === 'boolean') {\n          this.view = data['view'];\n        }\n      }\n\n      if (data['contents'] !== undefined) {\n        this.contents = data['contents'];\n      }\n\n      if (data['cloneContents'] !== undefined) {\n        if (typeof data['cloneContents'] === 'boolean') {\n          this.clone_contents = data['cloneContents'];\n        }\n      }\n\n      if (data['style'] !== undefined) {\n        if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(data['style']) === 'object') {\n          this.style = data['style'];\n        }\n      }\n\n      if (data['marginElement'] !== undefined) {\n        this.margin_element = data['marginElement'];\n      }\n\n      if (data['sizePosition'] !== undefined) {\n        this.size_position = data['sizePosition'];\n      }\n\n      if (data['closeButton'] !== undefined) {\n        this.close_button = data['closeButton'];\n      }\n\n      if (data['closeAuto'] !== undefined) {\n        if (typeof data['closeAuto'] === 'boolean') {\n          this.close_auto = data['closeAuto'];\n        }\n      }\n    } //Отображение модального окна\n\n  }, {\n    key: \"popupView\",\n    value: function popupView(element) {\n      this.element = document.querySelector(element);\n      var parent = this.element.parentElement; //так как мы передали елемент на который нам нужно кликать, мы должны рядом с ним впихнуть модальное окно.\n\n      parent.style.position = 'relative';\n      parent.append(this.modal); //this.element = document.querySelector(element); //определяю елемент на который нужно ориентироваться, делаю это второй раз, потому что добавление через innerHTML ломает указатель\n\n      this.modal = parent.children[parent.children.length - 1];\n\n      if (this.modal.style.display === 'none') {\n        this.modal.style.display = 'block';\n      } //вызываем функцию добавления содержимого в модальное окно\n\n\n      this.cloneContents(); //присваиваем стили\n\n      if (this.style !== '') {\n        this.setStyleModal();\n      } //позиция модального окна\n\n\n      this.savePositionModal();\n    } //функция вырезания или клонирования содержимого (контента) в модальное окно\n\n  }, {\n    key: \"cloneContents\",\n    value: function cloneContents() {\n      if (this.contents !== '') {\n        var content = '';\n        var div_content = document.querySelector(this.contents);\n\n        if (div_content !== null) {\n          if (this.clone_contents) {\n            content = div_content.cloneNode(true);\n          } else {\n            content = div_content;\n          }\n\n          if (content.style.display === 'none') {\n            content.style.display = 'block';\n          }\n\n          this.modal.append(content);\n        }\n      }\n    } //Вычисляем положение модального окна и соответствующей ему пипки\n\n  }, {\n    key: \"pointerSide\",\n    value: function pointerSide() {\n      var top, left, svgRotate, svgLeft, svgTop, svgTranslateX, svgTranslateY;\n\n      switch (this.modal_side) {\n        case 'top':\n          this.pointerPosition(this.modal.offsetWidth);\n          top = this.element.offsetTop - this.modal.offsetHeight - 8 - this.margin_element;\n          left = this.element.offsetLeft - (this.modal.offsetWidth - this.element.offsetWidth) / 2 + this.size_pointer_position;\n          svgRotate = 270;\n          svgLeft = this.size_pointer_position;\n          svgTop = this.modal.offsetHeight;\n          svgTranslateX = 50;\n          svgTranslateY = 40;\n          break;\n\n        case 'right':\n          console.log(this.modal.offsetHeight);\n          this.pointerPosition(this.modal.offsetHeight);\n          top = this.element.offsetTop + this.element.offsetHeight / 2 - this.modal.offsetHeight / 2 + this.size_pointer_position; // top = -this.modal.offsetHeight / 2;\n\n          left = this.element.offsetLeft + this.element.offsetWidth + 19 + this.margin_element;\n          svgRotate = 0;\n          svgLeft = 0;\n          svgTop = this.size_pointer_position;\n          svgTranslateX = 70;\n          svgTranslateY = 50;\n          break;\n\n        case 'bottom':\n          this.pointerPosition(this.modal.offsetWidth);\n          top = this.element.offsetTop + this.element.offsetHeight + 8 + this.margin_element;\n          left = this.element.offsetLeft - (this.modal.offsetWidth - this.element.offsetWidth) / 2 + this.size_position; //+ this.size_pointer_position\n\n          svgRotate = 90;\n          svgLeft = this.size_pointer_position;\n          svgTop = 0;\n          svgTranslateX = 50;\n          svgTranslateY = 60;\n          break;\n\n        case 'left':\n          this.pointerPosition(this.modal.offsetHeight);\n          top = this.element.offsetTop + this.element.offsetHeight / 2 - this.modal.offsetHeight / 2 + this.size_pointer_position;\n          left = this.element.offsetLeft - this.modal.offsetWidth - 8 - this.margin_element;\n          svgRotate = 180;\n          svgLeft = this.modal.offsetWidth;\n          svgTop = this.size_pointer_position;\n          svgTranslateX = 30;\n          svgTranslateY = 50;\n          break;\n      }\n\n      return {\n        'top': top,\n        'left': left,\n        'svgRotate': svgRotate,\n        'svgLeft': svgLeft,\n        'svgTop': svgTop,\n        'svgTranslateX': svgTranslateX,\n        'svgTranslateY': svgTranslateY\n      };\n    } //сохраняем позицию модального окна\n\n  }, {\n    key: \"savePositionModal\",\n    value: function savePositionModal() {\n      var pointer_side = this.pointerSide();\n      this.modal.style.top = pointer_side['top'] + 'px';\n      this.modal.style.left = pointer_side['left'] + 'px';\n      this.modal.children[0].style.transform = 'translate(-' + pointer_side['svgTranslateX'] + '%,-' + pointer_side['svgTranslateY'] + '%) rotate(' + pointer_side['svgRotate'] + 'deg)';\n      this.modal.children[0].style.top = pointer_side['svgTop'] + 'px';\n      this.modal.children[0].style.left = pointer_side['svgLeft'] + 'px';\n    } //функция которая автоматически разсчитывает позицию пипки модального окна, в случае если его позиция не задана пользователем.\n\n  }, {\n    key: \"pointerPosition\",\n    value: function pointerPosition(size) {\n      if (['left', 'right'].indexOf(this.pointer_position) !== -1) {\n        if (this.size_pointer_position === 0) {\n          // проверяем задавал ли позицию пользователь\n          this.size_pointer_position = size * 0.20 > 10 ? size / 4 : 0; // это если размер окажется меньше 10px, то проигнорировать отступ\n        }\n\n        if (this.pointer_position === 'left') {\n          // реверс\n          this.size_pointer_position = -this.size_pointer_position;\n        }\n      } else {\n        this.size_pointer_position = size / 2 - this.size_pointer_position;\n      }\n    } //присваиваем стили модальному окну\n\n  }, {\n    key: \"setStyleModal\",\n    value: function setStyleModal() {\n      if (this.style['color'] !== undefined) {\n        this.modal.style.color = this.style['color'];\n      }\n\n      if (this.style['backgroundColor'] !== undefined) {\n        this.modal.style.backgroundColor = this.style['backgroundColor'];\n        this.modal.children[0].children[0].style.stroke = this.style['backgroundColor'];\n        this.modal.children[0].children[0].style.fill = this.style['backgroundColor'];\n      }\n\n      if (this.style['borderRadius'] !== undefined) {\n        this.modal.style.borderRadius = this.style['borderRadius'];\n      }\n\n      if (this.style['padding'] !== undefined) {\n        this.modal.style.padding = this.style['padding'];\n      }\n    } //автозакрытие модального окна, при мисскликах или же спецом вне окна addEventDocument(),removeEventDocument(),checkEventClick(,)\n    //добавления события клика к документу\n\n  }, {\n    key: \"addEventDocument\",\n    value: function addEventDocument(element) {\n      var main = this;\n\n      document.querySelector(element).onmousedown = function (e) {\n        // console.log('This is I');\n        e.stopPropagation();\n      };\n\n      document.onmousedown = function (e) {\n        main.checkEventClick(e, element);\n      };\n    } //удаление события клика к документу\n\n  }, {\n    key: \"checkEventClick\",\n    //проверка клика. Если клик вне модального окна, тогда вызываем метод закрытия модального окна closeModal().\n    value: function checkEventClick(event, target) {\n      var index = PopupMD.checkIndex(target);\n\n      if (index !== -1) {\n        var data_number = PopupMD.list_object.data_number[index];\n        var element = event.target;\n\n        while (true) {\n          if (this.element_off_close.length) {\n            var temp = false;\n\n            for (var i = 0; i < this.element_off_close.length; i++) {\n              if (element.classList.contains(this.element_off_close[i])) {\n                temp = true;\n                break;\n              }\n            }\n\n            if (temp) {\n              break;\n            }\n          }\n\n          if (element.getAttribute('data-number') === data_number.toString()) {\n            break;\n          }\n\n          if (element.nodeName !== 'HTML') {\n            element = element.parentElement;\n          } else {\n            PopupMD.closeModal(index);\n            break;\n          }\n        }\n      }\n    } //закрытие модального окна\n\n  }, {\n    key: \"closeButton\",\n    //закрытие модального окна по клике на кнопку, для более точного определения елемента, используется так же идентификатор контента, если контента не будет, работать также не будет.\n    value: function closeButton(element) {\n      var button = document.querySelector(this.contents + ' ' + this.close_button);\n\n      if (button !== null) {\n        if (!button.hasAttribute('onclick')) {\n          button.setAttribute('onclick', 'PopupMD.closeModal(PopupMD.checkIndex(\\'' + element + '\\'))');\n        }\n      }\n    } //проверка на то, нужно ли закрывать ранее созданное модальное окно (only_one)\n\n  }, {\n    key: \"setListObject\",\n    //добавления в список только что созданых объектов\n    value: function setListObject(element) {\n      var number = 0;\n\n      if (PopupMD.list_object.data_number.length !== 0) {\n        number = PopupMD.list_object.data_number[PopupMD.list_object.data_number.length - 1];\n      }\n\n      this.modal.setAttribute('data-number', number + 1);\n      this.modal.setAttribute('data-modal', 'PopupMD');\n      PopupMD.list_object.element.push(element);\n      PopupMD.list_object.data_number.push(number + 1);\n      PopupMD.list_object.only_one.push(this.only_one);\n      PopupMD.list_object.clone_contents.push(this.clone_contents);\n      PopupMD.list_object.close_auto.push(this.close_auto);\n      PopupMD.list_object[\"this\"].push(this); //console.log('new object');\n    } //Уничтожение класса. Вызывается после добавление модального окна.\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      delete this;\n    }\n  }], [{\n    key: \"removeEventDocument\",\n    value: function removeEventDocument() {\n      document.onmousedown = null;\n    }\n  }, {\n    key: \"closeModal\",\n    value: function closeModal(index) {\n      var target = PopupMD.list_object.data_number[index];\n      var modal = document.querySelector('[data-number=\"' + target + '\"]'); //вызов проверки на дочерние модальные окна. Если модальные окна будут обнаружены, мы создадим рекурсию.\n\n      PopupMD.checkChildrenModal(target);\n\n      if (!PopupMD.list_object.clone_contents[index]) {\n        var body = document.body;\n        modal.children[1].style.display = 'none';\n\n        for (var i = body.children.length - 1; i >= 0; i--) {\n          if (body.children[i].nodeName !== 'SCRIPT') {\n            body.children[i].after(modal.children[1]);\n            break;\n          }\n\n          if (i === 0) {\n            body.append(modal.children[1]);\n          }\n        }\n      } //проверяем не висит ли событие на документе (оно нужно для того что бы закрывать окна вне их клика)\n\n\n      if (PopupMD.list_object.close_auto[index]) {\n        if (document.onmousedown !== null) {\n          PopupMD.removeEventDocument();\n        }\n      }\n\n      PopupMD.list_object.element.splice(index, 1);\n      PopupMD.list_object.data_number.splice(index, 1);\n      PopupMD.list_object.only_one.splice(index, 1);\n      PopupMD.list_object.clone_contents.splice(index, 1);\n      PopupMD.list_object.close_auto.splice(index, 1);\n      PopupMD.list_object[\"this\"].splice(index, 1);\n      modal.remove();\n    } //проверяем есть ли у модального окна, дочерние модальные окна, это избавит нас от потери данных.\n\n  }, {\n    key: \"checkChildrenModal\",\n    value: function checkChildrenModal(target) {\n      var modalChildren = document.querySelector('[data-number=\"' + target + '\"]' + ' ' + '[data-modal=\"PopupMD\"]');\n\n      if (modalChildren !== null) {\n        var number = modalChildren.getAttribute('data-number');\n\n        if (number !== null) {\n          PopupMD.closeModal(PopupMD.checkIndexOnNumber(number));\n        }\n      }\n    }\n  }, {\n    key: \"checkPreviousModal\",\n    value: function checkPreviousModal() {\n      var index = PopupMD.list_object.only_one.length - 1;\n\n      for (var i = index; i >= 0; i--) {\n        //console.log(PopupMD.list_object.only_one[i] + i);\n        if (PopupMD.list_object.only_one[i]) {\n          PopupMD.closeModal(i);\n        } else {//break; //тут возможен баг, когда у родительського модального окна будет параметр only_one=true, а у дочерних наоборот, тогда и родительський елемент останется висеть.\n        }\n      }\n    } //определения индекса модального окна в масиве, по названию атрибута, для дальнейшей работы с ним\n\n  }, {\n    key: \"checkIndex\",\n    value: function checkIndex(element) {\n      //console.log(element);\n      return PopupMD.list_object.element.indexOf(element);\n    } //определения индекса модального окна в масиве, по номеру модального окна, для дальнейшей работы с ним\n\n  }, {\n    key: \"checkIndexOnNumber\",\n    value: function checkIndexOnNumber(number) {\n      return PopupMD.list_object.data_number.indexOf(parseInt(number));\n    }\n  }]);\n\n  return PopupMD;\n}();\n\nPopupMD.list_object = {\n  \"element\": [],\n  //атрибут который затриггерил объект\n  \"data_number\": [],\n  //атрибут по которому можно идентифицировать модально окно\n  \"only_one\": [],\n  //значение что обозначает состояние модального окна, после вызова второго. Закрывать или нет.\n  \"clone_contents\": [],\n  //клонирован ли контент, если нет, то нужно его вернуть по закрытию.\n  \"close_auto\": [],\n  //автозакрытие модального окна\n  \"this\": [] //пока не знаю, пригодится ли этот параметр\n\n}; // Я закончил на том, что обнаружил баг с настройкой \"only_one\", не правильно закрывать только последне открытое модальное окно, нужно закрывать сразу все, так как могут быть вложения.\n// Короче нужно переделать функцию checkPreviousModal()\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PopupMD);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbW9kZWwvcG9wdXAuanM/NDg2OCJdLCJuYW1lcyI6WyJQb3B1cE1EIiwiZWxlbWVudCIsImRhdGEiLCJtb2RhbCIsImNvbnRlbnRzIiwicG9pbnRlcl9wb3NpdGlvbiIsInNpemVfcG9pbnRlcl9wb3NpdGlvbiIsInNpemVfcG9zaXRpb24iLCJtb2RhbF9zaWRlIiwib25seV9vbmUiLCJlbGVtZW50X29mZl9jbG9zZSIsInZpZXciLCJ1bmRlZmluZWQiLCJzdHlsZSIsIm1hcmdpbl9lbGVtZW50IiwiY2xvbmVfY29udGVudHMiLCJjbG9zZV9idXR0b24iLCJjbG9zZV9hdXRvIiwiaW5kZXhPbGRFbGVtZW50IiwiY2hlY2tJbmRleCIsIkRPTUVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJjaGlsZHJlbiIsImZpcnN0U2V0dGluZyIsImNoZWNrUHJldmlvdXNNb2RhbCIsInBvcHVwVmlldyIsImNsb3NlQnV0dG9uIiwic2V0TGlzdE9iamVjdCIsImFkZEV2ZW50RG9jdW1lbnQiLCJjbG9zZU1vZGFsIiwiaW5kZXhPZiIsInF1ZXJ5U2VsZWN0b3IiLCJwYXJlbnQiLCJwYXJlbnRFbGVtZW50IiwicG9zaXRpb24iLCJhcHBlbmQiLCJsZW5ndGgiLCJkaXNwbGF5IiwiY2xvbmVDb250ZW50cyIsInNldFN0eWxlTW9kYWwiLCJzYXZlUG9zaXRpb25Nb2RhbCIsImNvbnRlbnQiLCJkaXZfY29udGVudCIsImNsb25lTm9kZSIsInRvcCIsImxlZnQiLCJzdmdSb3RhdGUiLCJzdmdMZWZ0Iiwic3ZnVG9wIiwic3ZnVHJhbnNsYXRlWCIsInN2Z1RyYW5zbGF0ZVkiLCJwb2ludGVyUG9zaXRpb24iLCJvZmZzZXRXaWR0aCIsIm9mZnNldFRvcCIsIm9mZnNldEhlaWdodCIsIm9mZnNldExlZnQiLCJjb25zb2xlIiwibG9nIiwicG9pbnRlcl9zaWRlIiwicG9pbnRlclNpZGUiLCJ0cmFuc2Zvcm0iLCJzaXplIiwiY29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzdHJva2UiLCJmaWxsIiwiYm9yZGVyUmFkaXVzIiwicGFkZGluZyIsIm1haW4iLCJvbm1vdXNlZG93biIsImUiLCJzdG9wUHJvcGFnYXRpb24iLCJjaGVja0V2ZW50Q2xpY2siLCJldmVudCIsInRhcmdldCIsImluZGV4IiwiZGF0YV9udW1iZXIiLCJsaXN0X29iamVjdCIsInRlbXAiLCJpIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJnZXRBdHRyaWJ1dGUiLCJ0b1N0cmluZyIsIm5vZGVOYW1lIiwiYnV0dG9uIiwiaGFzQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwibnVtYmVyIiwicHVzaCIsImNoZWNrQ2hpbGRyZW5Nb2RhbCIsImJvZHkiLCJhZnRlciIsInJlbW92ZUV2ZW50RG9jdW1lbnQiLCJzcGxpY2UiLCJyZW1vdmUiLCJtb2RhbENoaWxkcmVuIiwiY2hlY2tJbmRleE9uTnVtYmVyIiwicGFyc2VJbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBQU1BLE87QUFDRixtQkFBWUMsT0FBWixFQUFnQztBQUFBLFFBQVhDLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFDNUI7QUFDQSxTQUFLQyxLQUFMLEdBQWEsZ0NBQ1QsYUFEUyxHQUVULHdEQUZTLEdBR1QsY0FIUyxHQUlULFFBSkosQ0FGNEIsQ0FRNUI7QUFFQTs7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLEVBQWhCLENBWDRCLENBWTVCOztBQUNBLFNBQUtDLGdCQUFMLEdBQXdCLFFBQXhCLENBYjRCLENBYzVCOztBQUNBLFNBQUtDLHFCQUFMLEdBQTZCLENBQTdCLENBZjRCLENBZ0I1Qjs7QUFDQSxTQUFLQyxhQUFMLEdBQXFCLENBQXJCLENBakI0QixDQWtCNUI7O0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixPQUFsQixDQW5CNEIsQ0FvQjVCOztBQUNBLFNBQUtDLFFBQUwsR0FBZ0IsSUFBaEIsQ0FyQjRCLENBc0I1Qjs7QUFDQSxTQUFLQyxpQkFBTCxHQUF5QixFQUF6QixD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QUFDOUIsYUFBTzFGLE9BQU8sQ0FBQytFLFdBQVIsQ0FBb0JELFdBQXBCLENBQWdDOUMsT0FBaEMsQ0FBd0NvRSxRQUFRLENBQUNWLE1BQUQsQ0FBaEQsQ0FBUDtBQUNIOzs7Ozs7QUEwQkwxRixPQUFPLENBQUMrRSxXQUFSLEdBQXNCO0FBQ2xCLGFBQVcsRUFETztBQUNIO0FBQ2YsaUJBQWUsRUFGRztBQUVDO0FBQ25CLGNBQVksRUFITTtBQUdGO0FBQ2hCLG9CQUFrQixFQUpBO0FBSUk7QUFDdEIsZ0JBQWMsRUFMSTtBQUtBO0FBQ2xCLFVBQVEsRUFOVSxDQU1OOztBQU5NLENBQXRCLEMsQ0FTQTtBQUNBOztBQUdlL0Usc0VBQWYiLCJmaWxlIjoiLi9hcHAvanMvbW9kZWwvcG9wdXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBQb3B1cE1EIHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGRhdGEgPSB7fSkge1xyXG4gICAgICAgIC8v0LzQvtC00LDQu9GM0L3QvtC1INC+0LrQvdC+XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9ICc8ZGl2IGNsYXNzPVwibW9kYWxfc2hvcnRcIj5cXG4nICtcclxuICAgICAgICAgICAgJyAgICA8c3ZnPlxcbicgK1xyXG4gICAgICAgICAgICAnICAgICAgICA8cG9seWdvbiBwb2ludHM9XCIwIDEwIDEwIDAgMTAgMjBcIj48L3BvbHlnb24+XFxuJyArXHJcbiAgICAgICAgICAgICcgICAgPC9zdmc+XFxuJyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nO1xyXG5cclxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tc2V0dGluZyBwb3B1cCAo0L/QvtC70Y8g0LzQvtC00LDQu9GM0L3QvtCz0L4g0L7QutC90LApXHJcblxyXG4gICAgICAgIC8v0LrQvtC90YLQtdC50L3QtdGAINC00LvRjyDRgdC+0LTQtdGA0LbQuNC80L7Qs9C+ICjQutC+0L3RgtC10L3RgiApXHJcbiAgICAgICAgdGhpcy5jb250ZW50cyA9ICcnO1xyXG4gICAgICAgIC8v0L/QvtC30LjRhtC40Y8g0YPQutCw0LfQsNGC0LXQu9GPLiDQktC+0LfQvNC+0LbQvdGL0LUg0LLQsNGA0LjQsNC90YLRizogbGVmdCwgcmlnaHQsIGNlbnRlci5cclxuICAgICAgICB0aGlzLnBvaW50ZXJfcG9zaXRpb24gPSAnY2VudGVyJztcclxuICAgICAgICAvL9GA0LDQt9C80LXRgCDQvtGC0YHRgtGD0L/QsCDQv9C40L/QutC4INC+0YIg0LrRgNCw0Y8uINCf0L4g0YPQvNC+0LvRh9Cw0L3QuNGOIDAgLy9jZW50ZXJcclxuICAgICAgICB0aGlzLnNpemVfcG9pbnRlcl9wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgLy/RgNCw0LfQvNC10YAg0L7RgtGB0YLRg9C/0LAg0LzQvtC00LDQu9GM0L3QvtCz0L4g0L7QutC90LAuINCf0L4g0YPQvNC+0LvRh9Cw0L3QuNGOIDBcclxuICAgICAgICB0aGlzLnNpemVfcG9zaXRpb24gPSAwO1xyXG4gICAgICAgIC8v0YHRgtC+0YDQvtC90LAg0YPQutCw0LfQsNGC0LXQu9GPLiDQktC+0LfQvNC+0LbQvdGL0LUg0LLQsNGA0LjQsNC90YLRizogbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLlxyXG4gICAgICAgIHRoaXMubW9kYWxfc2lkZSA9ICdyaWdodCc7XHJcbiAgICAgICAgLy/Qt9Cw0LrRgNGL0LLQsNGC0Ywg0LvQuCDQvNC+0LTQsNC70YzQvdC+0LUg0L7QutC90L4sINC/0L7RgdC70LUg0LLRi9C30L7QstCwINC00YDRg9Cz0L7Qs9C+LiDQktC+0LfQvNC+0LbQvdGL0LUg0LLQsNGA0LjQsNC90YLRizogdHJ1ZSwgZmFsc2UuXHJcbiAgICAgICAgdGhpcy5vbmx5X29uZSA9IHRydWU7XHJcbiAgICAgICAgLy/QtNC+0L/QvtC70L3QuNGC0LXQu9GM0L3Ri9C1INC10LvQtdC80LXQvdGC0Ysg0L/RgNC4INC60LvQuNC60LUg0L3QsCDQutC+0YLQvtGA0YvQtSDQvdC1INC30LDQutGA0YvQstCw0YLRjCDQvNC+0LTQsNC70YzQvdC+0LUg0L7QutC90L4uINCf0LXRgNC10LTQsNCy0LDRgtGMINC90YPQttC90L4g0L3QsNC30LLQsNC90LjQtSDQutC70LDRgdGB0LBcclxuICAgICAgICB0aGlzLmVsZW1lbnRfb2ZmX2Nsb3NlID0gW107XHJcbiAgICAgICAgLy/QvtGC0L7QsdGA0LDQttC10L3QuNC1INC/0L7Qv9Cw0L8g0L7QutC90LAuINCS0L7Qt9C80L7QttC90YvQtSDQstCw0YDQuNCw0L3RgtGLOiB0cnVlLCBmYWxzZS5cclxuICAgICAgICB0aGlzLnZpZXcgPSBmYWxzZTtcclxuICAgICAgICAvL9C10LvQtdC80LXQvdGCINC/0L4g0LrQu9C40LrRgyDQvdCwINC60L7RgtC+0YDRi9C5INCx0YPQtNC10YIg0LLRi9C70LDQt9C40YLRjCDQvNC+0LTQsNC70YzQvdC+0LUg0L7QutC90L5cclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy/RgdGC0LjQu9C4INC10LvQtdC80LXQvdGC0LBcclxuICAgICAgICB0aGlzLnN0eWxlID0gJyc7XHJcbiAgICAgICAgLy/QvtGC0YHRgtGD0L8g0L7RgiDQv9C+0LfQuNGG0LjQvtC90LjRgNGD0LXQvNC+0LPQviDQtdC70LXQvNC10L3RgtCwXHJcbiAgICAgICAgdGhpcy5tYXJnaW5fZWxlbWVudCA9IDA7XHJcbiAgICAgICAgLy/QutC70L7QvdC40YDQvtCy0LDRgtGMINGB0L7QtNC10YDQttC40LzQvtC1INC00LvRjyDQvNC+0LTQsNC70YzQvdC+0LPQviDQvtC60L3QsCDQuNC70Lgg0LLRi9GA0LXQt9Cw0YLRjC4g0JLQvtC30LzQvtC20L3Ri9C1INCy0LDRgNC40LDQvdGC0Ys6IHRydWUsIGZhbHNlLlxyXG4gICAgICAgIHRoaXMuY2xvbmVfY29udGVudHMgPSB0cnVlO1xyXG4gICAgICAgIC8v0YPQvdC40LrQsNC70YzQvdGL0Lkg0LDRgtGA0LjQsdGD0YIg0LXQu9C10LzQtdC90YLQsCwg0L/RgNC4INC60LvQuNC60LUg0L3QsCDQutC+0YLQvtGA0YvQuSDQsdGD0LTQtdGCINC30LDQutGA0YvQstCw0YLRjNGB0Y8g0LzQvtC00LDQu9GM0L3QvtC1INC+0LrQvdC+LiDQndC1INGB0YDQsNCx0L7RgtCw0LXRgiDQsdC10Lcg0LrQvtC90YLQtdC90YLQsC5cclxuICAgICAgICB0aGlzLmNsb3NlX2J1dHRvbiA9ICcubW9kYWxfY2xvc2UnO1xyXG4gICAgICAgIC8v0LfQsNC60YDRi9Cy0LDRgtGMINC70Lgg0LzQvtC00LDQu9GM0L3QvtC1INC+0LrQvdC+INC/0YDQuCDQutC70LjQutCw0YUg0LLQvdC1INC10LPQviDQs9GA0LDQvdC40YbRiy4g0JLQvtC30LzQvtC20L3Ri9C1INCy0LDRgNC40LDQvdGC0Ys6IHRydWUsIGZhbHNlLlxyXG4gICAgICAgIHRoaXMuY2xvc2VfYXV0byA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLdC90LDRh9Cw0LvQviDRgNCw0LHQvtGC0YtcclxuXHJcbiAgICAgICAgbGV0IGluZGV4T2xkRWxlbWVudCA9IFBvcHVwTUQuY2hlY2tJbmRleChlbGVtZW50KTtcclxuICAgICAgICBpZiAoaW5kZXhPbGRFbGVtZW50ID09PSAtMSkge1xyXG4gICAgICAgICAgICAvL9Cc0LXRgtC+0LQg0L/RgNC10L7QsdGA0LDQt9C+0LLQsNC90LjRjyDRgdGC0YDQvtC60Lgg0LIg0L7QsdGK0LXQutGCIERPTVxyXG4gICAgICAgICAgICBsZXQgRE9NRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBET01FbGVtZW50LmlubmVySFRNTCA9IHRoaXMubW9kYWw7XHJcbiAgICAgICAgICAgIHRoaXMubW9kYWwgPSBET01FbGVtZW50LmNoaWxkcmVuWzBdO1xyXG5cclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coRE9NRWxlbWVudC5pbm5lckhUTUwpXHJcblxyXG4gICAgICAgICAgICAvL9Cy0YvQt9C+0LIg0LHQsNC30L7QstC+0Lkg0L3QsNGB0YLRgNC+0LnQutC4XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RTZXR0aW5nKGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgLy/QstGL0LfQvtCyINC80LXRgtC+0LTQsCDQv9GA0L7QstC10YDQutC4INC90LAg0YLQviwg0YHRgtC+0LjRgiDQu9C4INC30LDQutGA0YvQstCw0YLRjCDQv9GA0LXQtNGL0LTRg9GJ0LXQtSDQvNC+0LTQsNC70YzQvdC+0LUg0L7QutC90L4uINCe0LHRitGP0LfQsNGC0LXQu9GM0L3Ri9C5INCy0YvQt9C+0LIg0L/QtdGA0LXQtCDQvNC10YLQvtC00L7QvCBzZXRMaXN0T2JqZWN0KClcclxuICAgICAgICAgICAgUG9wdXBNRC5jaGVja1ByZXZpb3VzTW9kYWwoKTtcclxuXHJcbiAgICAgICAgICAgIC8v0LLRi9C30L7QsiDQvtGC0L7QsdGA0LDQttC10L3QuNC1INC80L7QtNCw0LvRjNC90L7Qs9C+INC+0LrQvdCwXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBWaWV3KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL9Cy0YvQt9C+0LIg0LzQtdGC0L7QtNCwINC60L7RgtC+0YDRi9C5INC/0YDQuNGG0LXQv9C40YIg0YHQvtCx0YvRgtC40LUg0LfQsNC60YDRi9GC0LjRjyDQvNC+0LTQsNC70YzQvdC+0LPQviDQvtC60L3QsCDQvdCwINC60L3QvtC/0LrRg1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlQnV0dG9uKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgLy/QstGL0LfQvtCyINC00L7QsdCw0LLQu9C10L3QuNGPINCyINGB0L/QuNGB0L7QuiDRgtC+0LvRjNC60L4g0YfRgtC+INGB0L7Qt9C00LDQvdGL0YUg0L7QsdGK0LXQutGC0L7QslxyXG4gICAgICAgICAgICB0aGlzLnNldExpc3RPYmplY3QoZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAvL9Cy0YvQt9C+0LIg0LDQstGC0L7Qt9Cw0LrRgNGL0YLQuNGPINC80L7QtNCw0LvRjNC90L7Qs9C+INC+0LrQvdCwLCDQv9GA0Lgg0LzQuNGB0YHQutC70LjQutCw0YUg0LjQu9C4INC20LUg0YHQv9C10YbQvtC8INCy0L3QtSDQvtC60L3QsFxyXG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZV9hdXRvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50RG9jdW1lbnQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnVGhpcyBvYmplY3QgaXNzZXQgJyArIGluZGV4T2xkRWxlbWVudCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coUG9wdXBNRC5saXN0X29iamVjdCk7XHJcbiAgICAgICAgICAgIFBvcHVwTUQuY2xvc2VNb2RhbChpbmRleE9sZEVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL9CR0LDQt9C+0LLQsNGPINC90LDRgdGC0YDQvtC50LrQsFxyXG4gICAgZmlyc3RTZXR0aW5nKGRhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YVsncG9pbnRlclBvc2l0aW9uJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlciddLmluZGV4T2YoZGF0YVsncG9pbnRlclBvc2l0aW9uJ10pICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyX3Bvc2l0aW9uID0gZGF0YVsncG9pbnRlclBvc2l0aW9uJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGFbJ3NpemVQb2ludGVyUG9zaXRpb24nXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZV9wb2ludGVyX3Bvc2l0aW9uID0gZGF0YVsnc2l6ZVBvaW50ZXJQb3NpdGlvbiddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YVsnbW9kYWxTaWRlJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKGRhdGFbJ21vZGFsU2lkZSddKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9kYWxfc2lkZSA9IGRhdGFbJ21vZGFsU2lkZSddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRhWydvbmx5T25lJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChkYXRhWydvbmx5T25lJ10pID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25seV9vbmUgPSBkYXRhWydvbmx5T25lJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGFbJ2VsZW1lbnRPZmZDbG9zZSddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoZGF0YVsnZWxlbWVudE9mZkNsb3NlJ10pID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50X29mZl9jbG9zZSA9IGRhdGFbJ2VsZW1lbnRPZmZDbG9zZSddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGF0YVsndmlldyddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoZGF0YVsndmlldyddKSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcgPSBkYXRhWyd2aWV3J107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGFbJ2NvbnRlbnRzJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gZGF0YVsnY29udGVudHMnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGFbJ2Nsb25lQ29udGVudHMnXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGRhdGFbJ2Nsb25lQ29udGVudHMnXSkgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9uZV9jb250ZW50cyA9IGRhdGFbJ2Nsb25lQ29udGVudHMnXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YVsnc3R5bGUnXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGRhdGFbJ3N0eWxlJ10pID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZSA9IGRhdGFbJ3N0eWxlJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGFbJ21hcmdpbkVsZW1lbnQnXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFyZ2luX2VsZW1lbnQgPSBkYXRhWydtYXJnaW5FbGVtZW50J107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRhWydzaXplUG9zaXRpb24nXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZV9wb3NpdGlvbiA9IGRhdGFbJ3NpemVQb3NpdGlvbiddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YVsnY2xvc2VCdXR0b24nXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VfYnV0dG9uID0gZGF0YVsnY2xvc2VCdXR0b24nXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGFbJ2Nsb3NlQXV0byddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoZGF0YVsnY2xvc2VBdXRvJ10pID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VfYXV0byA9IGRhdGFbJ2Nsb3NlQXV0byddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8v0J7RgtC+0LHRgNCw0LbQtdC90LjQtSDQvNC+0LTQsNC70YzQvdC+0LPQviDQvtC60L3QsFxyXG4gICAgcG9wdXBWaWV3KGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpO1xyXG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudDsgLy/RgtCw0Log0LrQsNC6INC80Ysg0L/QtdGA0LXQtNCw0LvQuCDQtdC70LXQvNC10L3RgiDQvdCwINC60L7RgtC+0YDRi9C5INC90LDQvCDQvdGD0LbQvdC+INC60LvQuNC60LDRgtGMLCDQvNGLINC00L7Qu9C20L3RiyDRgNGP0LTQvtC8INGBINC90LjQvCDQstC/0LjRhdC90YPRgtGMINC80L7QtNCw0LvRjNC90L7QtSDQvtC60L3Qvi5cclxuICAgICAgICBwYXJlbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgIHBhcmVudC5hcHBlbmQodGhpcy5tb2RhbCk7XHJcbiAgICAgICAgLy90aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpOyAvL9C+0L/RgNC10LTQtdC70Y/RjiDQtdC70LXQvNC10L3RgiDQvdCwINC60L7RgtC+0YDRi9C5INC90YPQttC90L4g0L7RgNC40LXQvdGC0LjRgNC+0LLQsNGC0YzRgdGPLCDQtNC10LvQsNGOINGN0YLQviDQstGC0L7RgNC+0Lkg0YDQsNC3LCDQv9C+0YLQvtC80YMg0YfRgtC+INC00L7QsdCw0LLQu9C10L3QuNC1INGH0LXRgNC10LcgaW5uZXJIVE1MINC70L7QvNCw0LXRgiDRg9C60LDQt9Cw0YLQtdC70YxcclxuICAgICAgICB0aGlzLm1vZGFsID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcclxuICAgICAgICBpZiAodGhpcy5tb2RhbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8v0LLRi9C30YvQstCw0LXQvCDRhNGD0L3QutGG0LjRjiDQtNC+0LHQsNCy0LvQtdC90LjRjyDRgdC+0LTQtdGA0LbQuNC80L7Qs9C+INCyINC80L7QtNCw0LvRjNC90L7QtSDQvtC60L3QvlxyXG4gICAgICAgIHRoaXMuY2xvbmVDb250ZW50cygpO1xyXG5cclxuICAgICAgICAvL9C/0YDQuNGB0LLQsNC40LLQsNC10Lwg0YHRgtC40LvQuFxyXG4gICAgICAgIGlmICh0aGlzLnN0eWxlICE9PSAnJykge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlTW9kYWwoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8v0L/QvtC30LjRhtC40Y8g0LzQvtC00LDQu9GM0L3QvtCz0L4g0L7QutC90LBcclxuICAgICAgICB0aGlzLnNhdmVQb3NpdGlvbk1vZGFsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/RhNGD0L3QutGG0LjRjyDQstGL0YDQtdC30LDQvdC40Y8g0LjQu9C4INC60LvQvtC90LjRgNC+0LLQsNC90LjRjyDRgdC+0LTQtdGA0LbQuNC80L7Qs9C+ICjQutC+0L3RgtC10L3RgtCwKSDQsiDQvNC+0LTQsNC70YzQvdC+0LUg0L7QutC90L5cclxuICAgIGNsb25lQ29udGVudHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudHMgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICAgICAgICAgIGxldCBkaXZfY29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5jb250ZW50cyk7XHJcbiAgICAgICAgICAgIGlmIChkaXZfY29udGVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xvbmVfY29udGVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gZGl2X2NvbnRlbnQuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gZGl2X2NvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RhbC5hcHBlbmQoY29udGVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy/QktGL0YfQuNGB0LvRj9C10Lwg0L/QvtC70L7QttC10L3QuNC1INC80L7QtNCw0LvRjNC90L7Qs9C+INC+0LrQvdCwINC4INGB0L7QvtGC0LLQtdGC0YHRgtCy0YPRjtGJ0LXQuSDQtdC80YMg0L/QuNC/0LrQuFxyXG4gICAgcG9pbnRlclNpZGUoKSB7XHJcbiAgICAgICAgbGV0IHRvcCwgbGVmdCwgc3ZnUm90YXRlLCBzdmdMZWZ0LCBzdmdUb3AsIHN2Z1RyYW5zbGF0ZVgsIHN2Z1RyYW5zbGF0ZVk7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGFsX3NpZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclBvc2l0aW9uKHRoaXMubW9kYWwub2Zmc2V0V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgdG9wID0gKHRoaXMuZWxlbWVudC5vZmZzZXRUb3AgLSB0aGlzLm1vZGFsLm9mZnNldEhlaWdodCAtIDgpIC0gdGhpcy5tYXJnaW5fZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSAodGhpcy5lbGVtZW50Lm9mZnNldExlZnQgLSAodGhpcy5tb2RhbC5vZmZzZXRXaWR0aCAtIHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCkgLyAyKSArIHRoaXMuc2l6ZV9wb2ludGVyX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc3ZnUm90YXRlID0gMjcwO1xyXG4gICAgICAgICAgICAgICAgc3ZnTGVmdCA9IHRoaXMuc2l6ZV9wb2ludGVyX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc3ZnVG9wID0gdGhpcy5tb2RhbC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBzdmdUcmFuc2xhdGVYID0gNTA7XHJcbiAgICAgICAgICAgICAgICBzdmdUcmFuc2xhdGVZID0gNDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5tb2RhbC5vZmZzZXRIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJQb3NpdGlvbih0aGlzLm1vZGFsLm9mZnNldEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0b3AgPSAodGhpcy5lbGVtZW50Lm9mZnNldFRvcCArIHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQgLyAyIC0gdGhpcy5tb2RhbC5vZmZzZXRIZWlnaHQgLyAyKSArIHRoaXMuc2l6ZV9wb2ludGVyX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgLy8gdG9wID0gLXRoaXMubW9kYWwub2Zmc2V0SGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSAodGhpcy5lbGVtZW50Lm9mZnNldExlZnQgKyB0aGlzLmVsZW1lbnQub2Zmc2V0V2lkdGggKyAxOSkgKyB0aGlzLm1hcmdpbl9lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgc3ZnUm90YXRlID0gMDtcclxuICAgICAgICAgICAgICAgIHN2Z0xlZnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgc3ZnVG9wID0gdGhpcy5zaXplX3BvaW50ZXJfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBzdmdUcmFuc2xhdGVYID0gNzA7XHJcbiAgICAgICAgICAgICAgICBzdmdUcmFuc2xhdGVZID0gNTA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclBvc2l0aW9uKHRoaXMubW9kYWwub2Zmc2V0V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgdG9wID0gKHRoaXMuZWxlbWVudC5vZmZzZXRUb3AgKyB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgOCkgKyB0aGlzLm1hcmdpbl9lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9ICh0aGlzLmVsZW1lbnQub2Zmc2V0TGVmdCAtICh0aGlzLm1vZGFsLm9mZnNldFdpZHRoIC0gdGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoKSAvIDIpICsgdGhpcy5zaXplX3Bvc2l0aW9uOyAvLysgdGhpcy5zaXplX3BvaW50ZXJfcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIHN2Z1JvdGF0ZSA9IDkwO1xyXG4gICAgICAgICAgICAgICAgc3ZnTGVmdCA9IHRoaXMuc2l6ZV9wb2ludGVyX3Bvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc3ZnVG9wID0gMDtcclxuICAgICAgICAgICAgICAgIHN2Z1RyYW5zbGF0ZVggPSA1MDtcclxuICAgICAgICAgICAgICAgIHN2Z1RyYW5zbGF0ZVkgPSA2MDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclBvc2l0aW9uKHRoaXMubW9kYWwub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRvcCA9ICh0aGlzLmVsZW1lbnQub2Zmc2V0VG9wICsgdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCAvIDIgLSB0aGlzLm1vZGFsLm9mZnNldEhlaWdodCAvIDIpICsgdGhpcy5zaXplX3BvaW50ZXJfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gKHRoaXMuZWxlbWVudC5vZmZzZXRMZWZ0IC0gdGhpcy5tb2RhbC5vZmZzZXRXaWR0aCAtIDgpIC0gdGhpcy5tYXJnaW5fZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHN2Z1JvdGF0ZSA9IDE4MDtcclxuICAgICAgICAgICAgICAgIHN2Z0xlZnQgPSB0aGlzLm1vZGFsLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgc3ZnVG9wID0gdGhpcy5zaXplX3BvaW50ZXJfcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBzdmdUcmFuc2xhdGVYID0gMzA7XHJcbiAgICAgICAgICAgICAgICBzdmdUcmFuc2xhdGVZID0gNTA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ3RvcCc6IHRvcCxcclxuICAgICAgICAgICAgJ2xlZnQnOiBsZWZ0LFxyXG4gICAgICAgICAgICAnc3ZnUm90YXRlJzogc3ZnUm90YXRlLFxyXG4gICAgICAgICAgICAnc3ZnTGVmdCc6IHN2Z0xlZnQsXHJcbiAgICAgICAgICAgICdzdmdUb3AnOiBzdmdUb3AsXHJcbiAgICAgICAgICAgICdzdmdUcmFuc2xhdGVYJzogc3ZnVHJhbnNsYXRlWCxcclxuICAgICAgICAgICAgJ3N2Z1RyYW5zbGF0ZVknOiBzdmdUcmFuc2xhdGVZLFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL9GB0L7RhdGA0LDQvdGP0LXQvCDQv9C+0LfQuNGG0LjRjiDQvNC+0LTQsNC70YzQvdC+0LPQviDQvtC60L3QsFxyXG4gICAgc2F2ZVBvc2l0aW9uTW9kYWwoKSB7XHJcbiAgICAgICAgbGV0IHBvaW50ZXJfc2lkZSA9IHRoaXMucG9pbnRlclNpZGUoKTtcclxuICAgICAgICB0aGlzLm1vZGFsLnN0eWxlLnRvcCA9IHBvaW50ZXJfc2lkZVsndG9wJ10gKyAncHgnO1xyXG4gICAgICAgIHRoaXMubW9kYWwuc3R5bGUubGVmdCA9IHBvaW50ZXJfc2lkZVsnbGVmdCddICsgJ3B4JztcclxuICAgICAgICB0aGlzLm1vZGFsLmNoaWxkcmVuWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLScgKyBwb2ludGVyX3NpZGVbJ3N2Z1RyYW5zbGF0ZVgnXSArICclLC0nICsgcG9pbnRlcl9zaWRlWydzdmdUcmFuc2xhdGVZJ10gKyAnJSkgcm90YXRlKCcgKyBwb2ludGVyX3NpZGVbJ3N2Z1JvdGF0ZSddICsgJ2RlZyknO1xyXG4gICAgICAgIHRoaXMubW9kYWwuY2hpbGRyZW5bMF0uc3R5bGUudG9wID0gcG9pbnRlcl9zaWRlWydzdmdUb3AnXSArICdweCc7XHJcbiAgICAgICAgdGhpcy5tb2RhbC5jaGlsZHJlblswXS5zdHlsZS5sZWZ0ID0gcG9pbnRlcl9zaWRlWydzdmdMZWZ0J10gKyAncHgnO1xyXG4gICAgfVxyXG5cclxuICAgIC8v0YTRg9C90LrRhtC40Y8g0LrQvtGC0L7RgNCw0Y8g0LDQstGC0L7QvNCw0YLQuNGH0LXRgdC60Lgg0YDQsNC30YHRh9C40YLRi9Cy0LDQtdGCINC/0L7Qt9C40YbQuNGOINC/0LjQv9C60Lgg0LzQvtC00LDQu9GM0L3QvtCz0L4g0L7QutC90LAsINCyINGB0LvRg9GH0LDQtSDQtdGB0LvQuCDQtdCz0L4g0L/QvtC30LjRhtC40Y8g0L3QtSDQt9Cw0LTQsNC90LAg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9C10LwuXHJcbiAgICBwb2ludGVyUG9zaXRpb24oc2l6ZSkge1xyXG4gICAgICAgIGlmIChbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHRoaXMucG9pbnRlcl9wb3NpdGlvbikgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpemVfcG9pbnRlcl9wb3NpdGlvbiA9PT0gMCkgeyAvLyDQv9GA0L7QstC10YDRj9C10Lwg0LfQsNC00LDQstCw0Lsg0LvQuCDQv9C+0LfQuNGG0LjRjiDQv9C+0LvRjNC30L7QstCw0YLQtdC70YxcclxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZV9wb2ludGVyX3Bvc2l0aW9uID0gKHNpemUgKiAwLjIwKSA+IDEwID8gKHNpemUgLyA0KSA6IDA7IC8vINGN0YLQviDQtdGB0LvQuCDRgNCw0LfQvNC10YAg0L7QutCw0LbQtdGC0YHRjyDQvNC10L3RjNGI0LUgMTBweCwg0YLQviDQv9GA0L7QuNCz0L3QvtGA0LjRgNC+0LLQsNGC0Ywg0L7RgtGB0YLRg9C/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlcl9wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7IC8vINGA0LXQstC10YDRgVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplX3BvaW50ZXJfcG9zaXRpb24gPSAtdGhpcy5zaXplX3BvaW50ZXJfcG9zaXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5zaXplX3BvaW50ZXJfcG9zaXRpb24gPSAoc2l6ZSAvIDIpIC0gdGhpcy5zaXplX3BvaW50ZXJfcG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8v0L/RgNC40YHQstCw0LjQstCw0LXQvCDRgdGC0LjQu9C4INC80L7QtNCw0LvRjNC90L7QvNGDINC+0LrQvdGDXHJcbiAgICBzZXRTdHlsZU1vZGFsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0eWxlWydjb2xvciddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RhbC5zdHlsZS5jb2xvciA9IHRoaXMuc3R5bGVbJ2NvbG9yJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0eWxlWydiYWNrZ3JvdW5kQ29sb3InXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kYWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5zdHlsZVsnYmFja2dyb3VuZENvbG9yJ107XHJcbiAgICAgICAgICAgIHRoaXMubW9kYWwuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uc3R5bGUuc3Ryb2tlID0gdGhpcy5zdHlsZVsnYmFja2dyb3VuZENvbG9yJ107XHJcbiAgICAgICAgICAgIHRoaXMubW9kYWwuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uc3R5bGUuZmlsbCA9IHRoaXMuc3R5bGVbJ2JhY2tncm91bmRDb2xvciddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdHlsZVsnYm9yZGVyUmFkaXVzJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGFsLnN0eWxlLmJvcmRlclJhZGl1cyA9IHRoaXMuc3R5bGVbJ2JvcmRlclJhZGl1cyddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdHlsZVsncGFkZGluZyddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RhbC5zdHlsZS5wYWRkaW5nID0gdGhpcy5zdHlsZVsncGFkZGluZyddO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL9Cw0LLRgtC+0LfQsNC60YDRi9GC0LjQtSDQvNC+0LTQsNC70YzQvdC+0LPQviDQvtC60L3QsCwg0L/RgNC4INC80LjRgdGB0LrQu9C40LrQsNGFINC40LvQuCDQttC1INGB0L/QtdGG0L7QvCDQstC90LUg0L7QutC90LAgYWRkRXZlbnREb2N1bWVudCgpLHJlbW92ZUV2ZW50RG9jdW1lbnQoKSxjaGVja0V2ZW50Q2xpY2soLClcclxuICAgIC8v0LTQvtCx0LDQstC70LXQvdC40Y8g0YHQvtCx0YvRgtC40Y8g0LrQu9C40LrQsCDQuiDQtNC+0LrRg9C80LXQvdGC0YNcclxuICAgIGFkZEV2ZW50RG9jdW1lbnQoZWxlbWVudCkge1xyXG4gICAgICAgIGxldCBtYWluID0gdGhpcztcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpLm9ubW91c2Vkb3duID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1RoaXMgaXMgSScpO1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGRvY3VtZW50Lm9ubW91c2Vkb3duID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgbWFpbi5jaGVja0V2ZW50Q2xpY2soZSwgZWxlbWVudCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvL9GD0LTQsNC70LXQvdC40LUg0YHQvtCx0YvRgtC40Y8g0LrQu9C40LrQsCDQuiDQtNC+0LrRg9C80LXQvdGC0YNcclxuICAgIHN0YXRpYyByZW1vdmVFdmVudERvY3VtZW50KCkge1xyXG4gICAgICAgIGRvY3VtZW50Lm9ubW91c2Vkb3duID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvL9C/0YDQvtCy0LXRgNC60LAg0LrQu9C40LrQsC4g0JXRgdC70Lgg0LrQu9C40Log0LLQvdC1INC80L7QtNCw0LvRjNC90L7Qs9C+INC+0LrQvdCwLCDRgtC+0LPQtNCwINCy0YvQt9GL0LLQsNC10Lwg0LzQtdGC0L7QtCDQt9Cw0LrRgNGL0YLQuNGPINC80L7QtNCw0LvRjNC90L7Qs9C+INC+0LrQvdCwIGNsb3NlTW9kYWwoKS5cclxuICAgIGNoZWNrRXZlbnRDbGljayhldmVudCwgdGFyZ2V0KSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gUG9wdXBNRC5jaGVja0luZGV4KHRhcmdldCk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICBsZXQgZGF0YV9udW1iZXIgPSBQb3B1cE1ELmxpc3Rfb2JqZWN0LmRhdGFfbnVtYmVyW2luZGV4XTtcclxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBldmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVsZW1lbnRfb2ZmX2Nsb3NlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZWxlbWVudF9vZmZfY2xvc2UubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmVsZW1lbnRfb2ZmX2Nsb3NlW2ldKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRlbXApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbnVtYmVyJykgPT09IGRhdGFfbnVtYmVyLnRvU3RyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lICE9PSAnSFRNTCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBQb3B1cE1ELmNsb3NlTW9kYWwoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL9C30LDQutGA0YvRgtC40LUg0LzQvtC00LDQu9GM0L3QvtCz0L4g0L7QutC90LBcclxuICAgIHN0YXRpYyBjbG9zZU1vZGFsKGluZGV4KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IFBvcHVwTUQubGlzdF9vYmplY3QuZGF0YV9udW1iZXJbaW5kZXhdO1xyXG4gICAgICAgIGxldCBtb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW51bWJlcj1cIicgKyB0YXJnZXQgKyAnXCJdJyk7XHJcblxyXG4gICAgICAgIC8v0LLRi9C30L7QsiDQv9GA0L7QstC10YDQutC4INC90LAg0LTQvtGH0LXRgNC90LjQtSDQvNC+0LTQsNC70YzQvdGL0LUg0L7QutC90LAuINCV0YHQu9C4INC80L7QtNCw0LvRjNC90YvQtSDQvtC60L3QsCDQsdGD0LTRg9GCINC+0LHQvdCw0YDRg9C20LXQvdGLLCDQvNGLINGB0L7Qt9C00LDQtNC40Lwg0YDQtdC60YPRgNGB0LjRji5cclxuICAgICAgICBQb3B1cE1ELmNoZWNrQ2hpbGRyZW5Nb2RhbCh0YXJnZXQpO1xyXG5cclxuICAgICAgICBpZiAoIVBvcHVwTUQubGlzdF9vYmplY3QuY2xvbmVfY29udGVudHNbaW5kZXhdKSB7XHJcbiAgICAgICAgICAgIGxldCBib2R5ID0gZG9jdW1lbnQuYm9keTtcclxuICAgICAgICAgICAgbW9kYWwuY2hpbGRyZW5bMV0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJvZHkuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChib2R5LmNoaWxkcmVuW2ldLm5vZGVOYW1lICE9PSAnU0NSSVBUJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuY2hpbGRyZW5baV0uYWZ0ZXIobW9kYWwuY2hpbGRyZW5bMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZChtb2RhbC5jaGlsZHJlblsxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8v0L/RgNC+0LLQtdGA0Y/QtdC8INC90LUg0LLQuNGB0LjRgiDQu9C4INGB0L7QsdGL0YLQuNC1INC90LAg0LTQvtC60YPQvNC10L3RgtC1ICjQvtC90L4g0L3Rg9C20L3QviDQtNC70Y8g0YLQvtCz0L4g0YfRgtC+INCx0Ysg0LfQsNC60YDRi9Cy0LDRgtGMINC+0LrQvdCwINCy0L3QtSDQuNGFINC60LvQuNC60LApXHJcbiAgICAgICAgaWYgKFBvcHVwTUQubGlzdF9vYmplY3QuY2xvc2VfYXV0b1tpbmRleF0pIHtcclxuICAgICAgICAgICAgaWYgKGRvY3VtZW50Lm9ubW91c2Vkb3duICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBQb3B1cE1ELnJlbW92ZUV2ZW50RG9jdW1lbnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgUG9wdXBNRC5saXN0X29iamVjdC5lbGVtZW50LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgUG9wdXBNRC5saXN0X29iamVjdC5kYXRhX251bWJlci5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIFBvcHVwTUQubGlzdF9vYmplY3Qub25seV9vbmUuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICBQb3B1cE1ELmxpc3Rfb2JqZWN0LmNsb25lX2NvbnRlbnRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgUG9wdXBNRC5saXN0X29iamVjdC5jbG9zZV9hdXRvLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgUG9wdXBNRC5saXN0X29iamVjdC50aGlzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgbW9kYWwucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/Qv9GA0L7QstC10YDRj9C10Lwg0LXRgdGC0Ywg0LvQuCDRgyDQvNC+0LTQsNC70YzQvdC+0LPQviDQvtC60L3QsCwg0LTQvtGH0LXRgNC90LjQtSDQvNC+0LTQsNC70YzQvdGL0LUg0L7QutC90LAsINGN0YLQviDQuNC30LHQsNCy0LjRgiDQvdCw0YEg0L7RgiDQv9C+0YLQtdGA0Lgg0LTQsNC90L3Ri9GFLlxyXG4gICAgc3RhdGljIGNoZWNrQ2hpbGRyZW5Nb2RhbCh0YXJnZXQpIHtcclxuICAgICAgICBsZXQgbW9kYWxDaGlsZHJlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW51bWJlcj1cIicgKyB0YXJnZXQgKyAnXCJdJyArICcgJyArICdbZGF0YS1tb2RhbD1cIlBvcHVwTURcIl0nKTtcclxuICAgICAgICBpZiAobW9kYWxDaGlsZHJlbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZXQgbnVtYmVyID0gbW9kYWxDaGlsZHJlbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtbnVtYmVyJyk7XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIFBvcHVwTUQuY2xvc2VNb2RhbChQb3B1cE1ELmNoZWNrSW5kZXhPbk51bWJlcihudW1iZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL9C30LDQutGA0YvRgtC40LUg0LzQvtC00LDQu9GM0L3QvtCz0L4g0L7QutC90LAg0L/QviDQutC70LjQutC1INC90LAg0LrQvdC+0L/QutGDLCDQtNC70Y8g0LHQvtC70LXQtSDRgtC+0YfQvdC+0LPQviDQvtC/0YDQtdC00LXQu9C10L3QuNGPINC10LvQtdC80LXQvdGC0LAsINC40YHQv9C+0LvRjNC30YPQtdGC0YHRjyDRgtCw0Log0LbQtSDQuNC00LXQvdGC0LjRhNC40LrQsNGC0L7RgCDQutC+0L3RgtC10L3RgtCwLCDQtdGB0LvQuCDQutC+0L3RgtC10L3RgtCwINC90LUg0LHRg9C00LXRgiwg0YDQsNCx0L7RgtCw0YLRjCDRgtCw0LrQttC1INC90LUg0LHRg9C00LXRgi5cclxuICAgIGNsb3NlQnV0dG9uKGVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgYnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmNvbnRlbnRzICsgJyAnICsgdGhpcy5jbG9zZV9idXR0b24pO1xyXG4gICAgICAgIGlmIChidXR0b24gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKCFidXR0b24uaGFzQXR0cmlidXRlKCdvbmNsaWNrJykpIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ29uY2xpY2snLCAnUG9wdXBNRC5jbG9zZU1vZGFsKFBvcHVwTUQuY2hlY2tJbmRleChcXCcnICsgZWxlbWVudCArICdcXCcpKScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8v0L/RgNC+0LLQtdGA0LrQsCDQvdCwINGC0L4sINC90YPQttC90L4g0LvQuCDQt9Cw0LrRgNGL0LLQsNGC0Ywg0YDQsNC90LXQtSDRgdC+0LfQtNCw0L3QvdC+0LUg0LzQvtC00LDQu9GM0L3QvtC1INC+0LrQvdC+IChvbmx5X29uZSlcclxuICAgIHN0YXRpYyBjaGVja1ByZXZpb3VzTW9kYWwoKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gUG9wdXBNRC5saXN0X29iamVjdC5vbmx5X29uZS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhQb3B1cE1ELmxpc3Rfb2JqZWN0Lm9ubHlfb25lW2ldICsgaSk7XHJcbiAgICAgICAgICAgIGlmIChQb3B1cE1ELmxpc3Rfb2JqZWN0Lm9ubHlfb25lW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBQb3B1cE1ELmNsb3NlTW9kYWwoaSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2JyZWFrOyAvL9GC0YPRgiDQstC+0LfQvNC+0LbQtdC9INCx0LDQsywg0LrQvtCz0LTQsCDRgyDRgNC+0LTQuNGC0LXQu9GM0YHRjNC60L7Qs9C+INC80L7QtNCw0LvRjNC90L7Qs9C+INC+0LrQvdCwINCx0YPQtNC10YIg0L/QsNGA0LDQvNC10YLRgCBvbmx5X29uZT10cnVlLCDQsCDRgyDQtNC+0YfQtdGA0L3QuNGFINC90LDQvtCx0L7RgNC+0YIsINGC0L7Qs9C00LAg0Lgg0YDQvtC00LjRgtC10LvRjNGB0YzQutC40Lkg0LXQu9C10LzQtdC90YIg0L7RgdGC0LDQvdC10YLRgdGPINCy0LjRgdC10YLRjC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL9C+0L/RgNC10LTQtdC70LXQvdC40Y8g0LjQvdC00LXQutGB0LAg0LzQvtC00LDQu9GM0L3QvtCz0L4g0L7QutC90LAg0LIg0LzQsNGB0LjQstC1LCDQv9C+INC90LDQt9Cy0LDQvdC40Y4g0LDRgtGA0LjQsdGD0YLQsCwg0LTQu9GPINC00LDQu9GM0L3QtdC50YjQtdC5INGA0LDQsdC+0YLRiyDRgSDQvdC40LxcclxuICAgIHN0YXRpYyBjaGVja0luZGV4KGVsZW1lbnQpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKGVsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiBQb3B1cE1ELmxpc3Rfb2JqZWN0LmVsZW1lbnQuaW5kZXhPZihlbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvL9C+0L/RgNC10LTQtdC70LXQvdC40Y8g0LjQvdC00LXQutGB0LAg0LzQvtC00LDQu9GM0L3QvtCz0L4g0L7QutC90LAg0LIg0LzQsNGB0LjQstC1LCDQv9C+INC90L7QvNC10YDRgyDQvNC+0LTQsNC70YzQvdC+0LPQviDQvtC60L3QsCwg0LTQu9GPINC00LDQu9GM0L3QtdC50YjQtdC5INGA0LDQsdC+0YLRiyDRgSDQvdC40LxcclxuICAgIHN0YXRpYyBjaGVja0luZGV4T25OdW1iZXIobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIFBvcHVwTUQubGlzdF9vYmplY3QuZGF0YV9udW1iZXIuaW5kZXhPZihwYXJzZUludChudW1iZXIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvL9C00L7QsdCw0LLQu9C10L3QuNGPINCyINGB0L/QuNGB0L7QuiDRgtC+0LvRjNC60L4g0YfRgtC+INGB0L7Qt9C00LDQvdGL0YUg0L7QsdGK0LXQutGC0L7QslxyXG4gICAgc2V0TGlzdE9iamVjdChlbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IG51bWJlciA9IDA7XHJcbiAgICAgICAgaWYgKFBvcHVwTUQubGlzdF9vYmplY3QuZGF0YV9udW1iZXIubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIG51bWJlciA9IFBvcHVwTUQubGlzdF9vYmplY3QuZGF0YV9udW1iZXJbUG9wdXBNRC5saXN0X29iamVjdC5kYXRhX251bWJlci5sZW5ndGggLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tb2RhbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbnVtYmVyJywgbnVtYmVyICsgMSk7XHJcbiAgICAgICAgdGhpcy5tb2RhbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwnLCAnUG9wdXBNRCcpO1xyXG5cclxuICAgICAgICBQb3B1cE1ELmxpc3Rfb2JqZWN0LmVsZW1lbnQucHVzaChlbGVtZW50KTtcclxuICAgICAgICBQb3B1cE1ELmxpc3Rfb2JqZWN0LmRhdGFfbnVtYmVyLnB1c2gobnVtYmVyICsgMSk7XHJcbiAgICAgICAgUG9wdXBNRC5saXN0X29iamVjdC5vbmx5X29uZS5wdXNoKHRoaXMub25seV9vbmUpO1xyXG4gICAgICAgIFBvcHVwTUQubGlzdF9vYmplY3QuY2xvbmVfY29udGVudHMucHVzaCh0aGlzLmNsb25lX2NvbnRlbnRzKTtcclxuICAgICAgICBQb3B1cE1ELmxpc3Rfb2JqZWN0LmNsb3NlX2F1dG8ucHVzaCh0aGlzLmNsb3NlX2F1dG8pO1xyXG4gICAgICAgIFBvcHVwTUQubGlzdF9vYmplY3QudGhpcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ25ldyBvYmplY3QnKTtcclxuICAgIH1cclxuXHJcbiAgICAvL9Cj0L3QuNGH0YLQvtC20LXQvdC40LUg0LrQu9Cw0YHRgdCwLiDQktGL0LfRi9Cy0LDQtdGC0YHRjyDQv9C+0YHQu9C1INC00L7QsdCw0LLQu9C10L3QuNC1INC80L7QtNCw0LvRjNC90L7Qs9C+INC+0LrQvdCwLlxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBkZWxldGUgdGhpcztcclxuICAgIH1cclxufVxyXG5cclxuUG9wdXBNRC5saXN0X29iamVjdCA9IHtcclxuICAgIFwiZWxlbWVudFwiOiBbXSwgLy/QsNGC0YDQuNCx0YPRgiDQutC+0YLQvtGA0YvQuSDQt9Cw0YLRgNC40LPQs9C10YDQuNC7INC+0LHRitC10LrRglxyXG4gICAgXCJkYXRhX251bWJlclwiOiBbXSwgLy/QsNGC0YDQuNCx0YPRgiDQv9C+INC60L7RgtC+0YDQvtC80YMg0LzQvtC20L3QviDQuNC00LXQvdGC0LjRhNC40YbQuNGA0L7QstCw0YLRjCDQvNC+0LTQsNC70YzQvdC+INC+0LrQvdC+XHJcbiAgICBcIm9ubHlfb25lXCI6IFtdLCAvL9C30L3QsNGH0LXQvdC40LUg0YfRgtC+INC+0LHQvtC30L3QsNGH0LDQtdGCINGB0L7RgdGC0L7Rj9C90LjQtSDQvNC+0LTQsNC70YzQvdC+0LPQviDQvtC60L3QsCwg0L/QvtGB0LvQtSDQstGL0LfQvtCy0LAg0LLRgtC+0YDQvtCz0L4uINCX0LDQutGA0YvQstCw0YLRjCDQuNC70Lgg0L3QtdGCLlxyXG4gICAgXCJjbG9uZV9jb250ZW50c1wiOiBbXSwgLy/QutC70L7QvdC40YDQvtCy0LDQvSDQu9C4INC60L7QvdGC0LXQvdGCLCDQtdGB0LvQuCDQvdC10YIsINGC0L4g0L3Rg9C20L3QviDQtdCz0L4g0LLQtdGA0L3Rg9GC0Ywg0L/QviDQt9Cw0LrRgNGL0YLQuNGOLlxyXG4gICAgXCJjbG9zZV9hdXRvXCI6IFtdLCAvL9Cw0LLRgtC+0LfQsNC60YDRi9GC0LjQtSDQvNC+0LTQsNC70YzQvdC+0LPQviDQvtC60L3QsFxyXG4gICAgXCJ0aGlzXCI6IFtdLCAvL9C/0L7QutCwINC90LUg0LfQvdCw0Y4sINC/0YDQuNCz0L7QtNC40YLRgdGPINC70Lgg0Y3RgtC+0YIg0L/QsNGA0LDQvNC10YLRgFxyXG59O1xyXG5cclxuLy8g0K8g0LfQsNC60L7QvdGH0LjQuyDQvdCwINGC0L7QvCwg0YfRgtC+INC+0LHQvdCw0YDRg9C20LjQuyDQsdCw0LMg0YEg0L3QsNGB0YLRgNC+0LnQutC+0LkgXCJvbmx5X29uZVwiLCDQvdC1INC/0YDQsNCy0LjQu9GM0L3QviDQt9Cw0LrRgNGL0LLQsNGC0Ywg0YLQvtC70YzQutC+INC/0L7RgdC70LXQtNC90LUg0L7RgtC60YDRi9GC0L7QtSDQvNC+0LTQsNC70YzQvdC+0LUg0L7QutC90L4sINC90YPQttC90L4g0LfQsNC60YDRi9Cy0LDRgtGMINGB0YDQsNC30YMg0LLRgdC1LCDRgtCw0Log0LrQsNC6INC80L7Qs9GD0YIg0LHRi9GC0Ywg0LLQu9C+0LbQtdC90LjRjy5cclxuLy8g0JrQvtGA0L7Rh9C1INC90YPQttC90L4g0L/QtdGA0LXQtNC10LvQsNGC0Ywg0YTRg9C90LrRhtC40Y4gY2hlY2tQcmV2aW91c01vZGFsKClcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBQb3B1cE1EIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./app/js/model/popup.js\n");

/***/ }),

/***/ "./app/js/model/sidebarListsToggle.js":
/*!********************************************!*\
  !*** ./app/js/model/sidebarListsToggle.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// import {OverlayScrollbars} from '../../libs/libs'\n// import {sidebarWrapper} from '../view'\nvar sidebarListsToggle = function sidebarListsToggle(items) {\n  items.forEach(function (item, i, arr) {\n    item.addEventListener('click', function () {\n      arr.forEach(function (a) {\n        a.classList.remove('active');\n      });\n      this.classList.add('active');\n    });\n  });\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (sidebarListsToggle);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbW9kZWwvc2lkZWJhckxpc3RzVG9nZ2xlLmpzP2ZhODIiXSwibmFtZXMiOlsic2lkZWJhckxpc3RzVG9nZ2xlIiwiaXRlbXMiLCJmb3JFYWNoIiwiaXRlbSIsImkiLCJhcnIiLCJhZGRFdmVudExpc3RlbmVyIiwiYSIsImNsYXNzTGlzdCIsInJlbW92ZSIsImFkZCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBR0EsSUFBTUEsa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQixDQUFDQyxLQUFELEVBQVU7QUFDcENBLE9BQUssQ0FBQ0MsT0FBTixDQUFjLFVBQUNDLElBQUQsRUFBT0MsQ0FBUCxFQUFVQyxHQUFWLEVBQWlCO0FBRTlCRixRQUFJLENBQUNHLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFlBQVk7QUFDMUNELFNBQUcsQ0FBQ0gsT0FBSixDQUFZLFVBQUFLLENBQUMsRUFBRztBQUNmQSxTQUFDLENBQUNDLFNBQUYsQ0FBWUMsTUFBWixDQUFtQixRQUFuQjtBQUNBLE9BRkQ7QUFHQSxXQUFLRCxTQUFMLENBQWVFLEdBQWYsQ0FBbUIsUUFBbkI7QUFDQSxLQUxEO0FBTUEsR0FSRDtBQVNBLENBVkQ7O0FBZWVWLGlGQUFmIiwiZmlsZSI6Ii4vYXBwL2pzL21vZGVsL3NpZGViYXJMaXN0c1RvZ2dsZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCB7T3ZlcmxheVNjcm9sbGJhcnN9IGZyb20gJy4uLy4uL2xpYnMvbGlicydcclxuLy8gaW1wb3J0IHtzaWRlYmFyV3JhcHBlcn0gZnJvbSAnLi4vdmlldydcclxuXHJcblxyXG5jb25zdCBzaWRlYmFyTGlzdHNUb2dnbGUgPSAoaXRlbXMpPT4ge1xyXG5cdGl0ZW1zLmZvckVhY2goKGl0ZW0sIGksIGFycik9PiB7XHJcblx0XHRcclxuXHRcdGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGFyci5mb3JFYWNoKGE9PiB7XHJcblx0XHRcdFx0YS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKVxyXG5cdFx0XHR9KVxyXG5cdFx0XHR0aGlzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXHJcblx0XHR9KVxyXG5cdH0pXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHNpZGViYXJMaXN0c1RvZ2dsZVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./app/js/model/sidebarListsToggle.js\n");

/***/ }),

/***/ "./app/js/view/index.js":
/*!******************************!*\
  !*** ./app/js/view/index.js ***!
  \******************************/
/*! exports provided: sidebarWrapper, sidebarListItems, rows */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sidebarWrapper\", function() { return sidebarWrapper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sidebarListItems\", function() { return sidebarListItems; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rows\", function() { return rows; });\nvar sidebarWrapper = document.querySelector('.sidebar__wrapper');\nvar sidebarListItems = document.querySelectorAll('.sidebar__list-item');\nvar rows = document.querySelectorAll('.row');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvdmlldy9pbmRleC5qcz9hY2Y1Il0sIm5hbWVzIjpbInNpZGViYXJXcmFwcGVyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwic2lkZWJhckxpc3RJdGVtcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyb3dzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQU1BLGNBQWMsR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLG1CQUF2QixDQUF2QjtBQUNBLElBQU1DLGdCQUFnQixHQUFHRixRQUFRLENBQUNHLGdCQUFULENBQTBCLHFCQUExQixDQUF6QjtBQUNBLElBQU1DLElBQUksR0FBR0osUUFBUSxDQUFDRyxnQkFBVCxDQUEwQixNQUExQixDQUFiIiwiZmlsZSI6Ii4vYXBwL2pzL3ZpZXcvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBzaWRlYmFyV3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zaWRlYmFyX193cmFwcGVyJyk7XHJcbmNvbnN0IHNpZGViYXJMaXN0SXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc2lkZWJhcl9fbGlzdC1pdGVtJyk7XHJcbmNvbnN0IHJvd3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucm93Jyk7XHJcblxyXG5cclxuXHJcbmV4cG9ydCB7XHJcblx0c2lkZWJhcldyYXBwZXIsXHJcblx0c2lkZWJhckxpc3RJdGVtcyxcclxuXHRyb3dzXHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./app/js/view/index.js\n");

/***/ }),

/***/ "./app/libs/libs.js":
/*!**************************!*\
  !*** ./app/libs/libs.js ***!
  \**************************/
/*! exports provided: OverlayScrollbars, MicroModal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! overlayscrollbars */ \"./node_modules/overlayscrollbars/js/OverlayScrollbars.js\");\n/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(overlayscrollbars__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"OverlayScrollbars\", function() { return overlayscrollbars__WEBPACK_IMPORTED_MODULE_0___default.a; });\n/* harmony import */ var micromodal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromodal */ \"./node_modules/micromodal/dist/micromodal.es.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MicroModal\", function() { return micromodal__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n// import noUiSlider from 'nouislider'\n// import wNumb from 'wNumb'\n// import Chart from 'chart.js'\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbGlicy9saWJzLmpzPzcxYWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vYXBwL2xpYnMvbGlicy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCBub1VpU2xpZGVyIGZyb20gJ25vdWlzbGlkZXInXHJcbi8vIGltcG9ydCB3TnVtYiBmcm9tICd3TnVtYidcclxuLy8gaW1wb3J0IENoYXJ0IGZyb20gJ2NoYXJ0LmpzJ1xyXG5pbXBvcnQgT3ZlcmxheVNjcm9sbGJhcnMgZnJvbSAnb3ZlcmxheXNjcm9sbGJhcnMnXHJcbmltcG9ydCBNaWNyb01vZGFsIGZyb20gJ21pY3JvbW9kYWwnXHJcblxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IHtcclxuXHRPdmVybGF5U2Nyb2xsYmFycyxcclxuXHRNaWNyb01vZGFsXHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./app/libs/libs.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcz85NzBiIl0sIm5hbWVzIjpbIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxlQUFULENBQXlCQyxRQUF6QixFQUFtQ0MsV0FBbkMsRUFBZ0Q7QUFDOUMsTUFBSSxFQUFFRCxRQUFRLFlBQVlDLFdBQXRCLENBQUosRUFBd0M7QUFDdEMsVUFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUNEO0FBQ0Y7O0FBRURDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsZUFBakIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/classCallCheck.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcz81YmMzIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxpQkFBVCxDQUEyQkMsTUFBM0IsRUFBbUNDLEtBQW5DLEVBQTBDO0FBQ3hDLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDRSxNQUExQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxRQUFJRSxVQUFVLEdBQUdILEtBQUssQ0FBQ0MsQ0FBRCxDQUF0QjtBQUNBRSxjQUFVLENBQUNDLFVBQVgsR0FBd0JELFVBQVUsQ0FBQ0MsVUFBWCxJQUF5QixLQUFqRDtBQUNBRCxjQUFVLENBQUNFLFlBQVgsR0FBMEIsSUFBMUI7QUFDQSxRQUFJLFdBQVdGLFVBQWYsRUFBMkJBLFVBQVUsQ0FBQ0csUUFBWCxHQUFzQixJQUF0QjtBQUMzQkMsVUFBTSxDQUFDQyxjQUFQLENBQXNCVCxNQUF0QixFQUE4QkksVUFBVSxDQUFDTSxHQUF6QyxFQUE4Q04sVUFBOUM7QUFDRDtBQUNGOztBQUVELFNBQVNPLFlBQVQsQ0FBc0JDLFdBQXRCLEVBQW1DQyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7QUFDMUQsTUFBSUQsVUFBSixFQUFnQmQsaUJBQWlCLENBQUNhLFdBQVcsQ0FBQ0csU0FBYixFQUF3QkYsVUFBeEIsQ0FBakI7QUFDaEIsTUFBSUMsV0FBSixFQUFpQmYsaUJBQWlCLENBQUNhLFdBQUQsRUFBY0UsV0FBZCxDQUFqQjtBQUNqQixTQUFPRixXQUFQO0FBQ0Q7O0FBRURJLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQk4sWUFBakIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/createClass.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/NzAzNyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiXSwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCO0FBQ3BCOztBQUVBLE1BQUksT0FBT0MsTUFBUCxLQUFrQixVQUFsQixJQUFnQyxPQUFPQSxNQUFNLENBQUNDLFFBQWQsS0FBMkIsUUFBL0QsRUFBeUU7QUFDdkVDLFVBQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsT0FBTyxHQUFHLFNBQVNBLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCO0FBQy9DLGFBQU8sT0FBT0EsR0FBZDtBQUNELEtBRkQ7QUFHRCxHQUpELE1BSU87QUFDTEcsVUFBTSxDQUFDQyxPQUFQLEdBQWlCTCxPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7QUFDL0MsYUFBT0EsR0FBRyxJQUFJLE9BQU9DLE1BQVAsS0FBa0IsVUFBekIsSUFBdUNELEdBQUcsQ0FBQ0ssV0FBSixLQUFvQkosTUFBM0QsSUFBcUVELEdBQUcsS0FBS0MsTUFBTSxDQUFDSyxTQUFwRixHQUFnRyxRQUFoRyxHQUEyRyxPQUFPTixHQUF6SDtBQUNELEtBRkQ7QUFHRDs7QUFFRCxTQUFPRCxPQUFPLENBQUNDLEdBQUQsQ0FBZDtBQUNEOztBQUVERyxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLE9BQWpCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n");

/***/ }),

/***/ "./node_modules/micromodal/dist/micromodal.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/micromodal/dist/micromodal.es.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar MicroModal = function () {\n  var FOCUSABLE_ELEMENTS = ['a[href]', 'area[href]', 'input:not([disabled]):not([type=\"hidden\"]):not([aria-hidden])', 'select:not([disabled]):not([aria-hidden])', 'textarea:not([disabled]):not([aria-hidden])', 'button:not([disabled]):not([aria-hidden])', 'iframe', 'object', 'embed', '[contenteditable]', '[tabindex]:not([tabindex^=\"-\"])'];\n\n  var Modal = /*#__PURE__*/function () {\n    function Modal(_ref) {\n      var targetModal = _ref.targetModal,\n          _ref$triggers = _ref.triggers,\n          triggers = _ref$triggers === void 0 ? [] : _ref$triggers,\n          _ref$onShow = _ref.onShow,\n          onShow = _ref$onShow === void 0 ? function () {} : _ref$onShow,\n          _ref$onClose = _ref.onClose,\n          onClose = _ref$onClose === void 0 ? function () {} : _ref$onClose,\n          _ref$openTrigger = _ref.openTrigger,\n          openTrigger = _ref$openTrigger === void 0 ? 'data-micromodal-trigger' : _ref$openTrigger,\n          _ref$closeTrigger = _ref.closeTrigger,\n          closeTrigger = _ref$closeTrigger === void 0 ? 'data-micromodal-close' : _ref$closeTrigger,\n          _ref$openClass = _ref.openClass,\n          openClass = _ref$openClass === void 0 ? 'is-open' : _ref$openClass,\n          _ref$disableScroll = _ref.disableScroll,\n          disableScroll = _ref$disableScroll === void 0 ? false : _ref$disableScroll,\n          _ref$disableFocus = _ref.disableFocus,\n          disableFocus = _ref$disableFocus === void 0 ? false : _ref$disableFocus,\n          _ref$awaitCloseAnimat = _ref.awaitCloseAnimation,\n          awaitCloseAnimation = _ref$awaitCloseAnimat === void 0 ? false : _ref$awaitCloseAnimat,\n          _ref$awaitOpenAnimati = _ref.awaitOpenAnimation,\n          awaitOpenAnimation = _ref$awaitOpenAnimati === void 0 ? false : _ref$awaitOpenAnimati,\n          _ref$debugMode = _ref.debugMode,\n          debugMode = _ref$debugMode === void 0 ? false : _ref$debugMode;\n\n      _classCallCheck(this, Modal); // Save a reference of the modal\n\n\n      this.modal = document.getElementById(targetModal); // Save a reference to the passed config\n\n      this.config = {\n        debugMode: debugMode,\n        disableScroll: disableScroll,\n        openTrigger: openTrigger,\n        closeTrigger: closeTrigger,\n        openClass: openClass,\n        onShow: onShow,\n        onClose: onClose,\n        awaitCloseAnimation: awaitCloseAnimation,\n        awaitOpenAnimation: awaitOpenAnimation,\n        disableFocus: disableFocus\n      }; // Register click events only if pre binding eventListeners\n\n      if (triggers.length > 0) this.registerTriggers.apply(this, _toConsumableArray(triggers)); // pre bind functions for event listeners\n\n      this.onClick = this.onClick.bind(this);\n      this.onKeydown = this.onKeydown.bind(this);\n    }\n    /**\n     * Loops through all openTriggers and binds click event\n     * @param  {array} triggers [Array of node elements]\n     * @return {void}\n     */\n\n\n    _createClass(Modal, [{\n      key: \"registerTriggers\",\n      value: function registerTriggers() {\n        var _this = this;\n\n        for (var _len = arguments.length, triggers = new Array(_len), _key = 0; _key < _len; _key++) {\n          triggers[_key] = arguments[_key];\n        }\n\n        triggers.filter(Boolean).forEach(function (trigger) {\n          trigger.addEventListener('click', function (event) {\n            return _this.showModal(event);\n          });\n        });\n      }\n    }, {\n      key: \"showModal\",\n      value: function showModal() {\n        var _this2 = this;\n\n        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        this.activeElement = document.activeElement;\n        this.modal.setAttribute('aria-hidden', 'false');\n        this.modal.classList.add(this.config.openClass);\n        this.scrollBehaviour('disable');\n        this.addEventListeners();\n\n        if (this.config.awaitOpenAnimation) {\n          var handler = function handler() {\n            _this2.modal.removeEventListener('animationend', handler, false);\n\n            _this2.setFocusToFirstNode();\n          };\n\n          this.modal.addEventListener('animationend', handler, false);\n        } else {\n          this.setFocusToFirstNode();\n        }\n\n        this.config.onShow(this.modal, this.activeElement, event);\n      }\n    }, {\n      key: \"closeModal\",\n      value: function closeModal() {\n        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var modal = this.modal;\n        this.modal.setAttribute('aria-hidden', 'true');\n        this.removeEventListeners();\n        this.scrollBehaviour('enable');\n\n        if (this.activeElement && this.activeElement.focus) {\n          this.activeElement.focus();\n        }\n\n        this.config.onClose(this.modal, this.activeElement, event);\n\n        if (this.config.awaitCloseAnimation) {\n          var openClass = this.config.openClass; // <- old school ftw\n\n          this.modal.addEventListener('animationend', function handler() {\n            modal.classList.remove(openClass);\n            modal.removeEventListener('animationend', handler, false);\n          }, false);\n        } else {\n          modal.classList.remove(this.config.openClass);\n        }\n      }\n    }, {\n      key: \"closeModalById\",\n      value: function closeModalById(targetModal) {\n        this.modal = document.getElementById(targetModal);\n        if (this.modal) this.closeModal();\n      }\n    }, {\n      key: \"scrollBehaviour\",\n      value: function scrollBehaviour(toggle) {\n        if (!this.config.disableScroll) return;\n        var body = document.querySelector('body');\n\n        switch (toggle) {\n          case 'enable':\n            Object.assign(body.style, {\n              overflow: ''\n            });\n            break;\n\n          case 'disable':\n            Object.assign(body.style, {\n              overflow: 'hidden'\n            });\n            break;\n        }\n      }\n    }, {\n      key: \"addEventListeners\",\n      value: function addEventListeners() {\n        this.modal.addEventListener('touchstart', this.onClick);\n        this.modal.addEventListener('click', this.onClick);\n        document.addEventListener('keydown', this.onKeydown);\n      }\n    }, {\n      key: \"removeEventListeners\",\n      value: function removeEventListeners() {\n        this.modal.removeEventListener('touchstart', this.onClick);\n        this.modal.removeEventListener('click', this.onClick);\n        document.removeEventListener('keydown', this.onKeydown);\n      }\n    }, {\n      key: \"onClick\",\n      value: function onClick(event) {\n        if (event.target.hasAttribute(this.config.closeTrigger)) {\n          this.closeModal(event);\n        }\n      }\n    }, {\n      key: \"onKeydown\",\n      value: function onKeydown(event) {\n        if (event.keyCode === 27) this.closeModal(event); // esc\n\n        if (event.keyCode === 9) this.retainFocus(event); // tab\n      }\n    }, {\n      key: \"getFocusableNodes\",\n      value: function getFocusableNodes() {\n        var nodes = this.modal.querySelectorAll(FOCUSABLE_ELEMENTS);\n        return Array.apply(void 0, _toConsumableArray(nodes));\n      }\n      /**\n       * Tries to set focus on a node which is not a close trigger\n       * if no other nodes exist then focuses on first close trigger\n       */\n\n    }, {\n      key: \"setFocusToFirstNode\",\n      value: function setFocusToFirstNode() {\n        var _this3 = this;\n\n        if (this.config.disableFocus) return;\n        var focusableNodes = this.getFocusableNodes(); // no focusable nodes\n\n        if (focusableNodes.length === 0) return; // remove nodes on whose click, the modal closes\n        // could not think of a better name :(\n\n        var nodesWhichAreNotCloseTargets = focusableNodes.filter(function (node) {\n          return !node.hasAttribute(_this3.config.closeTrigger);\n        });\n        if (nodesWhichAreNotCloseTargets.length > 0) nodesWhichAreNotCloseTargets[0].focus();\n        if (nodesWhichAreNotCloseTargets.length === 0) focusableNodes[0].focus();\n      }\n    }, {\n      key: \"retainFocus\",\n      value: function retainFocus(event) {\n        var focusableNodes = this.getFocusableNodes(); // no focusable nodes\n\n        if (focusableNodes.length === 0) return;\n        /**\n         * Filters nodes which are hidden to prevent\n         * focus leak outside modal\n         */\n\n        focusableNodes = focusableNodes.filter(function (node) {\n          return node.offsetParent !== null;\n        }); // if disableFocus is true\n\n        if (!this.modal.contains(document.activeElement)) {\n          focusableNodes[0].focus();\n        } else {\n          var focusedItemIndex = focusableNodes.indexOf(document.activeElement);\n\n          if (event.shiftKey && focusedItemIndex === 0) {\n            focusableNodes[focusableNodes.length - 1].focus();\n            event.preventDefault();\n          }\n\n          if (!event.shiftKey && focusableNodes.length > 0 && focusedItemIndex === focusableNodes.length - 1) {\n            focusableNodes[0].focus();\n            event.preventDefault();\n          }\n        }\n      }\n    }]);\n\n    return Modal;\n  }();\n  /**\n   * Modal prototype ends.\n   * Here on code is responsible for detecting and\n   * auto binding event handlers on modal triggers\n   */\n  // Keep a reference to the opened modal\n\n\n  var activeModal = null;\n  /**\n   * Generates an associative array of modals and it's\n   * respective triggers\n   * @param  {array} triggers     An array of all triggers\n   * @param  {string} triggerAttr The data-attribute which triggers the module\n   * @return {array}\n   */\n\n  var generateTriggerMap = function generateTriggerMap(triggers, triggerAttr) {\n    var triggerMap = [];\n    triggers.forEach(function (trigger) {\n      var targetModal = trigger.attributes[triggerAttr].value;\n      if (triggerMap[targetModal] === undefined) triggerMap[targetModal] = [];\n      triggerMap[targetModal].push(trigger);\n    });\n    return triggerMap;\n  };\n  /**\n   * Validates whether a modal of the given id exists\n   * in the DOM\n   * @param  {number} id  The id of the modal\n   * @return {boolean}\n   */\n\n\n  var validateModalPresence = function validateModalPresence(id) {\n    if (!document.getElementById(id)) {\n      console.warn(\"MicroModal: \\u2757Seems like you have missed %c'\".concat(id, \"'\"), 'background-color: #f8f9fa;color: #50596c;font-weight: bold;', 'ID somewhere in your code. Refer example below to resolve it.');\n      console.warn(\"%cExample:\", 'background-color: #f8f9fa;color: #50596c;font-weight: bold;', \"<div class=\\\"modal\\\" id=\\\"\".concat(id, \"\\\"></div>\"));\n      return false;\n    }\n  };\n  /**\n   * Validates if there are modal triggers present\n   * in the DOM\n   * @param  {array} triggers An array of data-triggers\n   * @return {boolean}\n   */\n\n\n  var validateTriggerPresence = function validateTriggerPresence(triggers) {\n    if (triggers.length <= 0) {\n      console.warn(\"MicroModal: \\u2757Please specify at least one %c'micromodal-trigger'\", 'background-color: #f8f9fa;color: #50596c;font-weight: bold;', 'data attribute.');\n      console.warn(\"%cExample:\", 'background-color: #f8f9fa;color: #50596c;font-weight: bold;', \"<a href=\\\"#\\\" data-micromodal-trigger=\\\"my-modal\\\"></a>\");\n      return false;\n    }\n  };\n  /**\n   * Checks if triggers and their corresponding modals\n   * are present in the DOM\n   * @param  {array} triggers   Array of DOM nodes which have data-triggers\n   * @param  {array} triggerMap Associative array of modals and their triggers\n   * @return {boolean}\n   */\n\n\n  var validateArgs = function validateArgs(triggers, triggerMap) {\n    validateTriggerPresence(triggers);\n    if (!triggerMap) return true;\n\n    for (var id in triggerMap) {\n      validateModalPresence(id);\n    }\n\n    return true;\n  };\n  /**\n   * Binds click handlers to all modal triggers\n   * @param  {object} config [description]\n   * @return void\n   */\n\n\n  var init = function init(config) {\n    // Create an config object with default openTrigger\n    var options = Object.assign({}, {\n      openTrigger: 'data-micromodal-trigger'\n    }, config); // Collects all the nodes with the trigger\n\n    var triggers = _toConsumableArray(document.querySelectorAll(\"[\".concat(options.openTrigger, \"]\"))); // Makes a mappings of modals with their trigger nodes\n\n\n    var triggerMap = generateTriggerMap(triggers, options.openTrigger); // Checks if modals and triggers exist in dom\n\n    if (options.debugMode === true && validateArgs(triggers, triggerMap) === false) return; // For every target modal creates a new instance\n\n    for (var key in triggerMap) {\n      var value = triggerMap[key];\n      options.targetModal = key;\n      options.triggers = _toConsumableArray(value);\n      activeModal = new Modal(options); // eslint-disable-line no-new\n    }\n  };\n  /**\n   * Shows a particular modal\n   * @param  {string} targetModal [The id of the modal to display]\n   * @param  {object} config [The configuration object to pass]\n   * @return {void}\n   */\n\n\n  var show = function show(targetModal, config) {\n    var options = config || {};\n    options.targetModal = targetModal; // Checks if modals and triggers exist in dom\n\n    if (options.debugMode === true && validateModalPresence(targetModal) === false) return; // clear events in case previous modal wasn't close\n\n    if (activeModal) activeModal.removeEventListeners(); // stores reference to active modal\n\n    activeModal = new Modal(options); // eslint-disable-line no-new\n\n    activeModal.showModal();\n  };\n  /**\n   * Closes the active modal\n   * @param  {string} targetModal [The id of the modal to close]\n   * @return {void}\n   */\n\n\n  var close = function close(targetModal) {\n    targetModal ? activeModal.closeModalById(targetModal) : activeModal.closeModal();\n  };\n\n  return {\n    init: init,\n    show: show,\n    close: close\n  };\n}();\n\nwindow.MicroModal = MicroModal;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MicroModal);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWljcm9tb2RhbC9kaXN0L21pY3JvbW9kYWwuZXMuanM/YTFiNyJdLCJuYW1lcyI6WyJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiQXJyYXkiLCJpc0FycmF5IiwiX2FycmF5TGlrZVRvQXJyYXkiLCJpdGVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJmcm9tIiwibyIsIm1pbkxlbiIsIm4iLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiTWljcm9Nb2RhbCIsIkZPQ1VTQUJMRV9FTEVNRU5UUyIsIk1vZGFsIiwiX3JlZiIsInRhcmdldE1vZGFsIiwiX3JlZiR0cmlnZ2VycyIsInRyaWdnZXJzIiwiX3JlZiRvblNob3ciLCJvblNob3ciLCJfcmVmJG9uQ2xvc2UiLCJvbkNsb3NlIiwiX3JlZiRvcGVuVHJpZ2dlciIsIm9wZW5UcmlnZ2VyIiwiX3JlZiRjbG9zZVRyaWdnZXIiLCJjbG9zZVRyaWdnZXIiLCJfcmVmJG9wZW5DbGFzcyIsIm9wZW5DbGFzcyIsIl9yZWYkZGlzYWJsZVNjcm9sbCIsImRpc2FibGVTY3JvbGwiLCJfcmVmJGRpc2FibGVGb2N1cyIsImRpc2FibGVGb2N1cyIsIl9yZWYkYXdhaXRDbG9zZUFuaW1hdCIsImF3YWl0Q2xvc2VBbmltYXRpb24iLCJfcmVmJGF3YWl0T3BlbkFuaW1hdGkiLCJhd2FpdE9wZW5BbmltYXRpb24iLCJfcmVmJGRlYnVnTW9kZSIsImRlYnVnTW9kZSIsIm1vZGFsIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImNvbmZpZyIsInJlZ2lzdGVyVHJpZ2dlcnMiLCJhcHBseSIsIm9uQ2xpY2siLCJiaW5kIiwib25LZXlkb3duIiwidmFsdWUiLCJfdGhpcyIsIl9sZW4iLCJhcmd1bWVudHMiLCJfa2V5IiwiZmlsdGVyIiwiQm9vbGVhbiIsImZvckVhY2giLCJ0cmlnZ2VyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50Iiwic2hvd01vZGFsIiwiX3RoaXMyIiwidW5kZWZpbmVkIiwiYWN0aXZlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImNsYXNzTGlzdCIsImFkZCIsInNjcm9sbEJlaGF2aW91ciIsImFkZEV2ZW50TGlzdGVuZXJzIiwiaGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZXRGb2N1c1RvRmlyc3ROb2RlIiwiY2xvc2VNb2RhbCIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwiZm9jdXMiLCJyZW1vdmUiLCJjbG9zZU1vZGFsQnlJZCIsInRvZ2dsZSIsImJvZHkiLCJxdWVyeVNlbGVjdG9yIiwiYXNzaWduIiwic3R5bGUiLCJvdmVyZmxvdyIsImhhc0F0dHJpYnV0ZSIsImtleUNvZGUiLCJyZXRhaW5Gb2N1cyIsImdldEZvY3VzYWJsZU5vZGVzIiwibm9kZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiX3RoaXMzIiwiZm9jdXNhYmxlTm9kZXMiLCJub2Rlc1doaWNoQXJlTm90Q2xvc2VUYXJnZXRzIiwibm9kZSIsIm9mZnNldFBhcmVudCIsImNvbnRhaW5zIiwiZm9jdXNlZEl0ZW1JbmRleCIsImluZGV4T2YiLCJzaGlmdEtleSIsInByZXZlbnREZWZhdWx0IiwiYWN0aXZlTW9kYWwiLCJnZW5lcmF0ZVRyaWdnZXJNYXAiLCJ0cmlnZ2VyQXR0ciIsInRyaWdnZXJNYXAiLCJhdHRyaWJ1dGVzIiwicHVzaCIsInZhbGlkYXRlTW9kYWxQcmVzZW5jZSIsImlkIiwiY29uc29sZSIsIndhcm4iLCJjb25jYXQiLCJ2YWxpZGF0ZVRyaWdnZXJQcmVzZW5jZSIsInZhbGlkYXRlQXJncyIsImluaXQiLCJvcHRpb25zIiwic2hvdyIsImNsb3NlIiwid2luZG93Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBLFNBQVNBLGVBQVQsQ0FBeUJDLFFBQXpCLEVBQW1DQyxXQUFuQyxFQUFnRDtBQUM5QyxNQUFJLEVBQUVELFFBQVEsWUFBWUMsV0FBdEIsQ0FBSixFQUF3QztBQUN0QyxVQUFNLElBQUlDLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTQyxpQkFBVCxDQUEyQkMsTUFBM0IsRUFBbUNDLEtBQW5DLEVBQTBDO0FBQ3hDLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsS0FBSyxDQUFDRSxNQUExQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxRQUFJRSxVQUFVLEdBQUdILEtBQUssQ0FBQ0MsQ0FBRCxDQUF0QjtBQUNBRSxjQUFVLENBQUNDLFVBQVgsR0FBd0JELFVBQVUsQ0FBQ0MsVUFBWCxJQUF5QixLQUFqRDtBQUNBRCxjQUFVLENBQUNFLFlBQVgsR0FBMEIsSUFBMUI7QUFDQSxRQUFJLFdBQVdGLFVBQWYsRUFBMkJBLFVBQVUsQ0FBQ0csUUFBWCxHQUFzQixJQUF0QjtBQUMzQkMsVUFBTSxDQUFDQyxjQUFQLENBQXNCVCxNQUF0QixFQUE4QkksVUFBVSxDQUFDTSxHQUF6QyxFQUE4Q04sVUFBOUM7QUFDRDtBQUNGOztBQUVELFNBQVNPLFlBQVQsQ0FBc0JkLFdBQXRCLEVBQW1DZSxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7QUFDMUQsTUFBSUQsVUFBSixFQUFnQmIsaUJBQWlCLENBQUNGLFdBQVcsQ0FBQ2lCLFNBQWIs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MEIsTUFBM0IsRUFBbUM7QUFDNUMsUUFBSXNFLE9BQU8sR0FBR3RFLE1BQU0sSUFBSSxFQUF4QjtBQUNBc0UsV0FBTyxDQUFDaEcsV0FBUixHQUFzQkEsV0FBdEIsQ0FGNEMsQ0FFVDs7QUFFbkMsUUFBSWdHLE9BQU8sQ0FBQzFFLFNBQVIsS0FBc0IsSUFBdEIsSUFBOEJrRSxxQkFBcUIsQ0FBQ3hGLFdBQUQsQ0FBckIsS0FBdUMsS0FBekUsRUFBZ0YsT0FKcEMsQ0FJNEM7O0FBRXhGLFFBQUlrRixXQUFKLEVBQWlCQSxXQUFXLENBQUMxQixvQkFBWixHQU4yQixDQU1TOztBQUVyRDBCLGVBQVcsR0FBRyxJQUFJcEYsS0FBSixDQUFVa0csT0FBVixDQUFkLENBUjRDLENBUVY7O0FBRWxDZCxlQUFXLENBQUN2QyxTQUFaO0FBQ0QsR0FYRDtBQVlBOzs7Ozs7O0FBT0EsTUFBSXVELEtBQUssR0FBRyxTQUFTQSxLQUFULENBQWVsRyxXQUFmLEVBQTRCO0FBQ3RDQSxlQUFXLEdBQUdrRixXQUFXLENBQUN2QixjQUFaLENBQTJCM0QsV0FBM0IsQ0FBSCxHQUE2Q2tGLFdBQVcsQ0FBQzNCLFVBQVosRUFBeEQ7QUFDRCxHQUZEOztBQUlBLFNBQU87QUFDTHdDLFFBQUksRUFBRUEsSUFERDtBQUVMRSxRQUFJLEVBQUVBLElBRkQ7QUFHTEMsU0FBSyxFQUFFQTtBQUhGLEdBQVA7QUFLRCxDQTlYZ0IsRUFBakI7O0FBK1hBQyxNQUFNLENBQUN2RyxVQUFQLEdBQW9CQSxVQUFwQjtBQUVlQSx5RUFBZiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9taWNyb21vZGFsL2Rpc3QvbWljcm9tb2RhbC5lcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgTWljcm9Nb2RhbCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgRk9DVVNBQkxFX0VMRU1FTlRTID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbdHlwZT1cImhpZGRlblwiXSk6bm90KFthcmlhLWhpZGRlbl0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pJywgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKTpub3QoW2FyaWEtaGlkZGVuXSknLCAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKTpub3QoW2FyaWEtaGlkZGVuXSknLCAnaWZyYW1lJywgJ29iamVjdCcsICdlbWJlZCcsICdbY29udGVudGVkaXRhYmxlXScsICdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXhePVwiLVwiXSknXTtcblxuICB2YXIgTW9kYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGFsKF9yZWYpIHtcbiAgICAgIHZhciB0YXJnZXRNb2RhbCA9IF9yZWYudGFyZ2V0TW9kYWwsXG4gICAgICAgICAgX3JlZiR0cmlnZ2VycyA9IF9yZWYudHJpZ2dlcnMsXG4gICAgICAgICAgdHJpZ2dlcnMgPSBfcmVmJHRyaWdnZXJzID09PSB2b2lkIDAgPyBbXSA6IF9yZWYkdHJpZ2dlcnMsXG4gICAgICAgICAgX3JlZiRvblNob3cgPSBfcmVmLm9uU2hvdyxcbiAgICAgICAgICBvblNob3cgPSBfcmVmJG9uU2hvdyA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfcmVmJG9uU2hvdyxcbiAgICAgICAgICBfcmVmJG9uQ2xvc2UgPSBfcmVmLm9uQ2xvc2UsXG4gICAgICAgICAgb25DbG9zZSA9IF9yZWYkb25DbG9zZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfcmVmJG9uQ2xvc2UsXG4gICAgICAgICAgX3JlZiRvcGVuVHJpZ2dlciA9IF9yZWYub3BlblRyaWdnZXIsXG4gICAgICAgICAgb3BlblRyaWdnZXIgPSBfcmVmJG9wZW5UcmlnZ2VyID09PSB2b2lkIDAgPyAnZGF0YS1taWNyb21vZGFsLXRyaWdnZXInIDogX3JlZiRvcGVuVHJpZ2dlcixcbiAgICAgICAgICBfcmVmJGNsb3NlVHJpZ2dlciA9IF9yZWYuY2xvc2VUcmlnZ2VyLFxuICAgICAgICAgIGNsb3NlVHJpZ2dlciA9IF9yZWYkY2xvc2VUcmlnZ2VyID09PSB2b2lkIDAgPyAnZGF0YS1taWNyb21vZGFsLWNsb3NlJyA6IF9yZWYkY2xvc2VUcmlnZ2VyLFxuICAgICAgICAgIF9yZWYkb3BlbkNsYXNzID0gX3JlZi5vcGVuQ2xhc3MsXG4gICAgICAgICAgb3BlbkNsYXNzID0gX3JlZiRvcGVuQ2xhc3MgPT09IHZvaWQgMCA/ICdpcy1vcGVuJyA6IF9yZWYkb3BlbkNsYXNzLFxuICAgICAgICAgIF9yZWYkZGlzYWJsZVNjcm9sbCA9IF9yZWYuZGlzYWJsZVNjcm9sbCxcbiAgICAgICAgICBkaXNhYmxlU2Nyb2xsID0gX3JlZiRkaXNhYmxlU2Nyb2xsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGlzYWJsZVNjcm9sbCxcbiAgICAgICAgICBfcmVmJGRpc2FibGVGb2N1cyA9IF9yZWYuZGlzYWJsZUZvY3VzLFxuICAgICAgICAgIGRpc2FibGVGb2N1cyA9IF9yZWYkZGlzYWJsZUZvY3VzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGlzYWJsZUZvY3VzLFxuICAgICAgICAgIF9yZWYkYXdhaXRDbG9zZUFuaW1hdCA9IF9yZWYuYXdhaXRDbG9zZUFuaW1hdGlvbixcbiAgICAgICAgICBhd2FpdENsb3NlQW5pbWF0aW9uID0gX3JlZiRhd2FpdENsb3NlQW5pbWF0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkYXdhaXRDbG9zZUFuaW1hdCxcbiAgICAgICAgICBfcmVmJGF3YWl0T3BlbkFuaW1hdGkgPSBfcmVmLmF3YWl0T3BlbkFuaW1hdGlvbixcbiAgICAgICAgICBhd2FpdE9wZW5BbmltYXRpb24gPSBfcmVmJGF3YWl0T3BlbkFuaW1hdGkgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRhd2FpdE9wZW5BbmltYXRpLFxuICAgICAgICAgIF9yZWYkZGVidWdNb2RlID0gX3JlZi5kZWJ1Z01vZGUsXG4gICAgICAgICAgZGVidWdNb2RlID0gX3JlZiRkZWJ1Z01vZGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRkZWJ1Z01vZGU7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbCk7XG5cbiAgICAgIC8vIFNhdmUgYSByZWZlcmVuY2Ugb2YgdGhlIG1vZGFsXG4gICAgICB0aGlzLm1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0TW9kYWwpOyAvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXNzZWQgY29uZmlnXG5cbiAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICBkZWJ1Z01vZGU6IGRlYnVnTW9kZSxcbiAgICAgICAgZGlzYWJsZVNjcm9sbDogZGlzYWJsZVNjcm9sbCxcbiAgICAgICAgb3BlblRyaWdnZXI6IG9wZW5UcmlnZ2VyLFxuICAgICAgICBjbG9zZVRyaWdnZXI6IGNsb3NlVHJpZ2dlcixcbiAgICAgICAgb3BlbkNsYXNzOiBvcGVuQ2xhc3MsXG4gICAgICAgIG9uU2hvdzogb25TaG93LFxuICAgICAgICBvbkNsb3NlOiBvbkNsb3NlLFxuICAgICAgICBhd2FpdENsb3NlQW5pbWF0aW9uOiBhd2FpdENsb3NlQW5pbWF0aW9uLFxuICAgICAgICBhd2FpdE9wZW5BbmltYXRpb246IGF3YWl0T3BlbkFuaW1hdGlvbixcbiAgICAgICAgZGlzYWJsZUZvY3VzOiBkaXNhYmxlRm9jdXNcbiAgICAgIH07IC8vIFJlZ2lzdGVyIGNsaWNrIGV2ZW50cyBvbmx5IGlmIHByZSBiaW5kaW5nIGV2ZW50TGlzdGVuZXJzXG5cbiAgICAgIGlmICh0cmlnZ2Vycy5sZW5ndGggPiAwKSB0aGlzLnJlZ2lzdGVyVHJpZ2dlcnMuYXBwbHkodGhpcywgX3RvQ29uc3VtYWJsZUFycmF5KHRyaWdnZXJzKSk7IC8vIHByZSBiaW5kIGZ1bmN0aW9ucyBmb3IgZXZlbnQgbGlzdGVuZXJzXG5cbiAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5vbktleWRvd24gPSB0aGlzLm9uS2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29wcyB0aHJvdWdoIGFsbCBvcGVuVHJpZ2dlcnMgYW5kIGJpbmRzIGNsaWNrIGV2ZW50XG4gICAgICogQHBhcmFtICB7YXJyYXl9IHRyaWdnZXJzIFtBcnJheSBvZiBub2RlIGVsZW1lbnRzXVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhNb2RhbCwgW3tcbiAgICAgIGtleTogXCJyZWdpc3RlclRyaWdnZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJUcmlnZ2VycygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdHJpZ2dlcnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgdHJpZ2dlcnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB0cmlnZ2Vycy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgICAgICAgIHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaG93TW9kYWwoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2hvd01vZGFsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd01vZGFsKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgZXZlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMubW9kYWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuICAgICAgICB0aGlzLm1vZGFsLmNsYXNzTGlzdC5hZGQodGhpcy5jb25maWcub3BlbkNsYXNzKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCZWhhdmlvdXIoJ2Rpc2FibGUnKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hd2FpdE9wZW5BbmltYXRpb24pIHtcbiAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBfdGhpczIubW9kYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgaGFuZGxlciwgZmFsc2UpO1xuXG4gICAgICAgICAgICBfdGhpczIuc2V0Rm9jdXNUb0ZpcnN0Tm9kZSgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLm1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldEZvY3VzVG9GaXJzdE5vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlnLm9uU2hvdyh0aGlzLm1vZGFsLCB0aGlzLmFjdGl2ZUVsZW1lbnQsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VNb2RhbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlTW9kYWwoKSB7XG4gICAgICAgIHZhciBldmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgdmFyIG1vZGFsID0gdGhpcy5tb2RhbDtcbiAgICAgICAgdGhpcy5tb2RhbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnNjcm9sbEJlaGF2aW91cignZW5hYmxlJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlRWxlbWVudCAmJiB0aGlzLmFjdGl2ZUVsZW1lbnQuZm9jdXMpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlnLm9uQ2xvc2UodGhpcy5tb2RhbCwgdGhpcy5hY3RpdmVFbGVtZW50LCBldmVudCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF3YWl0Q2xvc2VBbmltYXRpb24pIHtcbiAgICAgICAgICB2YXIgb3BlbkNsYXNzID0gdGhpcy5jb25maWcub3BlbkNsYXNzOyAvLyA8LSBvbGQgc2Nob29sIGZ0d1xuXG4gICAgICAgICAgdGhpcy5tb2RhbC5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgbW9kYWwuY2xhc3NMaXN0LnJlbW92ZShvcGVuQ2xhc3MpO1xuICAgICAgICAgICAgbW9kYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RhbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY29uZmlnLm9wZW5DbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VNb2RhbEJ5SWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZU1vZGFsQnlJZCh0YXJnZXRNb2RhbCkge1xuICAgICAgICB0aGlzLm1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0TW9kYWwpO1xuICAgICAgICBpZiAodGhpcy5tb2RhbCkgdGhpcy5jbG9zZU1vZGFsKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNjcm9sbEJlaGF2aW91clwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbEJlaGF2aW91cih0b2dnbGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5kaXNhYmxlU2Nyb2xsKSByZXR1cm47XG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgICAgIHN3aXRjaCAodG9nZ2xlKSB7XG4gICAgICAgICAgY2FzZSAnZW5hYmxlJzpcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYm9keS5zdHlsZSwge1xuICAgICAgICAgICAgICBvdmVyZmxvdzogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdkaXNhYmxlJzpcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYm9keS5zdHlsZSwge1xuICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5tb2RhbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vbkNsaWNrKTtcbiAgICAgICAgdGhpcy5tb2RhbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5ZG93bik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMubW9kYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25DbGljayk7XG4gICAgICAgIHRoaXMubW9kYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleWRvd24pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvbkNsaWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0Lmhhc0F0dHJpYnV0ZSh0aGlzLmNvbmZpZy5jbG9zZVRyaWdnZXIpKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZU1vZGFsKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvbktleWRvd25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbktleWRvd24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB0aGlzLmNsb3NlTW9kYWwoZXZlbnQpOyAvLyBlc2NcblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gOSkgdGhpcy5yZXRhaW5Gb2N1cyhldmVudCk7IC8vIHRhYlxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRGb2N1c2FibGVOb2Rlc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvY3VzYWJsZU5vZGVzKCkge1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm1vZGFsLnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX0VMRU1FTlRTKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KG5vZGVzKSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFRyaWVzIHRvIHNldCBmb2N1cyBvbiBhIG5vZGUgd2hpY2ggaXMgbm90IGEgY2xvc2UgdHJpZ2dlclxuICAgICAgICogaWYgbm8gb3RoZXIgbm9kZXMgZXhpc3QgdGhlbiBmb2N1c2VzIG9uIGZpcnN0IGNsb3NlIHRyaWdnZXJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEZvY3VzVG9GaXJzdE5vZGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGb2N1c1RvRmlyc3ROb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuZGlzYWJsZUZvY3VzKSByZXR1cm47XG4gICAgICAgIHZhciBmb2N1c2FibGVOb2RlcyA9IHRoaXMuZ2V0Rm9jdXNhYmxlTm9kZXMoKTsgLy8gbm8gZm9jdXNhYmxlIG5vZGVzXG5cbiAgICAgICAgaWYgKGZvY3VzYWJsZU5vZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAvLyByZW1vdmUgbm9kZXMgb24gd2hvc2UgY2xpY2ssIHRoZSBtb2RhbCBjbG9zZXNcbiAgICAgICAgLy8gY291bGQgbm90IHRoaW5rIG9mIGEgYmV0dGVyIG5hbWUgOihcblxuICAgICAgICB2YXIgbm9kZXNXaGljaEFyZU5vdENsb3NlVGFyZ2V0cyA9IGZvY3VzYWJsZU5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiAhbm9kZS5oYXNBdHRyaWJ1dGUoX3RoaXMzLmNvbmZpZy5jbG9zZVRyaWdnZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vZGVzV2hpY2hBcmVOb3RDbG9zZVRhcmdldHMubGVuZ3RoID4gMCkgbm9kZXNXaGljaEFyZU5vdENsb3NlVGFyZ2V0c1swXS5mb2N1cygpO1xuICAgICAgICBpZiAobm9kZXNXaGljaEFyZU5vdENsb3NlVGFyZ2V0cy5sZW5ndGggPT09IDApIGZvY3VzYWJsZU5vZGVzWzBdLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJldGFpbkZvY3VzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmV0YWluRm9jdXMoZXZlbnQpIHtcbiAgICAgICAgdmFyIGZvY3VzYWJsZU5vZGVzID0gdGhpcy5nZXRGb2N1c2FibGVOb2RlcygpOyAvLyBubyBmb2N1c2FibGUgbm9kZXNcblxuICAgICAgICBpZiAoZm9jdXNhYmxlTm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWx0ZXJzIG5vZGVzIHdoaWNoIGFyZSBoaWRkZW4gdG8gcHJldmVudFxuICAgICAgICAgKiBmb2N1cyBsZWFrIG91dHNpZGUgbW9kYWxcbiAgICAgICAgICovXG5cbiAgICAgICAgZm9jdXNhYmxlTm9kZXMgPSBmb2N1c2FibGVOb2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5vZmZzZXRQYXJlbnQgIT09IG51bGw7XG4gICAgICAgIH0pOyAvLyBpZiBkaXNhYmxlRm9jdXMgaXMgdHJ1ZVxuXG4gICAgICAgIGlmICghdGhpcy5tb2RhbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgIGZvY3VzYWJsZU5vZGVzWzBdLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZvY3VzZWRJdGVtSW5kZXggPSBmb2N1c2FibGVOb2Rlcy5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzZWRJdGVtSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGZvY3VzYWJsZU5vZGVzW2ZvY3VzYWJsZU5vZGVzLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgZm9jdXNhYmxlTm9kZXMubGVuZ3RoID4gMCAmJiBmb2N1c2VkSXRlbUluZGV4ID09PSBmb2N1c2FibGVOb2Rlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBmb2N1c2FibGVOb2Rlc1swXS5mb2N1cygpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTW9kYWw7XG4gIH0oKTtcbiAgLyoqXG4gICAqIE1vZGFsIHByb3RvdHlwZSBlbmRzLlxuICAgKiBIZXJlIG9uIGNvZGUgaXMgcmVzcG9uc2libGUgZm9yIGRldGVjdGluZyBhbmRcbiAgICogYXV0byBiaW5kaW5nIGV2ZW50IGhhbmRsZXJzIG9uIG1vZGFsIHRyaWdnZXJzXG4gICAqL1xuICAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcGVuZWQgbW9kYWxcblxuXG4gIHZhciBhY3RpdmVNb2RhbCA9IG51bGw7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbW9kYWxzIGFuZCBpdCdzXG4gICAqIHJlc3BlY3RpdmUgdHJpZ2dlcnNcbiAgICogQHBhcmFtICB7YXJyYXl9IHRyaWdnZXJzICAgICBBbiBhcnJheSBvZiBhbGwgdHJpZ2dlcnNcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0cmlnZ2VyQXR0ciBUaGUgZGF0YS1hdHRyaWJ1dGUgd2hpY2ggdHJpZ2dlcnMgdGhlIG1vZHVsZVxuICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICovXG5cbiAgdmFyIGdlbmVyYXRlVHJpZ2dlck1hcCA9IGZ1bmN0aW9uIGdlbmVyYXRlVHJpZ2dlck1hcCh0cmlnZ2VycywgdHJpZ2dlckF0dHIpIHtcbiAgICB2YXIgdHJpZ2dlck1hcCA9IFtdO1xuICAgIHRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgIHZhciB0YXJnZXRNb2RhbCA9IHRyaWdnZXIuYXR0cmlidXRlc1t0cmlnZ2VyQXR0cl0udmFsdWU7XG4gICAgICBpZiAodHJpZ2dlck1hcFt0YXJnZXRNb2RhbF0gPT09IHVuZGVmaW5lZCkgdHJpZ2dlck1hcFt0YXJnZXRNb2RhbF0gPSBbXTtcbiAgICAgIHRyaWdnZXJNYXBbdGFyZ2V0TW9kYWxdLnB1c2godHJpZ2dlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyaWdnZXJNYXA7XG4gIH07XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgd2hldGhlciBhIG1vZGFsIG9mIHRoZSBnaXZlbiBpZCBleGlzdHNcbiAgICogaW4gdGhlIERPTVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlkICBUaGUgaWQgb2YgdGhlIG1vZGFsXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgdmFyIHZhbGlkYXRlTW9kYWxQcmVzZW5jZSA9IGZ1bmN0aW9uIHZhbGlkYXRlTW9kYWxQcmVzZW5jZShpZCkge1xuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJNaWNyb01vZGFsOiBcXHUyNzU3U2VlbXMgbGlrZSB5b3UgaGF2ZSBtaXNzZWQgJWMnXCIuY29uY2F0KGlkLCBcIidcIiksICdiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOWZhO2NvbG9yOiAjNTA1OTZjO2ZvbnQtd2VpZ2h0OiBib2xkOycsICdJRCBzb21ld2hlcmUgaW4geW91ciBjb2RlLiBSZWZlciBleGFtcGxlIGJlbG93IHRvIHJlc29sdmUgaXQuJyk7XG4gICAgICBjb25zb2xlLndhcm4oXCIlY0V4YW1wbGU6XCIsICdiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOWZhO2NvbG9yOiAjNTA1OTZjO2ZvbnQtd2VpZ2h0OiBib2xkOycsIFwiPGRpdiBjbGFzcz1cXFwibW9kYWxcXFwiIGlkPVxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIj48L2Rpdj5cIikpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBpZiB0aGVyZSBhcmUgbW9kYWwgdHJpZ2dlcnMgcHJlc2VudFxuICAgKiBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSAge2FycmF5fSB0cmlnZ2VycyBBbiBhcnJheSBvZiBkYXRhLXRyaWdnZXJzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgdmFyIHZhbGlkYXRlVHJpZ2dlclByZXNlbmNlID0gZnVuY3Rpb24gdmFsaWRhdGVUcmlnZ2VyUHJlc2VuY2UodHJpZ2dlcnMpIHtcbiAgICBpZiAodHJpZ2dlcnMubGVuZ3RoIDw9IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk1pY3JvTW9kYWw6IFxcdTI3NTdQbGVhc2Ugc3BlY2lmeSBhdCBsZWFzdCBvbmUgJWMnbWljcm9tb2RhbC10cmlnZ2VyJ1wiLCAnYmFja2dyb3VuZC1jb2xvcjogI2Y4ZjlmYTtjb2xvcjogIzUwNTk2Yztmb250LXdlaWdodDogYm9sZDsnLCAnZGF0YSBhdHRyaWJ1dGUuJyk7XG4gICAgICBjb25zb2xlLndhcm4oXCIlY0V4YW1wbGU6XCIsICdiYWNrZ3JvdW5kLWNvbG9yOiAjZjhmOWZhO2NvbG9yOiAjNTA1OTZjO2ZvbnQtd2VpZ2h0OiBib2xkOycsIFwiPGEgaHJlZj1cXFwiI1xcXCIgZGF0YS1taWNyb21vZGFsLXRyaWdnZXI9XFxcIm15LW1vZGFsXFxcIj48L2E+XCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0cmlnZ2VycyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBtb2RhbHNcbiAgICogYXJlIHByZXNlbnQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0gIHthcnJheX0gdHJpZ2dlcnMgICBBcnJheSBvZiBET00gbm9kZXMgd2hpY2ggaGF2ZSBkYXRhLXRyaWdnZXJzXG4gICAqIEBwYXJhbSAge2FycmF5fSB0cmlnZ2VyTWFwIEFzc29jaWF0aXZlIGFycmF5IG9mIG1vZGFscyBhbmQgdGhlaXIgdHJpZ2dlcnNcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblxuICB2YXIgdmFsaWRhdGVBcmdzID0gZnVuY3Rpb24gdmFsaWRhdGVBcmdzKHRyaWdnZXJzLCB0cmlnZ2VyTWFwKSB7XG4gICAgdmFsaWRhdGVUcmlnZ2VyUHJlc2VuY2UodHJpZ2dlcnMpO1xuICAgIGlmICghdHJpZ2dlck1hcCkgcmV0dXJuIHRydWU7XG5cbiAgICBmb3IgKHZhciBpZCBpbiB0cmlnZ2VyTWFwKSB7XG4gICAgICB2YWxpZGF0ZU1vZGFsUHJlc2VuY2UoaWQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogQmluZHMgY2xpY2sgaGFuZGxlcnMgdG8gYWxsIG1vZGFsIHRyaWdnZXJzXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB2b2lkXG4gICAqL1xuXG5cbiAgdmFyIGluaXQgPSBmdW5jdGlvbiBpbml0KGNvbmZpZykge1xuICAgIC8vIENyZWF0ZSBhbiBjb25maWcgb2JqZWN0IHdpdGggZGVmYXVsdCBvcGVuVHJpZ2dlclxuICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgb3BlblRyaWdnZXI6ICdkYXRhLW1pY3JvbW9kYWwtdHJpZ2dlcidcbiAgICB9LCBjb25maWcpOyAvLyBDb2xsZWN0cyBhbGwgdGhlIG5vZGVzIHdpdGggdGhlIHRyaWdnZXJcblxuICAgIHZhciB0cmlnZ2VycyA9IF90b0NvbnN1bWFibGVBcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiLmNvbmNhdChvcHRpb25zLm9wZW5UcmlnZ2VyLCBcIl1cIikpKTsgLy8gTWFrZXMgYSBtYXBwaW5ncyBvZiBtb2RhbHMgd2l0aCB0aGVpciB0cmlnZ2VyIG5vZGVzXG5cblxuICAgIHZhciB0cmlnZ2VyTWFwID0gZ2VuZXJhdGVUcmlnZ2VyTWFwKHRyaWdnZXJzLCBvcHRpb25zLm9wZW5UcmlnZ2VyKTsgLy8gQ2hlY2tzIGlmIG1vZGFscyBhbmQgdHJpZ2dlcnMgZXhpc3QgaW4gZG9tXG5cbiAgICBpZiAob3B0aW9ucy5kZWJ1Z01vZGUgPT09IHRydWUgJiYgdmFsaWRhdGVBcmdzKHRyaWdnZXJzLCB0cmlnZ2VyTWFwKSA9PT0gZmFsc2UpIHJldHVybjsgLy8gRm9yIGV2ZXJ5IHRhcmdldCBtb2RhbCBjcmVhdGVzIGEgbmV3IGluc3RhbmNlXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdHJpZ2dlck1hcCkge1xuICAgICAgdmFyIHZhbHVlID0gdHJpZ2dlck1hcFtrZXldO1xuICAgICAgb3B0aW9ucy50YXJnZXRNb2RhbCA9IGtleTtcbiAgICAgIG9wdGlvbnMudHJpZ2dlcnMgPSBfdG9Db25zdW1hYmxlQXJyYXkodmFsdWUpO1xuICAgICAgYWN0aXZlTW9kYWwgPSBuZXcgTW9kYWwob3B0aW9ucyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogU2hvd3MgYSBwYXJ0aWN1bGFyIG1vZGFsXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFyZ2V0TW9kYWwgW1RoZSBpZCBvZiB0aGUgbW9kYWwgdG8gZGlzcGxheV1cbiAgICogQHBhcmFtICB7b2JqZWN0fSBjb25maWcgW1RoZSBjb25maWd1cmF0aW9uIG9iamVjdCB0byBwYXNzXVxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cblxuXG4gIHZhciBzaG93ID0gZnVuY3Rpb24gc2hvdyh0YXJnZXRNb2RhbCwgY29uZmlnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjb25maWcgfHwge307XG4gICAgb3B0aW9ucy50YXJnZXRNb2RhbCA9IHRhcmdldE1vZGFsOyAvLyBDaGVja3MgaWYgbW9kYWxzIGFuZCB0cmlnZ2VycyBleGlzdCBpbiBkb21cblxuICAgIGlmIChvcHRpb25zLmRlYnVnTW9kZSA9PT0gdHJ1ZSAmJiB2YWxpZGF0ZU1vZGFsUHJlc2VuY2UodGFyZ2V0TW9kYWwpID09PSBmYWxzZSkgcmV0dXJuOyAvLyBjbGVhciBldmVudHMgaW4gY2FzZSBwcmV2aW91cyBtb2RhbCB3YXNuJ3QgY2xvc2VcblxuICAgIGlmIChhY3RpdmVNb2RhbCkgYWN0aXZlTW9kYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTsgLy8gc3RvcmVzIHJlZmVyZW5jZSB0byBhY3RpdmUgbW9kYWxcblxuICAgIGFjdGl2ZU1vZGFsID0gbmV3IE1vZGFsKG9wdGlvbnMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXG4gICAgYWN0aXZlTW9kYWwuc2hvd01vZGFsKCk7XG4gIH07XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGFjdGl2ZSBtb2RhbFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhcmdldE1vZGFsIFtUaGUgaWQgb2YgdGhlIG1vZGFsIHRvIGNsb3NlXVxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cblxuXG4gIHZhciBjbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKHRhcmdldE1vZGFsKSB7XG4gICAgdGFyZ2V0TW9kYWwgPyBhY3RpdmVNb2RhbC5jbG9zZU1vZGFsQnlJZCh0YXJnZXRNb2RhbCkgOiBhY3RpdmVNb2RhbC5jbG9zZU1vZGFsKCk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBpbml0OiBpbml0LFxuICAgIHNob3c6IHNob3csXG4gICAgY2xvc2U6IGNsb3NlXG4gIH07XG59KCk7XG53aW5kb3cuTWljcm9Nb2RhbCA9IE1pY3JvTW9kYWw7XG5cbmV4cG9ydCBkZWZhdWx0IE1pY3JvTW9kYWw7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/micromodal/dist/micromodal.es.js\n");

/***/ }),

/***/ "./node_modules/overlayscrollbars/js/OverlayScrollbars.js":
/*!****************************************************************!*\
  !*** ./node_modules/overlayscrollbars/js/OverlayScrollbars.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * OverlayScrollbars\r\n * https://github.com/KingSora/OverlayScrollbars\r\n *\r\n * Version: 1.12.0\r\n *\r\n * Copyright KingSora | Rene Haas.\r\n * https://github.com/KingSora\r\n *\r\n * Released under the MIT license.\r\n * Date: 05.04.2020\r\n */\n(function (global, factory) {\n  if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return factory(global, global.document, undefined);\n  }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(typeof window !== 'undefined' ? window : this, function (window, document, undefined) {\n  'use strict';\n\n  var PLUGINNAME = 'OverlayScrollbars';\n  var TYPES = {\n    o: 'object',\n    f: 'function',\n    a: 'array',\n    s: 'string',\n    b: 'boolean',\n    n: 'number',\n    u: 'undefined',\n    z: 'null' //d : 'date',\n    //e : 'error',\n    //r : 'regexp',\n    //y : 'symbol'\n\n  };\n  var LEXICON = {\n    c: 'class',\n    s: 'style',\n    i: 'id',\n    l: 'length',\n    p: 'prototype',\n    ti: 'tabindex',\n    oH: 'offsetHeight',\n    cH: 'clientHeight',\n    sH: 'scrollHeight',\n    oW: 'offsetWidth',\n    cW: 'clientWidth',\n    sW: 'scrollWidth',\n    hOP: 'hasOwnProperty',\n    bCR: 'getBoundingClientRect'\n  };\n\n  var VENDORS = function () {\n    //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix\n    var jsCache = {};\n    var cssCache = {};\n    var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];\n    var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];\n\n    function firstLetterToUpper(str) {\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    }\n\n    return {\n      _cssPrefixes: cssPrefixes,\n      _jsPrefixes: jsPrefixes,\n      _cssProperty: function (name) {\n        var result = cssCache[name];\n        if (cssCache[LEXICON.hOP](name)) return result;\n        var uppercasedName = firstLetterToUpper(name);\n        var elmStyle = document.createElement('div')[LEXICON.s];\n        var resultPossibilities;\n        var i = 0;\n        var v;\n        var currVendorWithoutDashes;\n\n        for (; i < cssPrefixes.length; i++) {\n          currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, '');\n          resultPossibilities = [name, //transition\n          cssPrefixes[i] + name, //-webkit-transition\n          currVendorWithoutDashes + uppercasedName, //webkitTransition\n          firstLetterToUpper(currVendorWithoutDashes) + uppercasedName //WebkitTransition\n          ];\n\n          for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {\n            if (elmStyle[resultPossibilities[v]] !== undefined) {\n              result = resultPossibilities[v];\n              break;\n            }\n          }\n        }\n\n        cssCache[name] = result;\n        return result;\n      },\n      _cssPropertyValue: function (property, values, suffix) {\n        var name = property + ' ' + values;\n        var result = cssCache[name];\n        if (cssCache[LEXICON.hOP](name)) return result;\n        var dummyStyle = document.createElement('div')[LEXICON.s];\n        var possbleValues = values.split(' ');\n        var preparedSuffix = suffix || '';\n        var i = 0;\n        var v = -1;\n        var prop;\n\n        for (; i < possbleValues[LEXICON.l]; i++) {\n          for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {\n            prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];\n            dummyStyle.cssText = property + ':' + prop + preparedSuffix;\n\n            if (dummyStyle[LEXICON.l]) {\n              result = prop;\n              break;\n            }\n          }\n        }\n\n        cssCache[name] = result;\n        return result;\n      },\n      _jsAPI: function (name, isInterface, fallback) {\n        var i = 0;\n        var result = jsCache[name];\n\n        if (!jsCache[LEXICON.hOP](name)) {\n          result = window[name];\n\n          for (; i < jsPrefixes[LEXICON.l]; i++) result = result || window[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];\n\n          jsCache[name] = result;\n        }\n\n        return result || fallback;\n      }\n    };\n  }();\n\n  var COMPATIBILITY = function () {\n    function windowSize(x) {\n      return x ? window.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW] : window.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];\n    }\n\n    function bind(func, thisObj) {\n      if (typeof func != TYPES.f) {\n        throw \"Can't bind function!\"; // closest thing possible to the ECMAScript 5\n        // internal IsCallable function\n        //throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n      }\n\n      var proto = LEXICON.p;\n      var aArgs = Array[proto].slice.call(arguments, 2);\n\n      var fNOP = function () {};\n\n      var fBound = function () {\n        return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments)));\n      };\n\n      if (func[proto]) fNOP[proto] = func[proto]; // Function.prototype doesn't have a prototype property\n\n      fBound[proto] = new fNOP();\n      return fBound;\n    }\n\n    return {\n      /**\r\n       * Gets the current window width.\r\n       * @returns {Number|number} The current window width in pixel.\r\n       */\n      wW: bind(windowSize, 0, true),\n\n      /**\r\n       * Gets the current window height.\r\n       * @returns {Number|number} The current window height in pixel.\r\n       */\n      wH: bind(windowSize, 0),\n\n      /**\r\n       * Gets the MutationObserver Object or undefined if not supported.\r\n       * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.\r\n       */\n      mO: bind(VENDORS._jsAPI, 0, 'MutationObserver', true),\n\n      /**\r\n       * Gets the ResizeObserver Object or undefined if not supported.\r\n       * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.\r\n       */\n      rO: bind(VENDORS._jsAPI, 0, 'ResizeObserver', true),\n\n      /**\r\n       * Gets the RequestAnimationFrame method or it's corresponding polyfill.\r\n       * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.\r\n       */\n      rAF: bind(VENDORS._jsAPI, 0, 'requestAnimationFrame', false, function (func) {\n        return window.setTimeout(func, 1000 / 60);\n      }),\n\n      /**\r\n       * Gets the CancelAnimationFrame method or it's corresponding polyfill.\r\n       * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.\r\n       */\n      cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function (id) {\n        return window.clearTimeout(id);\n      }),\n\n      /**\r\n       * Gets the current time.\r\n       * @returns {number} The current time.\r\n       */\n      now: function () {\n        return Date.now && Date.now() || new Date().getTime();\n      },\n\n      /**\r\n       * Stops the propagation of the given event.\r\n       * @param event The event of which the propagation shall be stoped.\r\n       */\n      stpP: function (event) {\n        if (event.stopPropagation) event.stopPropagation();else event.cancelBubble = true;\n      },\n\n      /**\r\n       * Prevents the default action of the given event.\r\n       * @param event The event of which the default action shall be prevented.\r\n       */\n      prvD: function (event) {\n        if (event.preventDefault && event.cancelable) event.preventDefault();else event.returnValue = false;\n      },\n\n      /**\r\n       * Gets the pageX and pageY values of the given mouse event.\r\n       * @param event The mouse event of which the pageX and pageX shall be got.\r\n       * @returns {{x: number, y: number}} x = pageX value, y = pageY value.\r\n       */\n      page: function (event) {\n        event = event.originalEvent || event;\n        var strPage = 'page';\n        var strClient = 'client';\n        var strX = 'X';\n        var strY = 'Y';\n        var target = event.target || event.srcElement || document;\n        var eventDoc = target.ownerDocument || document;\n        var doc = eventDoc.documentElement;\n        var body = eventDoc.body; //if touch event return return pageX/Y of it\n\n        if (event.touches !== undefined) {\n          var touch = event.touches[0];\n          return {\n            x: touch[strPage + strX],\n            y: touch[strPage + strY]\n          };\n        } // Calculate pageX/Y if not native supported\n\n\n        if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {\n          return {\n            x: event[strClient + strX] + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0),\n            y: event[strClient + strY] + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)\n          };\n        }\n\n        return {\n          x: event[strPage + strX],\n          y: event[strPage + strY]\n        };\n      },\n\n      /**\r\n       * Gets the clicked mouse button of the given mouse event.\r\n       * @param event The mouse event of which the clicked button shal be got.\r\n       * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)\r\n       */\n      mBtn: function (event) {\n        var button = event.button;\n        if (!event.which && button !== undefined) return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;else return event.which;\n      },\n\n      /**\r\n       * Checks whether a item is in the given array and returns its index.\r\n       * @param item The item of which the position in the array shall be determined.\r\n       * @param arr The array.\r\n       * @returns {number} The zero based index of the item or -1 if the item isn't in the array.\r\n       */\n      inA: function (item, arr) {\n        for (var i = 0; i < arr[LEXICON.l]; i++) //Sometiems in IE a \"SCRIPT70\" Permission denied error occurs if HTML elements in a iFrame are compared\n        try {\n          if (arr[i] === item) return i;\n        } catch (e) {}\n\n        return -1;\n      },\n\n      /**\r\n       * Returns true if the given value is a array.\r\n       * @param arr The potential array.\r\n       * @returns {boolean} True if the given value is a array, false otherwise.\r\n       */\n      isA: function (arr) {\n        var def = Array.isArray;\n        return def ? def(arr) : this.type(arr) == TYPES.a;\n      },\n\n      /**\r\n       * Determine the internal JavaScript [[Class]] of the given object.\r\n       * @param obj The object of which the type shall be determined.\r\n       * @returns {string} The type of the given object.\r\n       */\n      type: function (obj) {\n        if (obj === undefined) return obj + '';\n        if (obj === null) return obj + '';\n        return Object[LEXICON.p].toString.call(obj).replace(/^\\[object (.+)\\]$/, '$1').toLowerCase();\n      },\n      bind: bind\n      /**\r\n       * Gets the vendor-prefixed CSS property by the given name.\r\n       * For example the given name is \"transform\" and you're using a old Firefox browser then the returned value would be \"-moz-transform\".\r\n       * If the browser doesn't need a vendor-prefix, then the returned string is the given name.\r\n       * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.\r\n       * @param propName The unprefixed CSS property name.\r\n       * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.\r\n        cssProp: function(propName) {\r\n          return VENDORS._cssProperty(propName);\r\n      }\r\n      */\n\n    };\n  }();\n\n  var MATH = Math;\n  var JQUERY = window.jQuery;\n\n  var EASING = function () {\n    var _easingsMath = {\n      p: MATH.PI,\n      c: MATH.cos,\n      s: MATH.sin,\n      w: MATH.pow,\n      t: MATH.sqrt,\n      n: MATH.asin,\n      a: MATH.abs,\n      o: 1.70158\n    };\n    /*\r\n     x : current percent (0 - 1),\r\n     t : current time (duration * percent),\r\n     b : start value (from),\r\n     c : end value (to),\r\n     d : duration\r\n       easingName : function(x, t, b, c, d) { return easedValue; }\r\n     */\n\n    return {\n      swing: function (x, t, b, c, d) {\n        return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;\n      },\n      linear: function (x, t, b, c, d) {\n        return x;\n      },\n      easeInQuad: function (x, t, b, c, d) {\n        return c * (t /= d) * t + b;\n      },\n      easeOutQuad: function (x, t, b, c, d) {\n        return -c * (t /= d) * (t - 2) + b;\n      },\n      easeInOutQuad: function (x, t, b, c, d) {\n        return (t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b;\n      },\n      easeInCubic: function (x, t, b, c, d) {\n        return c * (t /= d) * t * t + b;\n      },\n      easeOutCubic: function (x, t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t + 1) + b;\n      },\n      easeInOutCubic: function (x, t, b, c, d) {\n        return (t /= d / 2) < 1 ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;\n      },\n      easeInQuart: function (x, t, b, c, d) {\n        return c * (t /= d) * t * t * t + b;\n      },\n      easeOutQuart: function (x, t, b, c, d) {\n        return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n      },\n      easeInOutQuart: function (x, t, b, c, d) {\n        return (t /= d / 2) < 1 ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n      },\n      easeInQuint: function (x, t, b, c, d) {\n        return c * (t /= d) * t * t * t * t + b;\n      },\n      easeOutQuint: function (x, t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n      },\n      easeInOutQuint: function (x, t, b, c, d) {\n        return (t /= d / 2) < 1 ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n      },\n      easeInSine: function (x, t, b, c, d) {\n        return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;\n      },\n      easeOutSine: function (x, t, b, c, d) {\n        return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;\n      },\n      easeInOutSine: function (x, t, b, c, d) {\n        return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;\n      },\n      easeInExpo: function (x, t, b, c, d) {\n        return t == 0 ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;\n      },\n      easeOutExpo: function (x, t, b, c, d) {\n        return t == d ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;\n      },\n      easeInOutExpo: function (x, t, b, c, d) {\n        if (t == 0) return b;\n        if (t == d) return b + c;\n        if ((t /= d / 2) < 1) return c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b;\n        return c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;\n      },\n      easeInCirc: function (x, t, b, c, d) {\n        return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;\n      },\n      easeOutCirc: function (x, t, b, c, d) {\n        return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;\n      },\n      easeInOutCirc: function (x, t, b, c, d) {\n        return (t /= d / 2) < 1 ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;\n      },\n      easeInElastic: function (x, t, b, c, d) {\n        var s = _easingsMath.o;\n        var p = 0;\n        var a = c;\n        if (t == 0) return b;\n        if ((t /= d) == 1) return b + c;\n        if (!p) p = d * .3;\n\n        if (a < _easingsMath.a(c)) {\n          a = c;\n          s = p / 4;\n        } else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);\n\n        return -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;\n      },\n      easeOutElastic: function (x, t, b, c, d) {\n        var s = _easingsMath.o;\n        var p = 0;\n        var a = c;\n        if (t == 0) return b;\n        if ((t /= d) == 1) return b + c;\n        if (!p) p = d * .3;\n\n        if (a < _easingsMath.a(c)) {\n          a = c;\n          s = p / 4;\n        } else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);\n\n        return a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b;\n      },\n      easeInOutElastic: function (x, t, b, c, d) {\n        var s = _easingsMath.o;\n        var p = 0;\n        var a = c;\n        if (t == 0) return b;\n        if ((t /= d / 2) == 2) return b + c;\n        if (!p) p = d * (.3 * 1.5);\n\n        if (a < _easingsMath.a(c)) {\n          a = c;\n          s = p / 4;\n        } else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);\n\n        if (t < 1) return -.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;\n        return a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * .5 + c + b;\n      },\n      easeInBack: function (x, t, b, c, d, s) {\n        s = s || _easingsMath.o;\n        return c * (t /= d) * t * ((s + 1) * t - s) + b;\n      },\n      easeOutBack: function (x, t, b, c, d, s) {\n        s = s || _easingsMath.o;\n        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n      },\n      easeInOutBack: function (x, t, b, c, d, s) {\n        s = s || _easingsMath.o;\n        return (t /= d / 2) < 1 ? c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n      },\n      easeInBounce: function (x, t, b, c, d) {\n        return c - this.easeOutBounce(x, d - t, 0, c, d) + b;\n      },\n      easeOutBounce: function (x, t, b, c, d) {\n        var o = 7.5625;\n\n        if ((t /= d) < 1 / 2.75) {\n          return c * (o * t * t) + b;\n        } else if (t < 2 / 2.75) {\n          return c * (o * (t -= 1.5 / 2.75) * t + .75) + b;\n        } else if (t < 2.5 / 2.75) {\n          return c * (o * (t -= 2.25 / 2.75) * t + .9375) + b;\n        } else {\n          return c * (o * (t -= 2.625 / 2.75) * t + .984375) + b;\n        }\n      },\n      easeInOutBounce: function (x, t, b, c, d) {\n        return t < d / 2 ? this.easeInBounce(x, t * 2, 0, c, d) * .5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;\n      }\n    };\n    /*\r\n     *\r\n     * TERMS OF USE - EASING EQUATIONS\r\n     * \r\n     * Open source under the BSD License. \r\n     * \r\n     * Copyright Â© 2001 Robert Penner\r\n     * All rights reserved.\r\n     * \r\n     * Redistribution and use in source and binary forms, with or without modification, \r\n     * are permitted provided that the following conditions are met:\r\n     * \r\n     * Redistributions of source code must retain the above copyright notice, this list of \r\n     * conditions and the following disclaimer.\r\n     * Redistributions in binary form must reproduce the above copyright notice, this list \r\n     * of conditions and the following disclaimer in the documentation and/or other materials \r\n     * provided with the distribution.\r\n     * \r\n     * Neither the name of the author nor the names of contributors may be used to endorse \r\n     * or promote products derived from this software without specific prior written permission.\r\n     * \r\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY \r\n     * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n     * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\r\n     *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\r\n     *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\r\n     *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED \r\n     * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n     *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n     * OF THE POSSIBILITY OF SUCH DAMAGE. \r\n     *\r\n     */\n  }();\n\n  var FRAMEWORK = function () {\n    var _rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n    var _strSpace = ' ';\n    var _strEmpty = '';\n    var _strScrollLeft = 'scrollLeft';\n    var _strScrollTop = 'scrollTop';\n    var _animations = [];\n    var _type = COMPATIBILITY.type;\n    var _cssNumber = {\n      animationIterationCount: true,\n      columnCount: true,\n      fillOpacity: true,\n      flexGrow: true,\n      flexShrink: true,\n      fontWeight: true,\n      lineHeight: true,\n      opacity: true,\n      order: true,\n      orphans: true,\n      widows: true,\n      zIndex: true,\n      zoom: true\n    };\n\n    function extend() {\n      var src,\n          copyIsArray,\n          copy,\n          name,\n          options,\n          clone,\n          target = arguments[0] || {},\n          i = 1,\n          length = arguments[LEXICON.l],\n          deep = false; // Handle a deep copy situation\n\n      if (_type(target) == TYPES.b) {\n        deep = target;\n        target = arguments[1] || {}; // skip the boolean and the target\n\n        i = 2;\n      } // Handle case when target is a string or something (possible in deep copy)\n\n\n      if (_type(target) != TYPES.o && !_type(target) == TYPES.f) {\n        target = {};\n      } // extend jQuery itself if only one argument is passed\n\n\n      if (length === i) {\n        target = FakejQuery;\n        --i;\n      }\n\n      for (; i < length; i++) {\n        // Only deal with non-null/undefined values\n        if ((options = arguments[i]) != null) {\n          // Extend the base object\n          for (name in options) {\n            src = target[name];\n            copy = options[name]; // Prevent never-ending loop\n\n            if (target === copy) {\n              continue;\n            } // Recurse if we're merging plain objects or arrays\n\n\n            if (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {\n              if (copyIsArray) {\n                copyIsArray = false;\n                clone = src && COMPATIBILITY.isA(src) ? src : [];\n              } else {\n                clone = src && isPlainObject(src) ? src : {};\n              } // Never move original objects, clone them\n\n\n              target[name] = extend(deep, clone, copy); // Don't bring in undefined values\n            } else if (copy !== undefined) {\n              target[name] = copy;\n            }\n          }\n        }\n      } // Return the modified object\n\n\n      return target;\n    }\n\n    ;\n\n    function inArray(item, arr, fromIndex) {\n      for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++) if (arr[i] === item) return i;\n\n      return -1;\n    }\n\n    function isFunction(obj) {\n      return _type(obj) == TYPES.f;\n    }\n\n    ;\n\n    function isEmptyObject(obj) {\n      for (var name in obj) return false;\n\n      return true;\n    }\n\n    ;\n\n    function isPlainObject(obj) {\n      if (!obj || _type(obj) != TYPES.o) return false;\n      var key;\n      var proto = LEXICON.p;\n      var hasOwnProperty = Object[proto].hasOwnProperty;\n      var hasOwnConstructor = hasOwnProperty.call(obj, 'constructor');\n      var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], 'isPrototypeOf');\n\n      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n        return false;\n      }\n\n      for (key in obj) {\n        /**/\n      }\n\n      return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);\n    }\n\n    ;\n\n    function each(obj, callback) {\n      var i = 0;\n\n      if (isArrayLike(obj)) {\n        for (; i < obj[LEXICON.l]; i++) {\n          if (callback.call(obj[i], i, obj[i]) === false) break;\n        }\n      } else {\n        for (i in obj) {\n          if (callback.call(obj[i], i, obj[i]) === false) break;\n        }\n      }\n\n      return obj;\n    }\n\n    ;\n\n    function isArrayLike(obj) {\n      var length = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];\n\n      var t = _type(obj);\n\n      return isFunction(t) ? false : t == TYPES.a || length === 0 || _type(length) == TYPES.n && length > 0 && length - 1 in obj;\n    }\n\n    function stripAndCollapse(value) {\n      var tokens = value.match(_rnothtmlwhite) || [];\n      return tokens.join(_strSpace);\n    }\n\n    function matches(elem, selector) {\n      var nodeList = (elem.parentNode || document).querySelectorAll(selector) || [];\n      var i = nodeList[LEXICON.l];\n\n      while (i--) if (nodeList[i] == elem) return true;\n\n      return false;\n    }\n\n    function insertAdjacentElement(el, strategy, child) {\n      if (COMPATIBILITY.isA(child)) {\n        for (var i = 0; i < child[LEXICON.l]; i++) insertAdjacentElement(el, strategy, child[i]);\n      } else if (_type(child) == TYPES.s) el.insertAdjacentHTML(strategy, child);else el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);\n    }\n\n    function setCSSVal(el, prop, val) {\n      try {\n        if (el[LEXICON.s][prop] !== undefined) el[LEXICON.s][prop] = parseCSSVal(prop, val);\n      } catch (e) {}\n    }\n\n    function parseCSSVal(prop, val) {\n      if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n) val += 'px';\n      return val;\n    }\n\n    function startNextAnimationInQ(animObj, removeFromQ) {\n      var index;\n      var nextAnim;\n      if (removeFromQ !== false) animObj.q.splice(0, 1);\n\n      if (animObj.q[LEXICON.l] > 0) {\n        nextAnim = animObj.q[0];\n        animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);\n      } else {\n        index = inArray(animObj, _animations);\n        if (index > -1) _animations.splice(index, 1);\n      }\n    }\n\n    function setAnimationValue(el, prop, value) {\n      if (prop === _strScrollLeft || prop === _strScrollTop) el[prop] = value;else setCSSVal(el, prop, value);\n    }\n\n    function animate(el, props, options, easing, complete, guaranteedNext) {\n      var hasOptions = isPlainObject(options);\n      var from = {};\n      var to = {};\n      var i = 0;\n      var key;\n      var animObj;\n      var start;\n      var progress;\n      var step;\n      var specialEasing;\n      var duration;\n\n      if (hasOptions) {\n        easing = options.easing;\n        start = options.start;\n        progress = options.progress;\n        step = options.step;\n        specialEasing = options.specialEasing;\n        complete = options.complete;\n        duration = options.duration;\n      } else duration = options;\n\n      specialEasing = specialEasing || {};\n      duration = duration || 400;\n      easing = easing || 'swing';\n      guaranteedNext = guaranteedNext || false;\n\n      for (; i < _animations[LEXICON.l]; i++) {\n        if (_animations[i].el === el) {\n          animObj = _animations[i];\n          break;\n        }\n      }\n\n      if (!animObj) {\n        animObj = {\n          el: el,\n          q: []\n        };\n\n        _animations.push(animObj);\n      }\n\n      for (key in props) {\n        if (key === _strScrollLeft || key === _strScrollTop) from[key] = el[key];else from[key] = FakejQuery(el).css(key);\n      }\n\n      for (key in from) {\n        if (from[key] !== props[key] && props[key] !== undefined) to[key] = props[key];\n      }\n\n      if (!isEmptyObject(to)) {\n        var timeNow;\n        var end;\n        var percent;\n        var fromVal;\n        var toVal;\n        var easedVal;\n        var timeStart;\n        var frame;\n        var elapsed;\n        var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);\n        var qObj = {\n          props: to,\n          duration: hasOptions ? options : duration,\n          easing: easing,\n          complete: complete\n        };\n\n        if (qPos === -1) {\n          qPos = animObj.q[LEXICON.l];\n          animObj.q.push(qObj);\n        }\n\n        if (qPos === 0) {\n          if (duration > 0) {\n            timeStart = COMPATIBILITY.now();\n\n            frame = function () {\n              timeNow = COMPATIBILITY.now();\n              elapsed = timeNow - timeStart;\n              end = qObj.stop || elapsed >= duration;\n              percent = 1 - (MATH.max(0, timeStart + duration - timeNow) / duration || 0);\n\n              for (key in to) {\n                fromVal = parseFloat(from[key]);\n                toVal = parseFloat(to[key]);\n                easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal;\n                setAnimationValue(el, key, easedVal);\n\n                if (isFunction(step)) {\n                  step(easedVal, {\n                    elem: el,\n                    prop: key,\n                    start: fromVal,\n                    now: easedVal,\n                    end: toVal,\n                    pos: percent,\n                    options: {\n                      easing: easing,\n                      speacialEasing: specialEasing,\n                      duration: duration,\n                      complete: complete,\n                      step: step\n                    },\n                    startTime: timeStart\n                  });\n                }\n              }\n\n              if (isFunction(progress)) progress({}, percent, MATH.max(0, duration - elapsed));\n\n              if (end) {\n                startNextAnimationInQ(animObj);\n                if (isFunction(complete)) complete();\n              } else qObj.frame = COMPATIBILITY.rAF()(frame);\n            };\n\n            qObj.frame = COMPATIBILITY.rAF()(frame);\n          } else {\n            for (key in to) setAnimationValue(el, key, to[key]);\n\n            startNextAnimationInQ(animObj);\n          }\n        }\n      } else if (guaranteedNext) startNextAnimationInQ(animObj);\n    }\n\n    function stop(el, clearQ, jumpToEnd) {\n      var animObj;\n      var qObj;\n      var key;\n      var i = 0;\n\n      for (; i < _animations[LEXICON.l]; i++) {\n        animObj = _animations[i];\n\n        if (animObj.el === el) {\n          if (animObj.q[LEXICON.l] > 0) {\n            qObj = animObj.q[0];\n            qObj.stop = true;\n            COMPATIBILITY.cAF()(qObj.frame);\n            animObj.q.splice(0, 1);\n            if (jumpToEnd) for (key in qObj.props) setAnimationValue(el, key, qObj.props[key]);\n            if (clearQ) animObj.q = [];else startNextAnimationInQ(animObj, false);\n          }\n\n          break;\n        }\n      }\n    }\n\n    function elementIsVisible(el) {\n      return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);\n    }\n\n    function FakejQuery(selector) {\n      if (arguments[LEXICON.l] === 0) return this;\n      var base = new FakejQuery();\n      var elements = selector;\n      var i = 0;\n      var elms;\n      var el;\n\n      if (_type(selector) == TYPES.s) {\n        elements = [];\n\n        if (selector.charAt(0) === '<') {\n          el = document.createElement('div');\n          el.innerHTML = selector;\n          elms = el.children;\n        } else {\n          elms = document.querySelectorAll(selector);\n        }\n\n        for (; i < elms[LEXICON.l]; i++) elements.push(elms[i]);\n      }\n\n      if (elements) {\n        if (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window || elements === elements.self)) elements = [elements];\n\n        for (i = 0; i < elements[LEXICON.l]; i++) base[i] = elements[i];\n\n        base[LEXICON.l] = elements[LEXICON.l];\n      }\n\n      return base;\n    }\n\n    ;\n    FakejQuery[LEXICON.p] = {\n      //EVENTS:\n      on: function (eventName, handler) {\n        eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];\n        var eventNameLength = eventName[LEXICON.l];\n        var i = 0;\n        var el;\n        return this.each(function () {\n          el = this;\n\n          try {\n            if (el.addEventListener) {\n              for (; i < eventNameLength; i++) el.addEventListener(eventName[i], handler);\n            } else if (el.detachEvent) {\n              for (; i < eventNameLength; i++) el.attachEvent('on' + eventName[i], handler);\n            }\n          } catch (e) {}\n        });\n      },\n      off: function (eventName, handler) {\n        eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];\n        var eventNameLength = eventName[LEXICON.l];\n        var i = 0;\n        var el;\n        return this.each(function () {\n          el = this;\n\n          try {\n            if (el.removeEventListener) {\n              for (; i < eventNameLength; i++) el.removeEventListener(eventName[i], handler);\n            } else if (el.detachEvent) {\n              for (; i < eventNameLength; i++) el.detachEvent('on' + eventName[i], handler);\n            }\n          } catch (e) {}\n        });\n      },\n      one: function (eventName, handler) {\n        eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];\n        return this.each(function () {\n          var el = FakejQuery(this);\n          FakejQuery.each(eventName, function (i, oneEventName) {\n            var oneHandler = function (e) {\n              handler.call(this, e);\n              el.off(oneEventName, oneHandler);\n            };\n\n            el.on(oneEventName, oneHandler);\n          });\n        });\n      },\n      trigger: function (eventName) {\n        var el;\n        var event;\n        return this.each(function () {\n          el = this;\n\n          if (document.createEvent) {\n            event = document.createEvent('HTMLEvents');\n            event.initEvent(eventName, true, false);\n            el.dispatchEvent(event);\n          } else {\n            el.fireEvent('on' + eventName);\n          }\n        });\n      },\n      //DOM NODE INSERTING / REMOVING:\n      append: function (child) {\n        return this.each(function () {\n          insertAdjacentElement(this, 'beforeend', child);\n        });\n      },\n      prepend: function (child) {\n        return this.each(function () {\n          insertAdjacentElement(this, 'afterbegin', child);\n        });\n      },\n      before: function (child) {\n        return this.each(function () {\n          insertAdjacentElement(this, 'beforebegin', child);\n        });\n      },\n      after: function (child) {\n        return this.each(function () {\n          insertAdjacentElement(this, 'afterend', child);\n        });\n      },\n      remove: function () {\n        return this.each(function () {\n          var el = this;\n          var parentNode = el.parentNode;\n          if (parentNode != null) parentNode.removeChild(el);\n        });\n      },\n      unwrap: function () {\n        var parents = [];\n        var i;\n        var el;\n        var parent;\n        this.each(function () {\n          parent = this.parentNode;\n          if (inArray(parent, parents) === -1) parents.push(parent);\n        });\n\n        for (i = 0; i < parents[LEXICON.l]; i++) {\n          el = parents[i];\n          parent = el.parentNode;\n\n          while (el.firstChild) parent.insertBefore(el.firstChild, el);\n\n          parent.removeChild(el);\n        }\n\n        return this;\n      },\n      wrapAll: function (wrapperHTML) {\n        var i;\n        var nodes = this;\n        var wrapper = FakejQuery(wrapperHTML)[0];\n        var deepest = wrapper;\n        var parent = nodes[0].parentNode;\n        var previousSibling = nodes[0].previousSibling;\n\n        while (deepest.childNodes[LEXICON.l] > 0) deepest = deepest.childNodes[0];\n\n        for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++) deepest.appendChild(nodes[i]);\n\n        var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;\n        parent.insertBefore(wrapper, nextSibling);\n        return this;\n      },\n      wrapInner: function (wrapperHTML) {\n        return this.each(function () {\n          var el = FakejQuery(this);\n          var contents = el.contents();\n          if (contents[LEXICON.l]) contents.wrapAll(wrapperHTML);else el.append(wrapperHTML);\n        });\n      },\n      wrap: function (wrapperHTML) {\n        return this.each(function () {\n          FakejQuery(this).wrapAll(wrapperHTML);\n        });\n      },\n      //DOM NODE MANIPULATION / INFORMATION:\n      css: function (styles, val) {\n        var el;\n        var key;\n        var cptStyle;\n        var getCptStyle = window.getComputedStyle;\n\n        if (_type(styles) == TYPES.s) {\n          if (val === undefined) {\n            el = this[0];\n            cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles]; //https://bugzilla.mozilla.org/show_bug.cgi?id=548397 can be null sometimes if iframe with display: none (firefox only!)\n\n            return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles) : el[LEXICON.s][styles] : cptStyle;\n          } else {\n            return this.each(function () {\n              setCSSVal(this, styles, val);\n            });\n          }\n        } else {\n          return this.each(function () {\n            for (key in styles) setCSSVal(this, key, styles[key]);\n          });\n        }\n      },\n      hasClass: function (className) {\n        var elem,\n            i = 0;\n        var classNamePrepared = _strSpace + className + _strSpace;\n        var classList;\n\n        while (elem = this[i++]) {\n          classList = elem.classList;\n          if (classList && classList.contains(className)) return true;else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1) return true;\n        }\n\n        return false;\n      },\n      addClass: function (className) {\n        var classes;\n        var elem;\n        var cur;\n        var curValue;\n        var clazz;\n        var finalValue;\n        var supportClassList;\n        var elmClassList;\n        var i = 0;\n        var v = 0;\n\n        if (className) {\n          classes = className.match(_rnothtmlwhite) || [];\n\n          while (elem = this[i++]) {\n            elmClassList = elem.classList;\n            if (supportClassList === undefined) supportClassList = elmClassList !== undefined;\n\n            if (supportClassList) {\n              while (clazz = classes[v++]) elmClassList.add(clazz);\n            } else {\n              curValue = elem.className + _strEmpty;\n              cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace;\n\n              if (cur) {\n                while (clazz = classes[v++]) if (cur.indexOf(_strSpace + clazz + _strSpace) < 0) cur += clazz + _strSpace;\n\n                finalValue = stripAndCollapse(cur);\n                if (curValue !== finalValue) elem.className = finalValue;\n              }\n            }\n          }\n        }\n\n        return this;\n      },\n      removeClass: function (className) {\n        var classes;\n        var elem;\n        var cur;\n        var curValue;\n        var clazz;\n        var finalValue;\n        var supportClassList;\n        var elmClassList;\n        var i = 0;\n        var v = 0;\n\n        if (className) {\n          classes = className.match(_rnothtmlwhite) || [];\n\n          while (elem = this[i++]) {\n            elmClassList = elem.classList;\n            if (supportClassList === undefined) supportClassList = elmClassList !== undefined;\n\n            if (supportClassList) {\n              while (clazz = classes[v++]) elmClassList.remove(clazz);\n            } else {\n              curValue = elem.className + _strEmpty;\n              cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace;\n\n              if (cur) {\n                while (clazz = classes[v++]) while (cur.indexOf(_strSpace + clazz + _strSpace) > -1) cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);\n\n                finalValue = stripAndCollapse(cur);\n                if (curValue !== finalValue) elem.className = finalValue;\n              }\n            }\n          }\n        }\n\n        return this;\n      },\n      hide: function () {\n        return this.each(function () {\n          this[LEXICON.s].display = 'none';\n        });\n      },\n      show: function () {\n        return this.each(function () {\n          this[LEXICON.s].display = 'block';\n        });\n      },\n      attr: function (attrName, value) {\n        var i = 0;\n        var el;\n\n        while (el = this[i++]) {\n          if (value === undefined) return el.getAttribute(attrName);\n          el.setAttribute(attrName, value);\n        }\n\n        return this;\n      },\n      removeAttr: function (attrName) {\n        return this.each(function () {\n          this.removeAttribute(attrName);\n        });\n      },\n      offset: function () {\n        var el = this[0];\n        var rect = el[LEXICON.bCR]();\n        var scrollLeft = window.pageXOffset || document.documentElement[_strScrollLeft];\n        var scrollTop = window.pageYOffset || document.documentElement[_strScrollTop];\n        return {\n          top: rect.top + scrollTop,\n          left: rect.left + scrollLeft\n        };\n      },\n      position: function () {\n        var el = this[0];\n        return {\n          top: el.offsetTop,\n          left: el.offsetLeft\n        };\n      },\n      scrollLeft: function (value) {\n        var i = 0;\n        var el;\n\n        while (el = this[i++]) {\n          if (value === undefined) return el[_strScrollLeft];\n          el[_strScrollLeft] = value;\n        }\n\n        return this;\n      },\n      scrollTop: function (value) {\n        var i = 0;\n        var el;\n\n        while (el = this[i++]) {\n          if (value === undefined) return el[_strScrollTop];\n          el[_strScrollTop] = value;\n        }\n\n        return this;\n      },\n      val: function (value) {\n        var el = this[0];\n        if (!value) return el.value;\n        el.value = value;\n        return this;\n      },\n      //DOM TRAVERSAL / FILTERING:\n      first: function () {\n        return this.eq(0);\n      },\n      last: function () {\n        return this.eq(-1);\n      },\n      eq: function (index) {\n        return FakejQuery(this[index >= 0 ? index : this[LEXICON.l] + index]);\n      },\n      find: function (selector) {\n        var children = [];\n        var i;\n        this.each(function () {\n          var el = this;\n          var ch = el.querySelectorAll(selector);\n\n          for (i = 0; i < ch[LEXICON.l]; i++) children.push(ch[i]);\n        });\n        return FakejQuery(children);\n      },\n      children: function (selector) {\n        var children = [];\n        var el;\n        var ch;\n        var i;\n        this.each(function () {\n          ch = this.children;\n\n          for (i = 0; i < ch[LEXICON.l]; i++) {\n            el = ch[i];\n\n            if (selector) {\n              if (el.matches && el.matches(selector) || matches(el, selector)) children.push(el);\n            } else children.push(el);\n          }\n        });\n        return FakejQuery(children);\n      },\n      parent: function (selector) {\n        var parents = [];\n        var parent;\n        this.each(function () {\n          parent = this.parentNode;\n          if (selector ? FakejQuery(parent).is(selector) : true) parents.push(parent);\n        });\n        return FakejQuery(parents);\n      },\n      is: function (selector) {\n        var el;\n        var i;\n\n        for (i = 0; i < this[LEXICON.l]; i++) {\n          el = this[i];\n          if (selector === ':visible') return elementIsVisible(el);\n          if (selector === ':hidden') return !elementIsVisible(el);\n          if (el.matches && el.matches(selector) || matches(el, selector)) return true;\n        }\n\n        return false;\n      },\n      contents: function () {\n        var contents = [];\n        var childs;\n        var i;\n        this.each(function () {\n          childs = this.childNodes;\n\n          for (i = 0; i < childs[LEXICON.l]; i++) contents.push(childs[i]);\n        });\n        return FakejQuery(contents);\n      },\n      each: function (callback) {\n        return each(this, callback);\n      },\n      //ANIMATION:\n      animate: function (props, duration, easing, complete) {\n        return this.each(function () {\n          animate(this, props, duration, easing, complete);\n        });\n      },\n      stop: function (clearQ, jump) {\n        return this.each(function () {\n          stop(this, clearQ, jump);\n        });\n      }\n    };\n    extend(FakejQuery, {\n      extend: extend,\n      inArray: inArray,\n      isEmptyObject: isEmptyObject,\n      isPlainObject: isPlainObject,\n      each: each\n    });\n    return FakejQuery;\n  }();\n\n  var INSTANCES = function () {\n    var _targets = [];\n    var _instancePropertyString = '__overlayScrollbars__';\n    /**\r\n     * Register, unregister or get a certain (or all) instances.\r\n     * Register: Pass the target and the instance.\r\n     * Unregister: Pass the target and null.\r\n     * Get Instance: Pass the target from which the instance shall be got.\r\n     * Get Targets: Pass no arguments.\r\n     * @param target The target to which the instance shall be registered / from which the instance shall be unregistered / the instance shall be got\r\n     * @param instance The instance.\r\n     * @returns {*|void} Returns the instance from the given target.\r\n     */\n\n    return function (target, instance) {\n      var argLen = arguments[LEXICON.l];\n\n      if (argLen < 1) {\n        //return all targets\n        return _targets;\n      } else {\n        if (instance) {\n          //register instance\n          target[_instancePropertyString] = instance;\n\n          _targets.push(target);\n        } else {\n          var index = COMPATIBILITY.inA(target, _targets);\n\n          if (index > -1) {\n            if (argLen > 1) {\n              //unregister instance\n              delete target[_instancePropertyString];\n\n              _targets.splice(index, 1);\n            } else {\n              //get instance from target\n              return _targets[index][_instancePropertyString];\n            }\n          }\n        }\n      }\n    };\n  }();\n\n  var PLUGIN = function () {\n    var _plugin;\n\n    var _pluginsGlobals;\n\n    var _pluginsAutoUpdateLoop;\n\n    var _pluginsExtensions = [];\n\n    var _pluginsOptions = function () {\n      var type = COMPATIBILITY.type;\n      var possibleTemplateTypes = [TYPES.b, //boolean\n      TYPES.n, //number\n      TYPES.s, //string\n      TYPES.a, //array\n      TYPES.o, //object\n      TYPES.f, //function\n      TYPES.z //null\n      ];\n      var restrictedStringsSplit = ' ';\n      var restrictedStringsPossibilitiesSplit = ':';\n      var classNameAllowedValues = [TYPES.z, TYPES.s];\n      var numberAllowedValues = TYPES.n;\n      var booleanNullAllowedValues = [TYPES.z, TYPES.b];\n      var booleanTrueTemplate = [true, TYPES.b];\n      var booleanFalseTemplate = [false, TYPES.b];\n      var callbackTemplate = [null, [TYPES.z, TYPES.f]];\n      var updateOnLoadTemplate = [['img'], [TYPES.s, TYPES.a, TYPES.z]];\n      var inheritedAttrsTemplate = [['style', 'class'], [TYPES.s, TYPES.a, TYPES.z]];\n      var resizeAllowedValues = 'n:none b:both h:horizontal v:vertical';\n      var overflowBehaviorAllowedValues = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden';\n      var scrollbarsVisibilityAllowedValues = 'v:visible h:hidden a:auto';\n      var scrollbarsAutoHideAllowedValues = 'n:never s:scroll l:leave m:move';\n      var optionsDefaultsAndTemplate = {\n        className: ['os-theme-dark', classNameAllowedValues],\n        //null || string\n        resize: ['none', resizeAllowedValues],\n        //none || both  || horizontal || vertical || n || b || h || v\n        sizeAutoCapable: booleanTrueTemplate,\n        //true || false\n        clipAlways: booleanTrueTemplate,\n        //true || false\n        normalizeRTL: booleanTrueTemplate,\n        //true || false\n        paddingAbsolute: booleanFalseTemplate,\n        //true || false\n        autoUpdate: [null, booleanNullAllowedValues],\n        //true || false || null\n        autoUpdateInterval: [33, numberAllowedValues],\n        //number\n        updateOnLoad: updateOnLoadTemplate,\n        //string || array || null\n        nativeScrollbarsOverlaid: {\n          showNativeScrollbars: booleanFalseTemplate,\n          //true || false\n          initialize: booleanTrueTemplate //true || false\n\n        },\n        overflowBehavior: {\n          x: ['scroll', overflowBehaviorAllowedValues],\n          //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s\n          y: ['scroll', overflowBehaviorAllowedValues] //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s\n\n        },\n        scrollbars: {\n          visibility: ['auto', scrollbarsVisibilityAllowedValues],\n          //visible || hidden || auto || v || h || a\n          autoHide: ['never', scrollbarsAutoHideAllowedValues],\n          //never || scroll || leave || move || n || s || l || m\n          autoHideDelay: [800, numberAllowedValues],\n          //number\n          dragScrolling: booleanTrueTemplate,\n          //true || false\n          clickScrolling: booleanFalseTemplate,\n          //true || false\n          touchSupport: booleanTrueTemplate,\n          //true || false\n          snapHandle: booleanFalseTemplate //true || false\n\n        },\n        textarea: {\n          dynWidth: booleanFalseTemplate,\n          //true || false\n          dynHeight: booleanFalseTemplate,\n          //true || false\n          inheritedAttrs: inheritedAttrsTemplate //string || array || null\n\n        },\n        callbacks: {\n          onInitialized: callbackTemplate,\n          //null || function\n          onInitializationWithdrawn: callbackTemplate,\n          //null || function\n          onDestroyed: callbackTemplate,\n          //null || function\n          onScrollStart: callbackTemplate,\n          //null || function\n          onScroll: callbackTemplate,\n          //null || function\n          onScrollStop: callbackTemplate,\n          //null || function\n          onOverflowChanged: callbackTemplate,\n          //null || function\n          onOverflowAmountChanged: callbackTemplate,\n          //null || function\n          onDirectionChanged: callbackTemplate,\n          //null || function\n          onContentSizeChanged: callbackTemplate,\n          //null || function\n          onHostSizeChanged: callbackTemplate,\n          //null || function\n          onUpdated: callbackTemplate //null || function\n\n        }\n      };\n\n      var convert = function (template) {\n        var recursive = function (obj) {\n          var key;\n          var val;\n          var valType;\n\n          for (key in obj) {\n            if (!obj[LEXICON.hOP](key)) continue;\n            val = obj[key];\n            valType = type(val);\n            if (valType == TYPES.a) obj[key] = val[template ? 1 : 0];else if (valType == TYPES.o) obj[key] = recursive(val);\n          }\n\n          return obj;\n        };\n\n        return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));\n      };\n\n      return {\n        _defaults: convert(),\n        _template: convert(true),\n\n        /**\r\n         * Validates the passed object by the passed template.\r\n         * @param obj The object which shall be validated.\r\n         * @param template The template which defines the allowed values and types.\r\n         * @param writeErrors True if errors shall be logged to the console.\r\n         * @param diffObj If a object is passed then only valid differences to this object will be returned.\r\n         * @returns {{}} A object which contains two objects called \"default\" and \"prepared\" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.\r\n         */\n        _validate: function (obj, template, writeErrors, diffObj) {\n          var validatedOptions = {};\n          var validatedOptionsPrepared = {};\n          var objectCopy = FRAMEWORK.extend(true, {}, obj);\n          var inArray = FRAMEWORK.inArray;\n          var isEmptyObj = FRAMEWORK.isEmptyObject;\n\n          var checkObjectProps = function (data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {\n            for (var prop in template) {\n              if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {\n                var isValid = false;\n                var isDiff = false;\n                var templateValue = template[prop];\n                var templateValueType = type(templateValue);\n                var templateIsComplex = templateValueType == TYPES.o;\n                var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;\n                var dataDiffValue = diffData[prop];\n                var dataValue = data[prop];\n                var dataValueType = type(dataValue);\n                var propPrefix = prevPropName ? prevPropName + '.' : '';\n                var error = \"The option \\\"\" + propPrefix + prop + \"\\\" wasn't set, because\";\n                var errorPossibleTypes = [];\n                var errorRestrictedStrings = [];\n                var restrictedStringValuesSplit;\n                var restrictedStringValuesPossibilitiesSplit;\n                var isRestrictedValue;\n                var mainPossibility;\n                var currType;\n                var i;\n                var v;\n                var j;\n                dataDiffValue = dataDiffValue === undefined ? {} : dataDiffValue; //if the template has a object as value, it means that the options are complex (verschachtelt)\n\n                if (templateIsComplex && dataValueType == TYPES.o) {\n                  validatedOptions[prop] = {};\n                  validatedOptionsPrepared[prop] = {};\n                  checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions[prop], validatedOptionsPrepared[prop], propPrefix + prop);\n                  FRAMEWORK.each([data, validatedOptions, validatedOptionsPrepared], function (index, value) {\n                    if (isEmptyObj(value[prop])) {\n                      delete value[prop];\n                    }\n                  });\n                } else if (!templateIsComplex) {\n                  for (i = 0; i < templateTypes[LEXICON.l]; i++) {\n                    currType = templateTypes[i];\n                    templateValueType = type(currType); //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix\n\n                    isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;\n\n                    if (isRestrictedValue) {\n                      errorPossibleTypes.push(TYPES.s); //split it into a array which contains all possible values for example: [\"y:yes\", \"n:no\", \"m:maybe\"]\n\n                      restrictedStringValuesSplit = currType.split(restrictedStringsSplit);\n                      errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);\n\n                      for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {\n                        //split the possible values into their possibiliteis for example: [\"y\", \"yes\"] -> the first is always the mainPossibility\n                        restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);\n                        mainPossibility = restrictedStringValuesPossibilitiesSplit[0];\n\n                        for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {\n                          //if any possibility matches with the dataValue, its valid\n                          if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {\n                            isValid = true;\n                            break;\n                          }\n                        }\n\n                        if (isValid) break;\n                      }\n                    } else {\n                      errorPossibleTypes.push(currType);\n\n                      if (dataValueType === currType) {\n                        isValid = true;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (isValid) {\n                    isDiff = dataValue !== dataDiffValue;\n                    if (isDiff) validatedOptions[prop] = dataValue;\n                    if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff) validatedOptionsPrepared[prop] = isRestrictedValue ? mainPossibility : dataValue;\n                  } else if (writeErrors) {\n                    console.warn(error + \" it doesn't accept the type [ \" + dataValueType.toUpperCase() + \" ] with the value of \\\"\" + dataValue + \"\\\".\\r\\n\" + \"Accepted types are: [ \" + errorPossibleTypes.join(', ').toUpperCase() + \" ].\" + (errorRestrictedStrings[length] > 0 ? \"\\r\\nValid strings are: [ \" + errorRestrictedStrings.join(', ').split(restrictedStringsPossibilitiesSplit).join(', ') + \" ].\" : ''));\n                  }\n\n                  delete data[prop];\n                }\n              }\n            }\n          };\n\n          checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared); //add values which aren't specified in the template to the finished validated object to prevent them from being discarded\n\n          /*\r\n          if(keepForeignProps) {\r\n              FRAMEWORK.extend(true, validatedOptions, objectCopy);\r\n              FRAMEWORK.extend(true, validatedOptionsPrepared, objectCopy);\r\n          }\r\n          */\n\n          if (!isEmptyObj(objectCopy) && writeErrors) console.warn('The following options are discarded due to invalidity:\\r\\n' + window.JSON.stringify(objectCopy, null, 2));\n          return {\n            _default: validatedOptions,\n            _prepared: validatedOptionsPrepared\n          };\n        }\n      };\n    }();\n    /**\r\n     * Initializes the object which contains global information about the plugin and each instance of it.\r\n     */\n\n\n    function initOverlayScrollbarsStatics() {\n      if (!_pluginsGlobals) _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);\n      if (!_pluginsAutoUpdateLoop) _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);\n    }\n    /**\r\n     * The global object for the OverlayScrollbars objects. It contains resources which every OverlayScrollbars object needs. This object is initialized only once: if the first OverlayScrollbars object gets initialized.\r\n     * @param defaultOptions\r\n     * @constructor\r\n     */\n\n\n    function OverlayScrollbarsGlobals(defaultOptions) {\n      var _base = this;\n\n      var strOverflow = 'overflow';\n      var strHidden = 'hidden';\n      var strScroll = 'scroll';\n      var bodyElement = FRAMEWORK('body');\n      var scrollbarDummyElement = FRAMEWORK('<div id=\"os-dummy-scrollbar-size\"><div></div></div>');\n      var scrollbarDummyElement0 = scrollbarDummyElement[0];\n      var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children('div').eq(0));\n      bodyElement.append(scrollbarDummyElement);\n      scrollbarDummyElement.hide().show(); //fix IE8 bug (incorrect measuring)\n\n      var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);\n      var nativeScrollbarIsOverlaid = {\n        x: nativeScrollbarSize.x === 0,\n        y: nativeScrollbarSize.y === 0\n      };\n\n      var msie = function () {\n        var ua = window.navigator.userAgent;\n        var strIndexOf = 'indexOf';\n        var strSubString = 'substring';\n        var msie = ua[strIndexOf]('MSIE ');\n        var trident = ua[strIndexOf]('Trident/');\n        var edge = ua[strIndexOf]('Edge/');\n        var rv = ua[strIndexOf]('rv:');\n        var result;\n        var parseIntFunc = parseInt; // IE 10 or older => return version number\n\n        if (msie > 0) result = parseIntFunc(ua[strSubString](msie + 5, ua[strIndexOf]('.', msie)), 10); // IE 11 => return version number\n        else if (trident > 0) result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf]('.', rv)), 10); // Edge (IE 12+) => return version number\n          else if (edge > 0) result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf]('.', edge)), 10); // other browser\n\n        return result;\n      }();\n\n      FRAMEWORK.extend(_base, {\n        defaultOptions: defaultOptions,\n        msie: msie,\n        autoUpdateLoop: false,\n        autoUpdateRecommended: !COMPATIBILITY.mO(),\n        nativeScrollbarSize: nativeScrollbarSize,\n        nativeScrollbarIsOverlaid: nativeScrollbarIsOverlaid,\n        nativeScrollbarStyling: function () {\n          var result = false;\n          scrollbarDummyElement.addClass('os-viewport-native-scrollbars-invisible');\n\n          try {\n            result = scrollbarDummyElement.css('scrollbar-width') === 'none' && (msie > 9 || !msie) || window.getComputedStyle(scrollbarDummyElement0, '::-webkit-scrollbar').getPropertyValue('display') === 'none';\n          } catch (ex) {} //fix opera bug: scrollbar styles will only appear if overflow value is scroll or auto during the activation of the style.\n          //and set overflow to scroll\n          //scrollbarDummyElement.css(strOverflow, strHidden).hide().css(strOverflow, strScroll).show();\n          //return (scrollbarDummyElement0[LEXICON.oH] - scrollbarDummyElement0[LEXICON.cH]) === 0 && (scrollbarDummyElement0[LEXICON.oW] - scrollbarDummyElement0[LEXICON.cW]) === 0;\n\n\n          return result;\n        }(),\n        overlayScrollbarDummySize: {\n          x: 30,\n          y: 30\n        },\n        cssCalc: VENDORS._cssPropertyValue('width', 'calc', '(1px)') || null,\n        restrictedMeasuring: function () {\n          //https://bugzilla.mozilla.org/show_bug.cgi?id=1439305\n          //since 1.11.0 always false -> fixed via CSS (hopefully)\n          scrollbarDummyElement.css(strOverflow, strHidden);\n          var scrollSize = {\n            w: scrollbarDummyElement0[LEXICON.sW],\n            h: scrollbarDummyElement0[LEXICON.sH]\n          };\n          scrollbarDummyElement.css(strOverflow, 'visible');\n          var scrollSize2 = {\n            w: scrollbarDummyElement0[LEXICON.sW],\n            h: scrollbarDummyElement0[LEXICON.sH]\n          };\n          return scrollSize.w - scrollSize2.w !== 0 || scrollSize.h - scrollSize2.h !== 0;\n        }(),\n        rtlScrollBehavior: function () {\n          scrollbarDummyElement.css({\n            'overflow-y': strHidden,\n            'overflow-x': strScroll,\n            'direction': 'rtl'\n          }).scrollLeft(0);\n          var dummyContainerOffset = scrollbarDummyElement.offset();\n          var dummyContainerChildOffset = dummyContainerChild.offset(); //https://github.com/KingSora/OverlayScrollbars/issues/187\n\n          scrollbarDummyElement.scrollLeft(-999);\n          var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();\n          return {\n            //origin direction = determines if the zero scroll position is on the left or right side\n            //'i' means 'invert' (i === true means that the axis must be inverted to be correct)\n            //true = on the left side\n            //false = on the right side\n            i: dummyContainerOffset.left === dummyContainerChildOffset.left,\n            //negative = determines if the maximum scroll is positive or negative\n            //'n' means 'negate' (n === true means that the axis must be negated to be correct)\n            //true = negative\n            //false = positive\n            n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left\n          };\n        }(),\n        supportTransform: !!VENDORS._cssProperty('transform'),\n        supportTransition: !!VENDORS._cssProperty('transition'),\n        supportPassiveEvents: function () {\n          var supportsPassive = false;\n\n          try {\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n              get: function () {\n                supportsPassive = true;\n              }\n            }));\n          } catch (e) {}\n\n          return supportsPassive;\n        }(),\n        supportResizeObserver: !!COMPATIBILITY.rO(),\n        supportMutationObserver: !!COMPATIBILITY.mO()\n      });\n      scrollbarDummyElement.removeAttr(LEXICON.s).remove(); //Catch zoom event:\n\n      (function () {\n        if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y) return;\n        var abs = MATH.abs;\n        var windowWidth = COMPATIBILITY.wW();\n        var windowHeight = COMPATIBILITY.wH();\n        var windowDpr = getWindowDPR();\n\n        var onResize = function () {\n          if (INSTANCES().length > 0) {\n            var newW = COMPATIBILITY.wW();\n            var newH = COMPATIBILITY.wH();\n            var deltaW = newW - windowWidth;\n            var deltaH = newH - windowHeight;\n            if (deltaW === 0 && deltaH === 0) return;\n            var deltaWRatio = MATH.round(newW / (windowWidth / 100.0));\n            var deltaHRatio = MATH.round(newH / (windowHeight / 100.0));\n            var absDeltaW = abs(deltaW);\n            var absDeltaH = abs(deltaH);\n            var absDeltaWRatio = abs(deltaWRatio);\n            var absDeltaHRatio = abs(deltaHRatio);\n            var newDPR = getWindowDPR();\n            var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;\n            var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);\n            var dprChanged = newDPR !== windowDpr && windowDpr > 0;\n            var isZoom = deltaIsBigger && difference && dprChanged;\n            var oldScrollbarSize = _base.nativeScrollbarSize;\n            var newScrollbarSize;\n\n            if (isZoom) {\n              bodyElement.append(scrollbarDummyElement);\n              newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);\n              scrollbarDummyElement.remove();\n\n              if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {\n                FRAMEWORK.each(INSTANCES(), function () {\n                  if (INSTANCES(this)) INSTANCES(this).update('zoom');\n                });\n              }\n            }\n\n            windowWidth = newW;\n            windowHeight = newH;\n            windowDpr = newDPR;\n          }\n        };\n\n        function differenceIsBiggerThanOne(valOne, valTwo) {\n          var absValOne = abs(valOne);\n          var absValTwo = abs(valTwo);\n          return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);\n        }\n\n        function getWindowDPR() {\n          var dDPI = window.screen.deviceXDPI || 0;\n          var sDPI = window.screen.logicalXDPI || 1;\n          return window.devicePixelRatio || dDPI / sDPI;\n        }\n\n        FRAMEWORK(window).on('resize', onResize);\n      })();\n\n      function calcNativeScrollbarSize(measureElement) {\n        return {\n          x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],\n          y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]\n        };\n      }\n    }\n    /**\r\n     * The object which manages the auto update loop for all OverlayScrollbars objects. This object is initialized only once: if the first OverlayScrollbars object gets initialized.\r\n     * @constructor\r\n     */\n\n\n    function OverlayScrollbarsAutoUpdateLoop(globals) {\n      var _base = this;\n\n      var _inArray = FRAMEWORK.inArray;\n      var _getNow = COMPATIBILITY.now;\n      var _strAutoUpdate = 'autoUpdate';\n\n      var _strAutoUpdateInterval = _strAutoUpdate + 'Interval';\n\n      var _strLength = LEXICON.l;\n      var _loopingInstances = [];\n      var _loopingInstancesIntervalCache = [];\n      var _loopIsActive = false;\n      var _loopIntervalDefault = 33;\n      var _loopInterval = _loopIntervalDefault;\n\n      var _loopTimeOld = _getNow();\n\n      var _loopID;\n      /**\r\n       * The auto update loop which will run every 50 milliseconds or less if the update interval of a instance is lower than 50 milliseconds.\r\n       */\n\n\n      var loop = function () {\n        if (_loopingInstances[_strLength] > 0 && _loopIsActive) {\n          _loopID = COMPATIBILITY.rAF()(function () {\n            loop();\n          });\n\n          var timeNew = _getNow();\n\n          var timeDelta = timeNew - _loopTimeOld;\n          var lowestInterval;\n          var instance;\n          var instanceOptions;\n          var instanceAutoUpdateAllowed;\n          var instanceAutoUpdateInterval;\n          var now;\n\n          if (timeDelta > _loopInterval) {\n            _loopTimeOld = timeNew - timeDelta % _loopInterval;\n            lowestInterval = _loopIntervalDefault;\n\n            for (var i = 0; i < _loopingInstances[_strLength]; i++) {\n              instance = _loopingInstances[i];\n\n              if (instance !== undefined) {\n                instanceOptions = instance.options();\n                instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];\n                instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);\n                now = _getNow();\n\n                if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && now - _loopingInstancesIntervalCache[i] > instanceAutoUpdateInterval) {\n                  instance.update('auto');\n                  _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);\n                }\n\n                lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));\n              }\n            }\n\n            _loopInterval = lowestInterval;\n          }\n        } else {\n          _loopInterval = _loopIntervalDefault;\n        }\n      };\n      /**\r\n       * Add OverlayScrollbars instance to the auto update loop. Only successful if the instance isn't already added.\r\n       * @param instance The instance which shall be updated in a loop automatically.\r\n       */\n\n\n      _base.add = function (instance) {\n        if (_inArray(instance, _loopingInstances) === -1) {\n          _loopingInstances.push(instance);\n\n          _loopingInstancesIntervalCache.push(_getNow());\n\n          if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {\n            _loopIsActive = true;\n            globals.autoUpdateLoop = _loopIsActive;\n            loop();\n          }\n        }\n      };\n      /**\r\n       * Remove OverlayScrollbars instance from the auto update loop. Only successful if the instance was added before.\r\n       * @param instance The instance which shall be updated in a loop automatically.\r\n       */\n\n\n      _base.remove = function (instance) {\n        var index = _inArray(instance, _loopingInstances);\n\n        if (index > -1) {\n          //remove from loopingInstances list\n          _loopingInstancesIntervalCache.splice(index, 1);\n\n          _loopingInstances.splice(index, 1); //correct update loop behavior\n\n\n          if (_loopingInstances[_strLength] === 0 && _loopIsActive) {\n            _loopIsActive = false;\n            globals.autoUpdateLoop = _loopIsActive;\n\n            if (_loopID !== undefined) {\n              COMPATIBILITY.cAF()(_loopID);\n              _loopID = -1;\n            }\n          }\n        }\n      };\n    }\n    /**\r\n     * A object which manages the scrollbars visibility of the target element.\r\n     * @param pluginTargetElement The element from which the scrollbars shall be hidden.\r\n     * @param options The custom options.\r\n     * @param extensions The custom extensions.\r\n     * @param globals\r\n     * @param autoUpdateLoop\r\n     * @returns {*}\r\n     * @constructor\r\n     */\n\n\n    function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {\n      //shortcuts\n      var type = COMPATIBILITY.type;\n      var inArray = FRAMEWORK.inArray;\n      var each = FRAMEWORK.each; //make correct instanceof\n\n      var _base = new _plugin();\n\n      var _frameworkProto = FRAMEWORK[LEXICON.p]; //if passed element is no HTML element: skip and return\n\n      if (!isHTMLElement(pluginTargetElement)) return; //if passed element is already initialized: set passed options if there are any and return its instance\n\n      if (INSTANCES(pluginTargetElement)) {\n        var inst = INSTANCES(pluginTargetElement);\n        inst.options(options);\n        return inst;\n      } //globals:\n\n\n      var _nativeScrollbarIsOverlaid;\n\n      var _overlayScrollbarDummySize;\n\n      var _rtlScrollBehavior;\n\n      var _autoUpdateRecommended;\n\n      var _msieVersion;\n\n      var _nativeScrollbarStyling;\n\n      var _cssCalc;\n\n      var _nativeScrollbarSize;\n\n      var _supportTransition;\n\n      var _supportTransform;\n\n      var _supportPassiveEvents;\n\n      var _supportResizeObserver;\n\n      var _supportMutationObserver;\n\n      var _restrictedMeasuring; //general readonly:\n\n\n      var _initialized;\n\n      var _destroyed;\n\n      var _isTextarea;\n\n      var _isBody;\n\n      var _documentMixed;\n\n      var _domExists; //general:\n\n\n      var _isBorderBox;\n\n      var _sizeAutoObserverAdded;\n\n      var _paddingX;\n\n      var _paddingY;\n\n      var _borderX;\n\n      var _borderY;\n\n      var _marginX;\n\n      var _marginY;\n\n      var _isRTL;\n\n      var _sleeping;\n\n      var _contentBorderSize = {};\n      var _scrollHorizontalInfo = {};\n      var _scrollVerticalInfo = {};\n      var _viewportSize = {};\n      var _nativeScrollbarMinSize = {}; //naming:\t\n\n      var _strMinusHidden = '-hidden';\n      var _strMarginMinus = 'margin-';\n      var _strPaddingMinus = 'padding-';\n      var _strBorderMinus = 'border-';\n      var _strTop = 'top';\n      var _strRight = 'right';\n      var _strBottom = 'bottom';\n      var _strLeft = 'left';\n      var _strMinMinus = 'min-';\n      var _strMaxMinus = 'max-';\n      var _strWidth = 'width';\n      var _strHeight = 'height';\n      var _strFloat = 'float';\n      var _strEmpty = '';\n      var _strAuto = 'auto';\n      var _strSync = 'sync';\n      var _strScroll = 'scroll';\n      var _strHundredPercent = '100%';\n      var _strX = 'x';\n      var _strY = 'y';\n      var _strDot = '.';\n      var _strSpace = ' ';\n      var _strScrollbar = 'scrollbar';\n      var _strMinusHorizontal = '-horizontal';\n      var _strMinusVertical = '-vertical';\n\n      var _strScrollLeft = _strScroll + 'Left';\n\n      var _strScrollTop = _strScroll + 'Top';\n\n      var _strMouseTouchDownEvent = 'mousedown touchstart';\n      var _strMouseTouchUpEvent = 'mouseup touchend touchcancel';\n      var _strMouseTouchMoveEvent = 'mousemove touchmove';\n      var _strMouseEnter = 'mouseenter';\n      var _strMouseLeave = 'mouseleave';\n      var _strKeyDownEvent = 'keydown';\n      var _strKeyUpEvent = 'keyup';\n      var _strSelectStartEvent = 'selectstart';\n      var _strTransitionEndEvent = 'transitionend webkitTransitionEnd oTransitionEnd';\n      var _strResizeObserverProperty = '__overlayScrollbarsRO__'; //class names:\t\n\n      var _cassNamesPrefix = 'os-';\n\n      var _classNameHTMLElement = _cassNamesPrefix + 'html';\n\n      var _classNameHostElement = _cassNamesPrefix + 'host';\n\n      var _classNameHostElementForeign = _classNameHostElement + '-foreign';\n\n      var _classNameHostTextareaElement = _classNameHostElement + '-textarea';\n\n      var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusHorizontal + _strMinusHidden;\n\n      var _classNameHostScrollbarVerticalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusVertical + _strMinusHidden;\n\n      var _classNameHostTransition = _classNameHostElement + '-transition';\n\n      var _classNameHostRTL = _classNameHostElement + '-rtl';\n\n      var _classNameHostResizeDisabled = _classNameHostElement + '-resize-disabled';\n\n      var _classNameHostScrolling = _classNameHostElement + '-scrolling';\n\n      var _classNameHostOverflow = _classNameHostElement + '-overflow';\n\n      var _classNameHostOverflow = _classNameHostElement + '-overflow';\n\n      var _classNameHostOverflowX = _classNameHostOverflow + '-x';\n\n      var _classNameHostOverflowY = _classNameHostOverflow + '-y';\n\n      var _classNameTextareaElement = _cassNamesPrefix + 'textarea';\n\n      var _classNameTextareaCoverElement = _classNameTextareaElement + '-cover';\n\n      var _classNamePaddingElement = _cassNamesPrefix + 'padding';\n\n      var _classNameViewportElement = _cassNamesPrefix + 'viewport';\n\n      var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + '-native-scrollbars-invisible';\n\n      var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + '-native-scrollbars-overlaid';\n\n      var _classNameContentElement = _cassNamesPrefix + 'content';\n\n      var _classNameContentArrangeElement = _cassNamesPrefix + 'content-arrange';\n\n      var _classNameContentGlueElement = _cassNamesPrefix + 'content-glue';\n\n      var _classNameSizeAutoObserverElement = _cassNamesPrefix + 'size-auto-observer';\n\n      var _classNameResizeObserverElement = _cassNamesPrefix + 'resize-observer';\n\n      var _classNameResizeObserverItemElement = _cassNamesPrefix + 'resize-observer-item';\n\n      var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + '-final';\n\n      var _classNameTextInherit = _cassNamesPrefix + 'text-inherit';\n\n      var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;\n\n      var _classNameScrollbarTrack = _classNameScrollbar + '-track';\n\n      var _classNameScrollbarTrackOff = _classNameScrollbarTrack + '-off';\n\n      var _classNameScrollbarHandle = _classNameScrollbar + '-handle';\n\n      var _classNameScrollbarHandleOff = _classNameScrollbarHandle + '-off';\n\n      var _classNameScrollbarUnusable = _classNameScrollbar + '-unusable';\n\n      var _classNameScrollbarAutoHidden = _classNameScrollbar + '-' + _strAuto + _strMinusHidden;\n\n      var _classNameScrollbarCorner = _classNameScrollbar + '-corner';\n\n      var _classNameScrollbarCornerResize = _classNameScrollbarCorner + '-resize';\n\n      var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + '-both';\n\n      var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;\n\n      var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;\n\n      var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;\n\n      var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;\n\n      var _classNameDragging = _cassNamesPrefix + 'dragging';\n\n      var _classNameThemeNone = _cassNamesPrefix + 'theme-none';\n\n      var _classNamesDynamicDestroy = [_classNameViewportNativeScrollbarsInvisible, _classNameViewportNativeScrollbarsOverlaid, _classNameScrollbarTrackOff, _classNameScrollbarHandleOff, _classNameScrollbarUnusable, _classNameScrollbarAutoHidden, _classNameScrollbarCornerResize, _classNameScrollbarCornerResizeB, _classNameScrollbarCornerResizeH, _classNameScrollbarCornerResizeV, _classNameDragging].join(_strSpace); //callbacks:\t\n\n\n      var _callbacksInitQeueue = []; //attrs viewport shall inherit from target\t\n\n      var _viewportAttrsFromTarget = [LEXICON.ti]; //options:\t\n\n      var _defaultOptions;\n\n      var _currentOptions;\n\n      var _currentPreparedOptions; //extensions:\t\n\n\n      var _extensions = {};\n      var _extensionsPrivateMethods = 'added removed on contract'; //update\t\n\n      var _lastUpdateTime;\n\n      var _swallowedUpdateHints = {};\n\n      var _swallowedUpdateTimeout;\n\n      var _swallowUpdateLag = 42;\n      var _updateOnLoadEventName = 'load';\n      var _updateOnLoadElms = []; //DOM elements:\t\n\n      var _windowElement;\n\n      var _documentElement;\n\n      var _htmlElement;\n\n      var _bodyElement;\n\n      var _targetElement; //the target element of this OverlayScrollbars object\t\n\n\n      var _hostElement; //the host element of this OverlayScrollbars object -> may be the same as targetElement\t\n\n\n      var _sizeAutoObserverElement; //observes size auto changes\t\n\n\n      var _sizeObserverElement; //observes size and padding changes\t\n\n\n      var _paddingElement; //manages the padding\t\n\n\n      var _viewportElement; //is the viewport of our scrollbar model\t\n\n\n      var _contentElement; //the element which holds the content\t\n\n\n      var _contentArrangeElement; //is needed for correct sizing of the content element (only if native scrollbars are overlays)\t\n\n\n      var _contentGlueElement; //has always the size of the content element\t\n\n\n      var _textareaCoverElement; //only applied if target is a textarea element. Used for correct size calculation and for prevention of uncontrolled scrolling\t\n\n\n      var _scrollbarCornerElement;\n\n      var _scrollbarHorizontalElement;\n\n      var _scrollbarHorizontalTrackElement;\n\n      var _scrollbarHorizontalHandleElement;\n\n      var _scrollbarVerticalElement;\n\n      var _scrollbarVerticalTrackElement;\n\n      var _scrollbarVerticalHandleElement;\n\n      var _windowElementNative;\n\n      var _documentElementNative;\n\n      var _targetElementNative;\n\n      var _hostElementNative;\n\n      var _sizeAutoObserverElementNative;\n\n      var _sizeObserverElementNative;\n\n      var _paddingElementNative;\n\n      var _viewportElementNative;\n\n      var _contentElementNative; //Cache:\t\n\n\n      var _hostSizeCache;\n\n      var _contentScrollSizeCache;\n\n      var _arrangeContentSizeCache;\n\n      var _hasOverflowCache;\n\n      var _hideOverflowCache;\n\n      var _widthAutoCache;\n\n      var _heightAutoCache;\n\n      var _cssBoxSizingCache;\n\n      var _cssPaddingCache;\n\n      var _cssBorderCache;\n\n      var _cssMarginCache;\n\n      var _cssDirectionCache;\n\n      var _cssDirectionDetectedCache;\n\n      var _paddingAbsoluteCache;\n\n      var _clipAlwaysCache;\n\n      var _contentGlueSizeCache;\n\n      var _overflowBehaviorCache;\n\n      var _overflowAmountCache;\n\n      var _ignoreOverlayScrollbarHidingCache;\n\n      var _autoUpdateCache;\n\n      var _sizeAutoCapableCache;\n\n      var _contentElementScrollSizeChangeDetectedCache;\n\n      var _hostElementSizeChangeDetectedCache;\n\n      var _scrollbarsVisibilityCache;\n\n      var _scrollbarsAutoHideCache;\n\n      var _scrollbarsClickScrollingCache;\n\n      var _scrollbarsDragScrollingCache;\n\n      var _resizeCache;\n\n      var _normalizeRTLCache;\n\n      var _classNameCache;\n\n      var _oldClassName;\n\n      var _textareaAutoWrappingCache;\n\n      var _textareaInfoCache;\n\n      var _textareaSizeCache;\n\n      var _textareaDynHeightCache;\n\n      var _textareaDynWidthCache;\n\n      var _bodyMinSizeCache;\n\n      var _updateAutoCache = {}; //MutationObserver:\t\n\n      var _mutationObserverHost;\n\n      var _mutationObserverContent;\n\n      var _mutationObserverHostCallback;\n\n      var _mutationObserverContentCallback;\n\n      var _mutationObserversConnected;\n\n      var _mutationObserverAttrsTextarea = ['wrap', 'cols', 'rows'];\n\n      var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, 'open'].concat(_viewportAttrsFromTarget); //events:\t\n\n\n      var _destroyEvents = []; //textarea:\t\n\n      var _textareaHasFocus; //scrollbars:\t\n\n\n      var _scrollbarsAutoHideTimeoutId;\n\n      var _scrollbarsAutoHideMoveTimeoutId;\n\n      var _scrollbarsAutoHideDelay;\n\n      var _scrollbarsAutoHideNever;\n\n      var _scrollbarsAutoHideScroll;\n\n      var _scrollbarsAutoHideMove;\n\n      var _scrollbarsAutoHideLeave;\n\n      var _scrollbarsHandleHovered;\n\n      var _scrollbarsHandlesDefineScrollPos; //resize\t\n\n\n      var _resizeNone;\n\n      var _resizeBoth;\n\n      var _resizeHorizontal;\n\n      var _resizeVertical; //==== Event Listener ====//\t\n\n      /**\t\r\n       * Adds or removes a event listener from the given element. \t\r\n       * @param element The element to which the event listener shall be applied or removed.\t\r\n       * @param eventNames The name(s) of the events.\t\r\n       * @param listener The method which shall be called.\t\r\n       * @param remove True if the handler shall be removed, false or undefined if the handler shall be added.\t\r\n       */\n\n\n      function setupResponsiveEventListener(element, eventNames, listener, remove, passive) {\n        var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);\n        var method = remove ? 'removeEventListener' : 'addEventListener';\n        var onOff = remove ? 'off' : 'on';\n        var events = collected ? false : eventNames.split(_strSpace);\n        var i = 0;\n\n        if (collected) {\n          for (; i < eventNames[LEXICON.l]; i++) setupResponsiveEventListener(element, eventNames[i], listener[i], remove);\n        } else {\n          for (; i < events[LEXICON.l]; i++) {\n            if (_supportPassiveEvents) element[0][method](events[i], listener, {\n              passive: passive || false\n            });else element[onOff](events[i], listener);\n          }\n        }\n      }\n\n      function addDestroyEventListener(element, eventNames, listener, passive) {\n        setupResponsiveEventListener(element, eventNames, listener, false, passive);\n\n        _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));\n      } //==== Resize Observer ====//\n\n      /**\r\n       * Adds or removes a resize observer from the given element.\r\n       * @param targetElement The element to which the resize observer shall be added or removed.\r\n       * @param onElementResizedCallback The callback which is fired every time the resize observer registers a size change or false / undefined if the resizeObserver shall be removed.\r\n       */\n\n\n      function setupResizeObserver(targetElement, onElementResizedCallback) {\n        if (targetElement) {\n          var resizeObserver = COMPATIBILITY.rO();\n          var strAnimationStartEvent = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart';\n          var strChildNodes = 'childNodes';\n          var constScroll = 3333333;\n\n          var callback = function () {\n            targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);\n\n            onElementResizedCallback();\n          }; //add resize observer:\n\n\n          if (onElementResizedCallback) {\n            if (_supportResizeObserver) {\n              var element = targetElement.addClass('observed').append(generateDiv(_classNameResizeObserverElement)).contents()[0];\n              var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);\n              observer.observe(element);\n            } else {\n              if (_msieVersion > 9 || !_autoUpdateRecommended) {\n                targetElement.prepend(generateDiv(_classNameResizeObserverElement, generateDiv({\n                  c: _classNameResizeObserverItemElement,\n                  dir: 'ltr'\n                }, generateDiv(_classNameResizeObserverItemElement, generateDiv(_classNameResizeObserverItemFinalElement)) + generateDiv(_classNameResizeObserverItemElement, generateDiv({\n                  c: _classNameResizeObserverItemFinalElement,\n                  style: 'width: 200%; height: 200%'\n                })))));\n                var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];\n                var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);\n                var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);\n                var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);\n                var widthCache = observerElement[LEXICON.oW];\n                var heightCache = observerElement[LEXICON.oH];\n                var isDirty;\n                var rAFId;\n                var currWidth;\n                var currHeight;\n                var factor = 2;\n                var nativeScrollbarSize = globals.nativeScrollbarSize; //care don't make changes to this object!!!\n\n                var reset = function () {\n                  /*\r\n                   var sizeResetWidth = observerElement[LEXICON.oW] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;\r\n                   var sizeResetHeight = observerElement[LEXICON.oH] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;\r\n                   var expandChildCSS = {};\r\n                   expandChildCSS[_strWidth] = sizeResetWidth;\r\n                   expandChildCSS[_strHeight] = sizeResetHeight;\r\n                   expandElementChild.css(expandChildCSS);\r\n                       expandElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);\r\n                   shrinkElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);\r\n                   */\n                  expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);\n\n                  shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);\n                };\n\n                var onResized = function () {\n                  rAFId = 0;\n                  if (!isDirty) return;\n                  widthCache = currWidth;\n                  heightCache = currHeight;\n                  callback();\n                };\n\n                var onScroll = function (event) {\n                  currWidth = observerElement[LEXICON.oW];\n                  currHeight = observerElement[LEXICON.oH];\n                  isDirty = currWidth != widthCache || currHeight != heightCache;\n\n                  if (event && isDirty && !rAFId) {\n                    COMPATIBILITY.cAF()(rAFId);\n                    rAFId = COMPATIBILITY.rAF()(onResized);\n                  } else if (!event) onResized();\n\n                  reset();\n\n                  if (event) {\n                    COMPATIBILITY.prvD(event);\n                    COMPATIBILITY.stpP(event);\n                  }\n\n                  return false;\n                };\n\n                var expandChildCSS = {};\n                var observerElementCSS = {};\n                setTopRightBottomLeft(observerElementCSS, _strEmpty, [-((nativeScrollbarSize.y + 1) * factor), nativeScrollbarSize.x * -factor, nativeScrollbarSize.y * -factor, -((nativeScrollbarSize.x + 1) * factor)]);\n                FRAMEWORK(observerElement).css(observerElementCSS);\n                expandElement.on(_strScroll, onScroll);\n                shrinkElement.on(_strScroll, onScroll);\n                targetElement.on(strAnimationStartEvent, function () {\n                  onScroll(false);\n                }); //lets assume that the divs will never be that large and a constant value is enough\n\n                expandChildCSS[_strWidth] = constScroll;\n                expandChildCSS[_strHeight] = constScroll;\n                expandElementChild.css(expandChildCSS);\n                reset();\n              } else {\n                var attachEvent = _documentElementNative.attachEvent;\n                var isIE = _msieVersion !== undefined;\n\n                if (attachEvent) {\n                  targetElement.prepend(generateDiv(_classNameResizeObserverElement));\n                  findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent('onresize', callback);\n                } else {\n                  var obj = _documentElementNative.createElement(TYPES.o);\n\n                  obj.setAttribute(LEXICON.ti, '-1');\n                  obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);\n\n                  obj.onload = function () {\n                    var wnd = this.contentDocument.defaultView;\n                    wnd.addEventListener('resize', callback);\n                    wnd.document.documentElement.style.display = 'none';\n                  };\n\n                  obj.type = 'text/html';\n                  if (isIE) targetElement.prepend(obj);\n                  obj.data = 'about:blank';\n                  if (!isIE) targetElement.prepend(obj);\n                  targetElement.on(strAnimationStartEvent, callback);\n                }\n              }\n            }\n\n            if (targetElement[0] === _sizeObserverElementNative) {\n              var directionChanged = function () {\n                var dir = _hostElement.css('direction');\n\n                var css = {};\n                var scrollLeftValue = 0;\n                var result = false;\n\n                if (dir !== _cssDirectionDetectedCache) {\n                  if (dir === 'ltr') {\n                    css[_strLeft] = 0;\n                    css[_strRight] = _strAuto;\n                    scrollLeftValue = constScroll;\n                  } else {\n                    css[_strLeft] = _strAuto;\n                    css[_strRight] = 0;\n                    scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;\n                  } //execution order is important for IE!!!\n\n\n                  _sizeObserverElement.children().eq(0).css(css);\n\n                  _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);\n\n                  _cssDirectionDetectedCache = dir;\n                  result = true;\n                }\n\n                return result;\n              };\n\n              directionChanged();\n              addDestroyEventListener(targetElement, _strScroll, function (event) {\n                if (directionChanged()) update();\n                COMPATIBILITY.prvD(event);\n                COMPATIBILITY.stpP(event);\n                return false;\n              });\n            }\n          } //remove resize observer:\n          else {\n              if (_supportResizeObserver) {\n                var element = targetElement.contents()[0];\n                var resizeObserverObj = element[_strResizeObserverProperty];\n\n                if (resizeObserverObj) {\n                  resizeObserverObj.disconnect();\n                  delete element[_strResizeObserverProperty];\n                }\n              } else {\n                remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));\n              }\n            }\n        }\n      }\n      /**\r\n       * Freezes or unfreezes the given resize observer.\r\n       * @param targetElement The element to which the target resize observer is applied.\r\n       * @param freeze True if the resize observer shall be frozen, false otherwise.\r\n       \r\n      function freezeResizeObserver(targetElement, freeze) {\r\n          if (targetElement !== undefined) {\r\n              if(freeze) {\r\n                  if (_supportResizeObserver) {\r\n                      var element = targetElement.contents()[0];\r\n                      element[_strResizeObserverProperty].unobserve(element);\r\n                  }\r\n                  else {\r\n                      targetElement = targetElement.children(_strDot + _classNameResizeObserverElement).eq(0);\r\n                      var w = targetElement.css(_strWidth);\r\n                      var h = targetElement.css(_strHeight);\r\n                      var css = {};\r\n                      css[_strWidth] = w;\r\n                      css[_strHeight] = h;\r\n                      targetElement.css(css);\r\n                  }\r\n              }\r\n              else {\r\n                  if (_supportResizeObserver) {\r\n                      var element = targetElement.contents()[0];\r\n                      element[_strResizeObserverProperty].observe(element);\r\n                  }\r\n                  else {\r\n                      var css = { };\r\n                      css[_strHeight] = _strEmpty;\r\n                      css[_strWidth] = _strEmpty;\r\n                      targetElement.children(_strDot + _classNameResizeObserverElement).eq(0).css(css);\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      */\n      //==== Mutation Observers ====//\n\n      /**\r\n       * Creates MutationObservers for the host and content Element if they are supported.\r\n       */\n\n\n      function createMutationObservers() {\n        if (_supportMutationObserver) {\n          var mutationObserverContentLag = 11;\n          var mutationObserver = COMPATIBILITY.mO();\n          var contentLastUpdate = COMPATIBILITY.now();\n          var mutationTarget;\n          var mutationAttrName;\n          var mutationIsClass;\n          var oldMutationVal;\n          var newClassVal;\n          var hostClassNameRegex;\n          var contentTimeout;\n          var now;\n          var sizeAuto;\n          var action;\n\n          _mutationObserverHostCallback = function (mutations) {\n            var doUpdate = false;\n            var doUpdateForce = false;\n            var mutation;\n            var mutatedAttrs = [];\n\n            if (_initialized && !_sleeping) {\n              each(mutations, function () {\n                mutation = this;\n                mutationTarget = mutation.target;\n                mutationAttrName = mutation.attributeName;\n                mutationIsClass = mutationAttrName === LEXICON.c;\n                oldMutationVal = mutation.oldValue;\n                newClassVal = mutationTarget.className;\n\n                if (_domExists && mutationIsClass && !doUpdateForce) {\n                  // if old class value contains _classNameHostElementForeign and new class value doesn't\n                  if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {\n                    hostClassNameRegex = createHostClassNameRegExp(true);\n                    _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function (name) {\n                      return name.match(hostClassNameRegex);\n                    })).join(_strSpace);\n                    doUpdate = doUpdateForce = true;\n                  }\n                }\n\n                if (!doUpdate) {\n                  doUpdate = mutationIsClass ? hostClassNamesChanged(oldMutationVal, newClassVal) : mutationAttrName === LEXICON.s ? oldMutationVal !== mutationTarget[LEXICON.s].cssText : true;\n                }\n\n                mutatedAttrs.push(mutationAttrName);\n              });\n              updateViewportAttrsFromTarget(mutatedAttrs);\n              if (doUpdate) _base.update(doUpdateForce || _strAuto);\n            }\n\n            return doUpdate;\n          };\n\n          _mutationObserverContentCallback = function (mutations) {\n            var doUpdate = false;\n            var mutation;\n\n            if (_initialized && !_sleeping) {\n              each(mutations, function () {\n                mutation = this;\n                doUpdate = isUnknownMutation(mutation);\n                return !doUpdate;\n              });\n\n              if (doUpdate) {\n                now = COMPATIBILITY.now();\n                sizeAuto = _heightAutoCache || _widthAutoCache;\n\n                action = function () {\n                  if (!_destroyed) {\n                    contentLastUpdate = now; //if cols, rows or wrap attr was changed\n\n                    if (_isTextarea) textareaUpdate();\n                    if (sizeAuto) update();else _base.update(_strAuto);\n                  }\n                };\n\n                clearTimeout(contentTimeout);\n                if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto) action();else contentTimeout = setTimeout(action, mutationObserverContentLag);\n              }\n            }\n\n            return doUpdate;\n          };\n\n          _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);\n          _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);\n        }\n      }\n      /**\r\n       * Connects the MutationObservers if they are supported.\r\n       */\n\n\n      function connectMutationObservers() {\n        if (_supportMutationObserver && !_mutationObserversConnected) {\n          _mutationObserverHost.observe(_hostElementNative, {\n            attributes: true,\n            attributeOldValue: true,\n            attributeFilter: _mutationObserverAttrsHost\n          });\n\n          _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {\n            attributes: true,\n            attributeOldValue: true,\n            subtree: !_isTextarea,\n            childList: !_isTextarea,\n            characterData: !_isTextarea,\n            attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost\n          });\n\n          _mutationObserversConnected = true;\n        }\n      }\n      /**\r\n       * Disconnects the MutationObservers if they are supported.\r\n       */\n\n\n      function disconnectMutationObservers() {\n        if (_supportMutationObserver && _mutationObserversConnected) {\n          _mutationObserverHost.disconnect();\n\n          _mutationObserverContent.disconnect();\n\n          _mutationObserversConnected = false;\n        }\n      } //==== Events of elements ====//\n\n      /**\r\n       * This method gets called every time the host element gets resized. IMPORTANT: Padding changes are detected too!!\r\n       * It refreshes the hostResizedEventArgs and the hostSizeResizeCache.\r\n       * If there are any size changes, the update method gets called.\r\n       */\n\n\n      function hostOnResized() {\n        if (!_sleeping) {\n          var changed;\n          var hostSize = {\n            w: _sizeObserverElementNative[LEXICON.sW],\n            h: _sizeObserverElementNative[LEXICON.sH]\n          };\n          changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);\n          _hostElementSizeChangeDetectedCache = hostSize;\n          if (changed) update({\n            _hostSizeChanged: true\n          });\n        }\n      }\n      /**\r\n       * The mouse enter event of the host element. This event is only needed for the autoHide feature.\r\n       */\n\n\n      function hostOnMouseEnter() {\n        if (_scrollbarsAutoHideLeave) refreshScrollbarsAutoHide(true);\n      }\n      /**\r\n       * The mouse leave event of the host element. This event is only needed for the autoHide feature.\r\n       */\n\n\n      function hostOnMouseLeave() {\n        if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging)) refreshScrollbarsAutoHide(false);\n      }\n      /**\r\n       * The mouse move event of the host element. This event is only needed for the autoHide \"move\" feature.\r\n       */\n\n\n      function hostOnMouseMove() {\n        if (_scrollbarsAutoHideMove) {\n          refreshScrollbarsAutoHide(true);\n          clearTimeout(_scrollbarsAutoHideMoveTimeoutId);\n          _scrollbarsAutoHideMoveTimeoutId = setTimeout(function () {\n            if (_scrollbarsAutoHideMove && !_destroyed) refreshScrollbarsAutoHide(false);\n          }, 100);\n        }\n      }\n      /**\r\n       * Prevents text from deselection if attached to the document element on the mousedown event of a DOM element.\r\n       * @param event The select start event.\r\n       */\n\n\n      function documentOnSelectStart(event) {\n        COMPATIBILITY.prvD(event);\n        return false;\n      }\n      /**\t\r\n       * A callback which will be called after a element has loaded.\t\r\n       */\n\n\n      function updateOnLoadCallback(event) {\n        var elm = FRAMEWORK(event.target);\n        eachUpdateOnLoad(function (i, updateOnLoadSelector) {\n          if (elm.is(updateOnLoadSelector)) {\n            update({\n              _contentSizeChanged: true\n            });\n          }\n        });\n      }\n      /**\r\n      * Adds or removes mouse & touch events of the host element. (for handling auto-hiding of the scrollbars)\r\n      * @param destroy Indicates whether the events shall be added or removed.\r\n      */\n\n\n      function setupHostMouseTouchEvents(destroy) {\n        if (!destroy) setupHostMouseTouchEvents(true);\n        setupResponsiveEventListener(_hostElement, _strMouseTouchMoveEvent.split(_strSpace)[0], hostOnMouseMove, !_scrollbarsAutoHideMove || destroy, true);\n        setupResponsiveEventListener(_hostElement, [_strMouseEnter, _strMouseLeave], [hostOnMouseEnter, hostOnMouseLeave], !_scrollbarsAutoHideLeave || destroy, true); //if the plugin is initialized and the mouse is over the host element, make the scrollbars visible\n\n        if (!_initialized && !destroy) _hostElement.one('mouseover', hostOnMouseEnter);\n      } //==== Update Detection ====//\n\n      /**\r\n       * Measures the min width and min height of the body element and refreshes the related cache.\r\n       * @returns {boolean} True if the min width or min height has changed, false otherwise.\r\n       */\n\n\n      function bodyMinSizeChanged() {\n        var bodyMinSize = {};\n\n        if (_isBody && _contentArrangeElement) {\n          bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));\n          bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));\n          bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);\n          bodyMinSize.f = true; //flag for \"measured at least once\"\n        }\n\n        _bodyMinSizeCache = bodyMinSize;\n        return !!bodyMinSize.c;\n      }\n      /**\r\n       * Returns true if the class names really changed (new class without plugin host prefix)\r\n       * @param oldClassNames The old ClassName string or array.\r\n       * @param newClassNames The new ClassName string or array.\r\n       * @returns {boolean} True if the class names has really changed, false otherwise.\r\n       */\n\n\n      function hostClassNamesChanged(oldClassNames, newClassNames) {\n        var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];\n        var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];\n        var diff = getArrayDifferences(oldClasses, currClasses); // remove none theme from diff list to prevent update\n\n        var idx = inArray(_classNameThemeNone, diff);\n        var i;\n        var regex;\n        if (idx > -1) diff.splice(idx, 1);\n\n        if (diff[LEXICON.l] > 0) {\n          regex = createHostClassNameRegExp(true, true);\n\n          for (i = 0; i < diff.length; i++) {\n            if (!diff[i].match(regex)) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      }\n      /**\r\n       * Returns true if the given mutation is not from a from the plugin generated element. If the target element is a textarea the mutation is always unknown.\r\n       * @param mutation The mutation which shall be checked.\r\n       * @returns {boolean} True if the mutation is from a unknown element, false otherwise.\r\n       */\n\n\n      function isUnknownMutation(mutation) {\n        var attributeName = mutation.attributeName;\n        var mutationTarget = mutation.target;\n        var mutationType = mutation.type;\n        var strClosest = 'closest';\n        if (mutationTarget === _contentElementNative) return attributeName === null;\n\n        if (mutationType === 'attributes' && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {\n          //ignore className changes by the plugin\t\n          if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement)) return hostClassNamesChanged(mutation.oldValue, mutationTarget.className); //only do it of browser support it natively\t\n\n          if (typeof mutationTarget[strClosest] != TYPES.f) return true;\n          if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null) return false;\n        }\n\n        return true;\n      }\n      /**\r\n       * Returns true if the content size was changed since the last time this method was called.\r\n       * @returns {boolean} True if the content size was changed, false otherwise.\r\n       */\n\n\n      function updateAutoContentSizeChanged() {\n        if (_sleeping) return false;\n        var contentMeasureElement = getContentMeasureElement();\n        var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;\n        var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;\n        var css = {};\n        var float;\n        var bodyMinSizeC;\n        var changed;\n        var contentElementScrollSize;\n\n        if (setCSS) {\n          float = _contentElement.css(_strFloat);\n          css[_strFloat] = _isRTL ? _strRight : _strLeft;\n          css[_strWidth] = _strAuto;\n\n          _contentElement.css(css);\n        }\n\n        contentElementScrollSize = {\n          w: contentMeasureElement[LEXICON.sW] + textareaValueLength,\n          h: contentMeasureElement[LEXICON.sH] + textareaValueLength\n        };\n\n        if (setCSS) {\n          css[_strFloat] = float;\n          css[_strWidth] = _strHundredPercent;\n\n          _contentElement.css(css);\n        }\n\n        bodyMinSizeC = bodyMinSizeChanged();\n        changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);\n        _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;\n        return changed || bodyMinSizeC;\n      }\n      /**\r\n       * Returns true when a attribute which the MutationObserver would observe has changed.  \r\n       * @returns {boolean} True if one of the attributes which a MutationObserver would observe has changed, false or undefined otherwise.\r\n       */\n\n\n      function meaningfulAttrsChanged() {\n        if (_sleeping || _mutationObserversConnected) return;\n        var elem;\n        var curr;\n        var cache;\n        var changedAttrs = [];\n        var checks = [{\n          _elem: _hostElement,\n          _attrs: _mutationObserverAttrsHost.concat(':visible')\n        }, {\n          _elem: _isTextarea ? _targetElement : undefined,\n          _attrs: _mutationObserverAttrsTextarea\n        }];\n        each(checks, function (index, check) {\n          elem = check._elem;\n\n          if (elem) {\n            each(check._attrs, function (index, attr) {\n              curr = attr.charAt(0) === ':' ? elem.is(attr) : elem.attr(attr);\n              cache = _updateAutoCache[attr];\n\n              if (checkCache(curr, cache)) {\n                changedAttrs.push(attr);\n              }\n\n              _updateAutoCache[attr] = curr;\n            });\n          }\n        });\n        updateViewportAttrsFromTarget(changedAttrs);\n        return changedAttrs[LEXICON.l] > 0;\n      }\n      /**\r\n       * Checks is a CSS Property of a child element is affecting the scroll size of the content.\r\n       * @param propertyName The CSS property name.\r\n       * @returns {boolean} True if the property is affecting the content scroll size, false otherwise.\r\n       */\n\n\n      function isSizeAffectingCSSProperty(propertyName) {\n        if (!_initialized) return true;\n        var flexGrow = 'flex-grow';\n        var flexShrink = 'flex-shrink';\n        var flexBasis = 'flex-basis';\n        var affectingPropsX = [_strWidth, _strMinMinus + _strWidth, _strMaxMinus + _strWidth, _strMarginMinus + _strLeft, _strMarginMinus + _strRight, _strLeft, _strRight, 'font-weight', 'word-spacing', flexGrow, flexShrink, flexBasis];\n        var affectingPropsXContentBox = [_strPaddingMinus + _strLeft, _strPaddingMinus + _strRight, _strBorderMinus + _strLeft + _strWidth, _strBorderMinus + _strRight + _strWidth];\n        var affectingPropsY = [_strHeight, _strMinMinus + _strHeight, _strMaxMinus + _strHeight, _strMarginMinus + _strTop, _strMarginMinus + _strBottom, _strTop, _strBottom, 'line-height', flexGrow, flexShrink, flexBasis];\n        var affectingPropsYContentBox = [_strPaddingMinus + _strTop, _strPaddingMinus + _strBottom, _strBorderMinus + _strTop + _strWidth, _strBorderMinus + _strBottom + _strWidth];\n        var _strS = 's';\n        var _strVS = 'v-s';\n        var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;\n        var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;\n        var sizeIsAffected = false;\n\n        var checkPropertyName = function (arr, name) {\n          for (var i = 0; i < arr[LEXICON.l]; i++) {\n            if (arr[i] === name) return true;\n          }\n\n          return false;\n        };\n\n        if (checkY) {\n          sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);\n          if (!sizeIsAffected && !_isBorderBox) sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);\n        }\n\n        if (checkX && !sizeIsAffected) {\n          sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);\n          if (!sizeIsAffected && !_isBorderBox) sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);\n        }\n\n        return sizeIsAffected;\n      } //==== Update ====//\n\n      /**\r\n       * Sets the attribute values of the viewport element to the values from the target element.\r\n       * The value of a attribute is only set if the attribute is whitelisted.\r\n       * @attrs attrs The array of attributes which shall be set or undefined if all whitelisted shall be set.\r\n       */\n\n\n      function updateViewportAttrsFromTarget(attrs) {\n        attrs = attrs || _viewportAttrsFromTarget;\n        each(attrs, function (index, attr) {\n          if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {\n            var targetAttr = _targetElement.attr(attr);\n\n            if (type(targetAttr) == TYPES.s) {\n              _viewportElement.attr(attr, targetAttr);\n            } else {\n              _viewportElement.removeAttr(attr);\n            }\n          }\n        });\n      }\n      /**\r\n       * Updates the variables and size of the textarea element, and manages the scroll on new line or new character.\r\n       */\n\n\n      function textareaUpdate() {\n        if (!_sleeping) {\n          var wrapAttrOff = !_textareaAutoWrappingCache;\n          var minWidth = _viewportSize.w;\n          var minHeight = _viewportSize.h;\n          var css = {};\n          var doMeasure = _widthAutoCache || wrapAttrOff;\n          var origWidth;\n          var width;\n          var origHeight;\n          var height; //reset min size\n\n          css[_strMinMinus + _strWidth] = _strEmpty;\n          css[_strMinMinus + _strHeight] = _strEmpty; //set width auto\n\n          css[_strWidth] = _strAuto;\n\n          _targetElement.css(css); //measure width\n\n\n          origWidth = _targetElementNative[LEXICON.oW];\n          width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;\n          /*width += (_widthAutoCache ? _marginX + (!_isBorderBox ? wrapAttrOff ? 0 : _paddingX + _borderX : 0) : 0);*/\n          //set measured width\n\n          css[_strWidth] = _widthAutoCache ? _strAuto\n          /*width*/\n          : _strHundredPercent;\n          css[_strMinMinus + _strWidth] = _strHundredPercent; //set height auto\n\n          css[_strHeight] = _strAuto;\n\n          _targetElement.css(css); //measure height\n\n\n          origHeight = _targetElementNative[LEXICON.oH];\n          height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1); //append correct size values\n\n          css[_strWidth] = width;\n          css[_strHeight] = height;\n\n          _textareaCoverElement.css(css); //apply min width / min height to prevent textarea collapsing\n\n\n          css[_strMinMinus + _strWidth] = minWidth\n          /*+ (!_isBorderBox && _widthAutoCache ? _paddingX + _borderX : 0)*/\n          ;\n          css[_strMinMinus + _strHeight] = minHeight\n          /*+ (!_isBorderBox && _heightAutoCache ? _paddingY + _borderY : 0)*/\n          ;\n\n          _targetElement.css(css);\n\n          return {\n            _originalWidth: origWidth,\n            _originalHeight: origHeight,\n            _dynamicWidth: width,\n            _dynamicHeight: height\n          };\n        }\n      }\n      /**\r\n       * Updates the plugin and DOM to the current options.\r\n       * This method should only be called if a update is 100% required.\r\n       * @param updateHints A objects which contains hints for this update:\r\n       * {\r\n       *   _hostSizeChanged : boolean,\r\n       *   _contentSizeChanged : boolean,\r\n       *   _force : boolean,                             == preventSwallowing\r\n       *   _changedOptions : { },                        == preventSwallowing && preventSleep\r\n      *  }\r\n       */\n\n\n      function update(updateHints) {\n        clearTimeout(_swallowedUpdateTimeout);\n        updateHints = updateHints || {};\n        _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;\n        _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;\n        _swallowedUpdateHints._force |= updateHints._force;\n        var now = COMPATIBILITY.now();\n        var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;\n        var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;\n        var force = !!_swallowedUpdateHints._force;\n        var changedOptions = updateHints._changedOptions;\n        var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && now - _lastUpdateTime < _swallowUpdateLag && !_heightAutoCache && !_widthAutoCache;\n        var displayIsHidden;\n        if (swallow) _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag); //abort update due to:\n        //destroyed\n        //swallowing\n        //sleeping\n        //host is hidden or has false display\n\n        if (_destroyed || swallow || _sleeping && !changedOptions || _initialized && !force && (displayIsHidden = _hostElement.is(':hidden')) || _hostElement.css('display') === 'inline') return;\n        _lastUpdateTime = now;\n        _swallowedUpdateHints = {}; //if scrollbar styling is possible and native scrollbars aren't overlaid the scrollbar styling will be applied which hides the native scrollbars completely.\n\n        if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {\n          //native scrollbars are hidden, so change the values to zero\n          _nativeScrollbarSize.x = 0;\n          _nativeScrollbarSize.y = 0;\n        } else {\n          //refresh native scrollbar size (in case of zoom)\n          _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);\n        } // Scrollbar padding is needed for firefox, because firefox hides scrollbar automatically if the size of the div is too small.\n        // The calculation: [scrollbar size +3 *3]\n        // (+3 because of possible decoration e.g. borders, margins etc., but only if native scrollbar is NOT a overlaid scrollbar)\n        // (*3 because (1)increase / (2)decrease -button and (3)resize handle)\n\n\n        _nativeScrollbarMinSize = {\n          x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,\n          y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3\n        };\n        changedOptions = changedOptions || {}; //freezeResizeObserver(_sizeObserverElement, true);\n        //freezeResizeObserver(_sizeAutoObserverElement, true);\n\n        var checkCacheAutoForce = function () {\n          return checkCache.apply(this, [].slice.call(arguments).concat([force]));\n        }; //save current scroll offset\n\n\n        var currScroll = {\n          x: _viewportElement[_strScrollLeft](),\n          y: _viewportElement[_strScrollTop]()\n        };\n        var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;\n        var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea; //scrollbars visibility:\n\n        var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;\n        var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache); //scrollbars autoHide:\n\n        var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;\n        var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache); //scrollbars click scrolling\n\n        var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;\n        var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache); //scrollbars drag scrolling\n\n        var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;\n        var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache); //className\n\n        var className = _currentPreparedOptions.className;\n        var classNameChanged = checkCacheAutoForce(className, _classNameCache); //resize\n\n        var resize = _currentPreparedOptions.resize;\n        var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody; //body can't be resized since the window itself acts as resize possibility.\n        //paddingAbsolute\n\n        var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;\n        var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache); //clipAlways\n\n        var clipAlways = _currentPreparedOptions.clipAlways;\n        var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache); //sizeAutoCapable\n\n        var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody; //body can never be size auto, because it shall be always as big as the viewport.\n\n        var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache); //showNativeScrollbars\n\n        var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;\n        var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache); //autoUpdate\n\n        var autoUpdate = _currentPreparedOptions.autoUpdate;\n        var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache); //overflowBehavior\n\n        var overflowBehavior = _currentPreparedOptions.overflowBehavior;\n        var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force); //dynWidth:\n\n        var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;\n        var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth); //dynHeight:\n\n        var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;\n        var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight); //scrollbars visibility\n\n        _scrollbarsAutoHideNever = scrollbarsAutoHide === 'n';\n        _scrollbarsAutoHideScroll = scrollbarsAutoHide === 's';\n        _scrollbarsAutoHideMove = scrollbarsAutoHide === 'm';\n        _scrollbarsAutoHideLeave = scrollbarsAutoHide === 'l'; //scrollbars autoHideDelay\n\n        _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay; //old className\n\n        _oldClassName = _classNameCache; //resize\n\n        _resizeNone = resize === 'n';\n        _resizeBoth = resize === 'b';\n        _resizeHorizontal = resize === 'h';\n        _resizeVertical = resize === 'v'; //normalizeRTL\n\n        _normalizeRTLCache = _currentPreparedOptions.normalizeRTL; //ignore overlay scrollbar hiding\n\n        ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && _nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y; //refresh options cache\n\n        _scrollbarsVisibilityCache = scrollbarsVisibility;\n        _scrollbarsAutoHideCache = scrollbarsAutoHide;\n        _scrollbarsClickScrollingCache = scrollbarsClickScrolling;\n        _scrollbarsDragScrollingCache = scrollbarsDragScrolling;\n        _classNameCache = className;\n        _resizeCache = resize;\n        _paddingAbsoluteCache = paddingAbsolute;\n        _clipAlwaysCache = clipAlways;\n        _sizeAutoCapableCache = sizeAutoCapable;\n        _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;\n        _autoUpdateCache = autoUpdate;\n        _overflowBehaviorCache = extendDeep({}, overflowBehavior);\n        _textareaDynWidthCache = textareaDynWidth;\n        _textareaDynHeightCache = textareaDynHeight;\n        _hasOverflowCache = _hasOverflowCache || {\n          x: false,\n          y: false\n        }; //set correct class name to the host element\n\n        if (classNameChanged) {\n          removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);\n          addClass(_hostElement, className !== undefined && className !== null && className.length > 0 ? className : _classNameThemeNone);\n        } //set correct auto Update\n\n\n        if (autoUpdateChanged) {\n          if (autoUpdate === true || autoUpdate === null && _autoUpdateRecommended) {\n            disconnectMutationObservers();\n            autoUpdateLoop.add(_base);\n          } else {\n            autoUpdateLoop.remove(_base);\n            connectMutationObservers();\n          }\n        } //activate or deactivate size auto capability\n\n\n        if (sizeAutoCapableChanged) {\n          if (sizeAutoCapable) {\n            if (_contentGlueElement) {\n              _contentGlueElement.show();\n            } else {\n              _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));\n\n              _paddingElement.before(_contentGlueElement);\n            }\n\n            if (_sizeAutoObserverAdded) {\n              _sizeAutoObserverElement.show();\n            } else {\n              _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));\n              _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];\n\n              _contentGlueElement.before(_sizeAutoObserverElement);\n\n              var oldSize = {\n                w: -1,\n                h: -1\n              };\n              setupResizeObserver(_sizeAutoObserverElement, function () {\n                var newSize = {\n                  w: _sizeAutoObserverElementNative[LEXICON.oW],\n                  h: _sizeAutoObserverElementNative[LEXICON.oH]\n                };\n\n                if (checkCache(newSize, oldSize)) {\n                  if (_initialized && _heightAutoCache && newSize.h > 0 || _widthAutoCache && newSize.w > 0) {\n                    update();\n                  } else if (_initialized && !_heightAutoCache && newSize.h === 0 || !_widthAutoCache && newSize.w === 0) {\n                    update();\n                  }\n                }\n\n                oldSize = newSize;\n              });\n              _sizeAutoObserverAdded = true; //fix heightAuto detector bug if height is fixed but contentHeight is 0.\n              //the probability this bug will ever happen is very very low, thats why its ok if we use calc which isn't supported in IE8.\n\n              if (_cssCalc !== null) _sizeAutoObserverElement.css(_strHeight, _cssCalc + '(100% + 1px)');\n            }\n          } else {\n            if (_sizeAutoObserverAdded) _sizeAutoObserverElement.hide();\n            if (_contentGlueElement) _contentGlueElement.hide();\n          }\n        } //if force, update all resizeObservers too\n\n\n        if (force) {\n          _sizeObserverElement.find('*').trigger(_strScroll);\n\n          if (_sizeAutoObserverAdded) _sizeAutoObserverElement.find('*').trigger(_strScroll);\n        } //display hidden:\n\n\n        displayIsHidden = displayIsHidden === undefined ? _hostElement.is(':hidden') : displayIsHidden; //textarea AutoWrapping:\n\n        var textareaAutoWrapping = _isTextarea ? _targetElement.attr('wrap') !== 'off' : false;\n        var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache); //detect direction:\n\n        var cssDirection = _hostElement.css('direction');\n\n        var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache); //detect box-sizing:\n\n        var boxSizing = _hostElement.css('box-sizing');\n\n        var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache); //detect padding:\n\n        var padding = getTopRightBottomLeftHost(_strPaddingMinus); //width + height auto detecting var:\n\n        var sizeAutoObserverElementBCRect; //exception occurs in IE8 sometimes (unknown exception)\n\n        try {\n          sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;\n        } catch (ex) {\n          return;\n        }\n\n        _isRTL = cssDirection === 'rtl';\n        _isBorderBox = boxSizing === 'border-box';\n        var isRTLLeft = _isRTL ? _strLeft : _strRight;\n        var isRTLRight = _isRTL ? _strRight : _strLeft; //detect width auto:\n\n        var widthAutoResizeDetection = false;\n        var widthAutoObserverDetection = _sizeAutoObserverAdded && _hostElement.css(_strFloat) !== 'none'\n        /*|| _isTextarea */\n        ? MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0 && (!paddingAbsolute ? _hostElementNative[LEXICON.cW] - _paddingX > 0 : true) : false;\n\n        if (sizeAutoCapable && !widthAutoObserverDetection) {\n          var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];\n\n          var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);\n\n          _contentGlueElement.css(_strWidth, _strAuto);\n\n          var tmpNewHostWidth = _hostElementNative[LEXICON.oW];\n\n          _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);\n\n          widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;\n\n          if (!widthAutoResizeDetection) {\n            _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);\n\n            tmpNewHostWidth = _hostElementNative[LEXICON.oW];\n\n            _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);\n\n            widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;\n          }\n        }\n\n        var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;\n        var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);\n        var wasWidthAuto = !widthAuto && _widthAutoCache; //detect height auto:\n\n        var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0 :\n        /* && (!paddingAbsolute && (_msieVersion > 9 || !_msieVersion) ? true : true) */\n        false;\n        var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);\n        var wasHeightAuto = !heightAuto && _heightAutoCache; //detect border:\n        //we need the border only if border box and auto size\n\n        var updateBorderX = widthAuto && _isBorderBox || !_isBorderBox;\n        var updateBorderY = heightAuto && _isBorderBox || !_isBorderBox;\n        var border = getTopRightBottomLeftHost(_strBorderMinus, '-' + _strWidth, !updateBorderX, !updateBorderY); //detect margin:\n\n        var margin = getTopRightBottomLeftHost(_strMarginMinus); //vars to apply correct css\n\n        var contentElementCSS = {};\n        var contentGlueElementCSS = {}; //funcs\n\n        var getHostSize = function () {\n          //has to be clientSize because offsetSize respect borders\n          return {\n            w: _hostElementNative[LEXICON.cW],\n            h: _hostElementNative[LEXICON.cH]\n          };\n        };\n\n        var getViewportSize = function () {\n          //viewport size is padding container because it never has padding, margin and a border\n          //determine zoom rounding error -> sometimes scrollWidth/Height is smaller than clientWidth/Height\n          //if this happens add the difference to the viewportSize to compensate the rounding error\n          return {\n            w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),\n            h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])\n          };\n        }; //set info for padding\n\n\n        var paddingAbsoluteX = _paddingX = padding.l + padding.r;\n        var paddingAbsoluteY = _paddingY = padding.t + padding.b;\n        paddingAbsoluteX *= paddingAbsolute ? 1 : 0;\n        paddingAbsoluteY *= paddingAbsolute ? 1 : 0;\n        padding.c = checkCacheAutoForce(padding, _cssPaddingCache); //set info for border\n\n        _borderX = border.l + border.r;\n        _borderY = border.t + border.b;\n        border.c = checkCacheAutoForce(border, _cssBorderCache); //set info for margin\n\n        _marginX = margin.l + margin.r;\n        _marginY = margin.t + margin.b;\n        margin.c = checkCacheAutoForce(margin, _cssMarginCache); //refresh cache\n\n        _textareaAutoWrappingCache = textareaAutoWrapping;\n        _cssDirectionCache = cssDirection;\n        _cssBoxSizingCache = boxSizing;\n        _widthAutoCache = widthAuto;\n        _heightAutoCache = heightAuto;\n        _cssPaddingCache = padding;\n        _cssBorderCache = border;\n        _cssMarginCache = margin; //IEFix direction changed\n\n        if (cssDirectionChanged && _sizeAutoObserverAdded) _sizeAutoObserverElement.css(_strFloat, isRTLRight); //apply padding:\n\n        if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {\n          var paddingElementCSS = {};\n          var textareaCSS = {};\n          var paddingValues = [padding.t, padding.r, padding.b, padding.l];\n          setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);\n\n          if (paddingAbsolute) {\n            setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);\n            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);\n          } else {\n            setTopRightBottomLeft(paddingElementCSS, _strEmpty);\n            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);\n          }\n\n          _paddingElement.css(paddingElementCSS);\n\n          _targetElement.css(textareaCSS);\n        } //viewport size is padding container because it never has padding, margin and a border.\n\n\n        _viewportSize = getViewportSize(); //update Textarea\n\n        var textareaSize = _isTextarea ? textareaUpdate() : false;\n\n        var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);\n\n        var textareaDynOrigSize = _isTextarea && textareaSize ? {\n          w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,\n          h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight\n        } : {};\n        _textareaSizeCache = textareaSize; //fix height auto / width auto in cooperation with current padding & boxSizing behavior:\n\n        if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {\n          contentElementCSS[_strHeight] = _strAuto;\n        } else if (heightAutoChanged || paddingAbsoluteChanged) {\n          contentElementCSS[_strHeight] = _strHundredPercent;\n        }\n\n        if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {\n          contentElementCSS[_strWidth] = _strAuto;\n          contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent; //IE Fix\n        } else if (widthAutoChanged || paddingAbsoluteChanged) {\n          contentElementCSS[_strWidth] = _strHundredPercent;\n          contentElementCSS[_strFloat] = _strEmpty;\n          contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //IE Fix\n        }\n\n        if (widthAuto) {\n          //textareaDynOrigSize.w || _strAuto :: doesnt works because applied margin will shift width\n          contentGlueElementCSS[_strWidth] = _strAuto;\n          contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, 'max-content intrinsic') || _strAuto;\n          contentElementCSS[_strFloat] = isRTLRight;\n        } else {\n          contentGlueElementCSS[_strWidth] = _strEmpty;\n        }\n\n        if (heightAuto) {\n          //textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] :: use for anti scroll jumping\n          contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];\n        } else {\n          contentGlueElementCSS[_strHeight] = _strEmpty;\n        }\n\n        if (sizeAutoCapable) _contentGlueElement.css(contentGlueElementCSS);\n\n        _contentElement.css(contentElementCSS); //CHECKPOINT HERE ~\n\n\n        contentElementCSS = {};\n        contentGlueElementCSS = {}; //if [content(host) client / scroll size, or target element direction, or content(host) max-sizes] changed, or force is true\n\n        if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {\n          var strOverflow = 'overflow';\n          var strOverflowX = strOverflow + '-x';\n          var strOverflowY = strOverflow + '-y';\n          var strHidden = 'hidden';\n          var strVisible = 'visible'; //Reset the viewport (very important for natively overlaid scrollbars and zoom change\n          //don't change the overflow prop as it is very expensive and affects performance !A LOT!\n\n          if (!_nativeScrollbarStyling) {\n            var viewportElementResetCSS = {};\n            var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y : 0;\n            var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x : 0;\n            setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);\n\n            _viewportElement.css(viewportElementResetCSS);\n          } //measure several sizes:\n\n\n          var contentMeasureElement = getContentMeasureElement(); //in Firefox content element has to have overflow hidden, else element margins aren't calculated properly, this element prevents this bug, but only if scrollbars aren't overlaid\n\n          var contentSize = {\n            //use clientSize because natively overlaidScrollbars add borders\n            w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],\n            h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]\n          };\n          var scrollSize = {\n            w: contentMeasureElement[LEXICON.sW],\n            h: contentMeasureElement[LEXICON.sH]\n          }; //apply the correct viewport style and measure viewport size\n\n          if (!_nativeScrollbarStyling) {\n            viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;\n            viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;\n\n            _viewportElement.css(viewportElementResetCSS);\n          }\n\n          _viewportSize = getViewportSize(); //measure and correct several sizes\n\n          var hostSize = getHostSize();\n          var hostAbsoluteRectSize = {\n            w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),\n            h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)\n          };\n          var contentGlueSize = {\n            //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually\n            //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding\n            w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),\n            h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)\n          };\n          contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);\n          _contentGlueSizeCache = contentGlueSize; //apply correct contentGlue size\n\n          if (sizeAutoCapable) {\n            //size contentGlue correctly to make sure the element has correct size if the sizing switches to auto\n            if (contentGlueSize.c || heightAuto || widthAuto) {\n              contentGlueElementCSS[_strWidth] = contentGlueSize.w;\n              contentGlueElementCSS[_strHeight] = contentGlueSize.h; //textarea-sizes are already calculated correctly at this point\n\n              if (!_isTextarea) {\n                contentSize = {\n                  //use clientSize because natively overlaidScrollbars add borders\n                  w: contentMeasureElement[LEXICON.cW],\n                  h: contentMeasureElement[LEXICON.cH]\n                };\n              }\n            }\n\n            var textareaCoverCSS = {};\n\n            var setContentGlueElementCSSfunction = function (horizontal) {\n              var scrollbarVars = getScrollbarVars(horizontal);\n              var wh = scrollbarVars._w_h;\n              var strWH = scrollbarVars._width_height;\n              var autoSize = horizontal ? widthAuto : heightAuto;\n              var borderSize = horizontal ? _borderX : _borderY;\n              var paddingSize = horizontal ? _paddingX : _paddingY;\n              var marginSize = horizontal ? _marginX : _marginY;\n              var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize); //make contentGlue size -1 if element is not auto sized, to make sure that a resize event happens when the element shrinks\n\n              if (!autoSize || !autoSize && border.c) contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1; //if size is auto and host is smaller than size as min size, make content glue size -1 to make sure size changes will be detected (this is only needed if padding is 0)\n\n              if (autoSize && contentSize[wh] < viewportSize && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {\n                if (_isTextarea) textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;\n                contentGlueElementCSS[strWH] -= 1;\n              } //make sure content glue size is at least 1\n\n\n              if (contentSize[wh] > 0) contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);\n            };\n\n            setContentGlueElementCSSfunction(true);\n            setContentGlueElementCSSfunction(false);\n            if (_isTextarea) _textareaCoverElement.css(textareaCoverCSS);\n\n            _contentGlueElement.css(contentGlueElementCSS);\n          }\n\n          if (widthAuto) contentElementCSS[_strWidth] = _strHundredPercent;\n          if (widthAuto && !_isBorderBox && !_mutationObserversConnected) contentElementCSS[_strFloat] = 'none'; //apply and reset content style\n\n          _contentElement.css(contentElementCSS);\n\n          contentElementCSS = {}; //measure again, but this time all correct sizes:\n\n          var contentScrollSize = {\n            w: contentMeasureElement[LEXICON.sW],\n            h: contentMeasureElement[LEXICON.sH]\n          };\n          contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);\n          _contentScrollSizeCache = contentScrollSize; //refresh viewport size after correct measuring\n\n          _viewportSize = getViewportSize();\n          hostSize = getHostSize();\n          hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);\n          _hostSizeCache = hostSize;\n          var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);\n          var previousOverflowAmount = _overflowAmountCache;\n          var overflowBehaviorIsVS = {};\n          var overflowBehaviorIsVH = {};\n          var overflowBehaviorIsS = {};\n          var overflowAmount = {};\n          var hasOverflow = {};\n          var hideOverflow = {};\n          var canScroll = {};\n\n          var viewportRect = _paddingElementNative[LEXICON.bCR]();\n\n          var setOverflowVariables = function (horizontal) {\n            var scrollbarVars = getScrollbarVars(horizontal);\n            var scrollbarVarsInverted = getScrollbarVars(!horizontal);\n            var xyI = scrollbarVarsInverted._x_y;\n            var xy = scrollbarVars._x_y;\n            var wh = scrollbarVars._w_h;\n            var widthHeight = scrollbarVars._width_height;\n            var scrollMax = _strScroll + scrollbarVars._Left_Top + 'Max';\n            var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;\n            var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;\n            overflowBehaviorIsVS[xy] = overflowBehavior[xy] === 'v-s';\n            overflowBehaviorIsVH[xy] = overflowBehavior[xy] === 'v-h';\n            overflowBehaviorIsS[xy] = overflowBehavior[xy] === 's';\n            overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);\n            overflowAmount[xy] *= hideOverflowForceTextarea || checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1 ? 0 : 1;\n            hasOverflow[xy] = overflowAmount[xy] > 0; //hideOverflow:\n            //x || y : true === overflow is hidden by \"overflow: scroll\" OR \"overflow: hidden\"\n            //xs || ys : true === overflow is hidden by \"overflow: scroll\"\n\n            hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI] : hasOverflow[xy];\n            hideOverflow[xy + 's'] = hideOverflow[xy] ? overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy] : false;\n            canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + 's'];\n          };\n\n          setOverflowVariables(true);\n          setOverflowVariables(false);\n          overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);\n          _overflowAmountCache = overflowAmount;\n          hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);\n          _hasOverflowCache = hasOverflow;\n          hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);\n          _hideOverflowCache = hideOverflow; //if native scrollbar is overlay at x OR y axis, prepare DOM\n\n          if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {\n            var borderDesign = 'px solid transparent';\n            var contentArrangeElementCSS = {};\n            var arrangeContent = {};\n            var arrangeChanged = force;\n            var setContentElementCSS;\n\n            if (hasOverflow.x || hasOverflow.y) {\n              arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;\n              arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;\n              arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);\n              _arrangeContentSizeCache = arrangeContent;\n            }\n\n            if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {\n              contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;\n\n              setContentElementCSS = function (horizontal) {\n                var scrollbarVars = getScrollbarVars(horizontal);\n                var scrollbarVarsInverted = getScrollbarVars(!horizontal);\n                var xy = scrollbarVars._x_y;\n                var strDirection = horizontal ? _strBottom : isRTLLeft;\n                var invertedAutoSize = horizontal ? heightAuto : widthAuto;\n\n                if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + 's']) {\n                  contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy] : _strEmpty;\n                  contentElementCSS[_strBorderMinus + strDirection] = (horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding ? _overlayScrollbarDummySize[xy] + borderDesign : _strEmpty;\n                } else {\n                  arrangeContent[scrollbarVarsInverted._w_h] = contentElementCSS[_strMarginMinus + strDirection] = contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;\n                  arrangeChanged = true;\n                }\n              };\n\n              if (_nativeScrollbarStyling) {\n                addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding);\n              } else {\n                setContentElementCSS(true);\n                setContentElementCSS(false);\n              }\n            }\n\n            if (ignoreOverlayScrollbarHiding) {\n              arrangeContent.w = arrangeContent.h = _strEmpty;\n              arrangeChanged = true;\n            }\n\n            if (arrangeChanged && !_nativeScrollbarStyling) {\n              contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;\n              contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;\n\n              if (!_contentArrangeElement) {\n                _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));\n\n                _viewportElement.prepend(_contentArrangeElement);\n              }\n\n              _contentArrangeElement.css(contentArrangeElementCSS);\n            }\n\n            _contentElement.css(contentElementCSS);\n          }\n\n          var viewportElementCSS = {};\n          var paddingElementCSS = {};\n          var setViewportCSS;\n\n          if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {\n            viewportElementCSS[isRTLRight] = _strEmpty;\n\n            setViewportCSS = function (horizontal) {\n              var scrollbarVars = getScrollbarVars(horizontal);\n              var scrollbarVarsInverted = getScrollbarVars(!horizontal);\n              var xy = scrollbarVars._x_y;\n              var XY = scrollbarVars._X_Y;\n              var strDirection = horizontal ? _strBottom : isRTLLeft;\n\n              var reset = function () {\n                viewportElementCSS[strDirection] = _strEmpty;\n                _contentBorderSize[scrollbarVarsInverted._w_h] = 0;\n              };\n\n              if (hasOverflow[xy] && hideOverflow[xy + 's']) {\n                viewportElementCSS[strOverflow + XY] = _strScroll;\n\n                if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {\n                  reset();\n                } else {\n                  viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);\n                  _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;\n                }\n              } else {\n                viewportElementCSS[strOverflow + XY] = _strEmpty;\n                reset();\n              }\n            };\n\n            setViewportCSS(true);\n            setViewportCSS(false); // if the scroll container is too small and if there is any overflow with no overlay scrollbar (and scrollbar styling isn't possible), \n            // make viewport element greater in size (Firefox hide Scrollbars fix)\n            // because firefox starts hiding scrollbars on too small elements\n            // with this behavior the overflow calculation may be incorrect or the scrollbars would appear suddenly\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=292284\n\n            if (!_nativeScrollbarStyling && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y) && (hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x || hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y)) {\n              viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;\n              viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;\n              viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;\n              viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;\n            } else {\n              viewportElementCSS[_strPaddingMinus + _strTop] = viewportElementCSS[_strMarginMinus + _strTop] = viewportElementCSS[_strPaddingMinus + isRTLRight] = viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;\n            }\n\n            viewportElementCSS[_strPaddingMinus + isRTLLeft] = viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty; //if there is any overflow (x OR y axis) and this overflow shall be hidden, make overflow hidden, else overflow visible\n\n            if (hasOverflow.x && hideOverflow.x || hasOverflow.y && hideOverflow.y || hideOverflowForceTextarea) {\n              //only hide if is Textarea\n              if (_isTextarea && hideOverflowForceTextarea) {\n                paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = strHidden;\n              }\n            } else {\n              if (!clipAlways || overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y) {\n                //only un-hide if Textarea\n                if (_isTextarea) {\n                  paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = _strEmpty;\n                }\n\n                viewportElementCSS[strOverflowX] = viewportElementCSS[strOverflowY] = strVisible;\n              }\n            }\n\n            _paddingElement.css(paddingElementCSS);\n\n            _viewportElement.css(viewportElementCSS);\n\n            viewportElementCSS = {}; //force soft redraw in webkit because without the scrollbars will may appear because DOM wont be redrawn under special conditions\n\n            if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {\n              var elementStyle = _contentElementNative[LEXICON.s];\n              var dump;\n              elementStyle.webkitTransform = 'scale(1)';\n              elementStyle.display = 'run-in';\n              dump = _contentElementNative[LEXICON.oH];\n              elementStyle.display = _strEmpty; //|| dump; //use dump to prevent it from deletion if minify\n\n              elementStyle.webkitTransform = _strEmpty;\n            }\n            /*\r\n            //force hard redraw in webkit if native overlaid scrollbars shall appear\r\n            if (ignoreOverlayScrollbarHidingChanged && ignoreOverlayScrollbarHiding) {\r\n                _hostElement.hide();\r\n                var dump = _hostElementNative[LEXICON.oH];\r\n                _hostElement.show();\r\n            }\r\n            */\n\n          } //change to direction RTL and width auto Bugfix in Webkit\n          //without this fix, the DOM still thinks the scrollbar is LTR and thus the content is shifted to the left\n\n\n          contentElementCSS = {};\n\n          if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {\n            if (_isRTL && widthAuto) {\n              var floatTmp = _contentElement.css(_strFloat);\n\n              var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);\n\n              _contentElement.css(_strFloat, floatTmp);\n\n              var posLeftWithFloat = MATH.round(_contentElement.position().left);\n              if (posLeftWithoutFloat !== posLeftWithFloat) contentElementCSS[_strLeft] = posLeftWithoutFloat;\n            } else {\n              contentElementCSS[_strLeft] = _strEmpty;\n            }\n          }\n\n          _contentElement.css(contentElementCSS); //handle scroll position\n\n\n          if (_isTextarea && contentSizeChanged) {\n            var textareaInfo = getTextareaInfo();\n\n            if (textareaInfo) {\n              var textareaRowsChanged = _textareaInfoCache === undefined ? true : textareaInfo._rows !== _textareaInfoCache._rows;\n              var cursorRow = textareaInfo._cursorRow;\n              var cursorCol = textareaInfo._cursorColumn;\n              var widestRow = textareaInfo._widestRow;\n              var lastRow = textareaInfo._rows;\n              var lastCol = textareaInfo._columns;\n              var cursorPos = textareaInfo._cursorPosition;\n              var cursorMax = textareaInfo._cursorMax;\n              var cursorIsLastPosition = cursorPos >= cursorMax && _textareaHasFocus;\n              var textareaScrollAmount = {\n                x: !textareaAutoWrapping && cursorCol === lastCol && cursorRow === widestRow ? _overflowAmountCache.x : -1,\n                y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? currScroll.y === previousOverflowAmount.y : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1\n              };\n              currScroll.x = textareaScrollAmount.x > -1 ? _isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x : currScroll.x; //if inverted, scroll to 0 -> normalized this means to max scroll offset.\n\n              currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;\n            }\n\n            _textareaInfoCache = textareaInfo;\n          }\n\n          if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache) currScroll.x += _contentBorderSize.w || 0;\n          if (widthAuto) _hostElement[_strScrollLeft](0);\n          if (heightAuto) _hostElement[_strScrollTop](0);\n\n          _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y); //scrollbars management:\n\n\n          var scrollbarsVisibilityVisible = scrollbarsVisibility === 'v';\n          var scrollbarsVisibilityHidden = scrollbarsVisibility === 'h';\n          var scrollbarsVisibilityAuto = scrollbarsVisibility === 'a';\n\n          var refreshScrollbarsVisibility = function (showX, showY) {\n            showY = showY === undefined ? showX : showY;\n            refreshScrollbarAppearance(true, showX, canScroll.x);\n            refreshScrollbarAppearance(false, showY, canScroll.y);\n          }; //manage class name which indicates scrollable overflow\n\n\n          addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);\n          addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);\n          addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y); //add or remove rtl class name for styling purposes\n\n          if (cssDirectionChanged) {\n            addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);\n          } //manage the resize feature (CSS3 resize \"polyfill\" for this plugin)\n\n\n          if (_isBody) addClass(_hostElement, _classNameHostResizeDisabled);\n\n          if (resizeChanged) {\n            addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);\n            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);\n            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);\n            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);\n            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);\n          } //manage the scrollbars general visibility + the scrollbar interactivity (unusable class name)\n\n\n          if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {\n            if (ignoreOverlayScrollbarHiding) {\n              if (ignoreOverlayScrollbarHidingChanged) {\n                removeClass(_hostElement, _classNameHostScrolling);\n\n                if (ignoreOverlayScrollbarHiding) {\n                  refreshScrollbarsVisibility(false);\n                }\n              }\n            } else if (scrollbarsVisibilityAuto) {\n              refreshScrollbarsVisibility(canScroll.x, canScroll.y);\n            } else if (scrollbarsVisibilityVisible) {\n              refreshScrollbarsVisibility(true);\n            } else if (scrollbarsVisibilityHidden) {\n              refreshScrollbarsVisibility(false);\n            }\n          } //manage the scrollbars auto hide feature (auto hide them after specific actions)\n\n\n          if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {\n            setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);\n            refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);\n          } //manage scrollbars handle length & offset - don't remove!\n\n\n          if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {\n            refreshScrollbarHandleLength(true);\n            refreshScrollbarHandleOffset(true);\n            refreshScrollbarHandleLength(false);\n            refreshScrollbarHandleOffset(false);\n          } //manage interactivity\n\n\n          if (scrollbarsClickScrollingChanged) refreshScrollbarsInteractive(true, scrollbarsClickScrolling);\n          if (scrollbarsDragScrollingChanged) refreshScrollbarsInteractive(false, scrollbarsDragScrolling); //callbacks:\n\n          dispatchCallback('onDirectionChanged', {\n            isRTL: _isRTL,\n            dir: cssDirection\n          }, cssDirectionChanged);\n          dispatchCallback('onHostSizeChanged', {\n            width: _hostSizeCache.w,\n            height: _hostSizeCache.h\n          }, hostSizeChanged);\n          dispatchCallback('onContentSizeChanged', {\n            width: _contentScrollSizeCache.w,\n            height: _contentScrollSizeCache.h\n          }, contentSizeChanged);\n          dispatchCallback('onOverflowChanged', {\n            x: hasOverflow.x,\n            y: hasOverflow.y,\n            xScrollable: hideOverflow.xs,\n            yScrollable: hideOverflow.ys,\n            clipped: hideOverflow.x || hideOverflow.y\n          }, hasOverflow.c || hideOverflow.c);\n          dispatchCallback('onOverflowAmountChanged', {\n            x: overflowAmount.x,\n            y: overflowAmount.y\n          }, overflowAmount.c);\n        } //fix body min size\n\n\n        if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {\n          //its possible that no min size was measured until now, because the content arrange element was just added now, in this case, measure now the min size.\n          if (!_bodyMinSizeCache.f) bodyMinSizeChanged();\n          if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x) _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);\n          if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y) _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);\n          _bodyMinSizeCache.c = false;\n        }\n\n        if (_initialized && changedOptions.updateOnLoad) {\n          updateElementsOnLoad();\n        } //freezeResizeObserver(_sizeObserverElement, false);\n        //freezeResizeObserver(_sizeAutoObserverElement, false);\n\n\n        dispatchCallback('onUpdated', {\n          forced: force\n        });\n      }\n      /**\r\n       * Updates the found elements of which the load event shall be handled.\r\n       */\n\n\n      function updateElementsOnLoad() {\n        if (!_isTextarea) {\n          eachUpdateOnLoad(function (i, updateOnLoadSelector) {\n            _contentElement.find(updateOnLoadSelector).each(function (i, el) {\n              // if element doesn't have a updateOnLoadCallback applied\n              if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {\n                _updateOnLoadElms.push(el);\n\n                FRAMEWORK(el).off(_updateOnLoadEventName, updateOnLoadCallback).on(_updateOnLoadEventName, updateOnLoadCallback);\n              }\n            });\n          });\n        }\n      } //==== Options ====//\n\n      /**\r\n       * Sets new options but doesn't call the update method.\r\n       * @param newOptions The object which contains the new options.\r\n       * @returns {*} A object which contains the changed options.\r\n       */\n\n\n      function setOptions(newOptions) {\n        var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions);\n\n        _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);\n        _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);\n        return validatedOpts._prepared;\n      } //==== Structure ====//\n\n      /**\r\n       * Builds or destroys the wrapper and helper DOM elements.\r\n       * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n       */\n\n      /**\r\n       * Builds or destroys the wrapper and helper DOM elements.\r\n       * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n       */\n\n\n      function setupStructureDOM(destroy) {\n        var strParent = 'parent';\n        var classNameResizeObserverHost = 'os-resize-observer-host';\n        var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;\n        var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;\n        var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;\n        var adoptAttrsMap = {};\n\n        var applyAdoptedAttrs = function () {\n          var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;\n          each(adoptAttrsMap, function (key, value) {\n            if (type(value) == TYPES.s) {\n              if (key == LEXICON.c) applyAdoptedAttrsElm.addClass(value);else applyAdoptedAttrsElm.attr(key, value);\n            }\n          });\n        };\n\n        var hostElementClassNames = [_classNameHostElement, _classNameHostElementForeign, _classNameHostTextareaElement, _classNameHostResizeDisabled, _classNameHostRTL, _classNameHostScrollbarHorizontalHidden, _classNameHostScrollbarVerticalHidden, _classNameHostTransition, _classNameHostScrolling, _classNameHostOverflow, _classNameHostOverflowX, _classNameHostOverflowY, _classNameThemeNone, _classNameTextareaElement, _classNameTextInherit, _classNameCache].join(_strSpace);\n        var hostElementCSS = {}; //get host element as first element, because that's the most upper element and required for the other elements\n\n        _hostElement = _hostElement || (_isTextarea ? _domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement)) : _targetElement);\n        _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);\n        _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);\n        _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);\n        _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);\n        _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined); //add this class to workaround class changing issues with UI frameworks especially Vue\n\n        if (_domExists) addClass(_hostElement, _classNameHostElementForeign); //on destroy, remove all generated class names from the host element before collecting the adopted attributes \n        //to prevent adopting generated class names\n\n        if (destroy) removeClass(_hostElement, hostElementClassNames); //collect all adopted attributes\n\n        adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;\n\n        if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {\n          each(adoptAttrs, function (i, v) {\n            if (type(v) == TYPES.s) {\n              adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);\n            }\n          });\n        }\n\n        if (!destroy) {\n          if (_isTextarea) {\n            if (!_currentPreparedOptions.sizeAutoCapable) {\n              hostElementCSS[_strWidth] = _targetElement.css(_strWidth);\n              hostElementCSS[_strHeight] = _targetElement.css(_strHeight);\n            }\n\n            if (!_domExists) _targetElement.addClass(_classNameTextInherit).wrap(_hostElement); //jQuery clones elements in wrap functions, so we have to select them again\n\n            _hostElement = _targetElement[strParent]().css(hostElementCSS);\n          }\n\n          if (!_domExists) {\n            //add the correct class to the target element\n            addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement); //wrap the content into the generated elements to create the required DOM\n\n            _hostElement.wrapInner(_contentElement).wrapInner(_viewportElement).wrapInner(_paddingElement).prepend(_sizeObserverElement); //jQuery clones elements in wrap functions, so we have to select them again\n\n\n            _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);\n            _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);\n            _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);\n\n            if (_isTextarea) {\n              _contentElement.prepend(_textareaCoverElement);\n\n              applyAdoptedAttrs();\n            }\n          }\n\n          if (_nativeScrollbarStyling) addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);\n          if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y) addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);\n          if (_isBody) addClass(_htmlElement, _classNameHTMLElement);\n          _sizeObserverElementNative = _sizeObserverElement[0];\n          _hostElementNative = _hostElement[0];\n          _paddingElementNative = _paddingElement[0];\n          _viewportElementNative = _viewportElement[0];\n          _contentElementNative = _contentElement[0];\n          updateViewportAttrsFromTarget();\n        } else {\n          if (_domExists && _initialized) {\n            //clear size observer\n            _sizeObserverElement.children().remove(); //remove the style property and classes from already generated elements\n\n\n            each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function (i, elm) {\n              if (elm) {\n                removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);\n              }\n            }); //add classes to the host element which was removed previously to match the expected DOM\n\n            addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);\n          } else {\n            //remove size observer\n            remove(_sizeObserverElement); //unwrap the content to restore DOM\n\n            _contentElement.contents().unwrap().unwrap().unwrap();\n\n            if (_isTextarea) {\n              _targetElement.unwrap();\n\n              remove(_hostElement);\n              remove(_textareaCoverElement);\n              applyAdoptedAttrs();\n            }\n          }\n\n          if (_isTextarea) _targetElement.removeAttr(LEXICON.s);\n          if (_isBody) removeClass(_htmlElement, _classNameHTMLElement);\n        }\n      }\n      /**\r\n       * Adds or removes all wrapper elements interactivity events.\r\n       * @param destroy Indicates whether the Events shall be added or removed.\r\n       */\n\n\n      function setupStructureEvents() {\n        var textareaKeyDownRestrictedKeyCodes = [112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123, //F1 to F12\n        33, 34, //page up, page down\n        37, 38, 39, 40, //left, up, right, down arrows\n        16, 17, 18, 19, 20, 144 //Shift, Ctrl, Alt, Pause, CapsLock, NumLock\n        ];\n        var textareaKeyDownKeyCodesList = [];\n        var textareaUpdateIntervalID;\n        var scrollStopTimeoutId;\n        var scrollStopDelay = 175;\n        var strFocus = 'focus';\n\n        function updateTextarea(doClearInterval) {\n          textareaUpdate();\n\n          _base.update(_strAuto);\n\n          if (doClearInterval && _autoUpdateRecommended) clearInterval(textareaUpdateIntervalID);\n        }\n\n        function textareaOnScroll(event) {\n          _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);\n\n          _targetElement[_strScrollTop](0);\n\n          COMPATIBILITY.prvD(event);\n          COMPATIBILITY.stpP(event);\n          return false;\n        }\n\n        function textareaOnDrop(event) {\n          setTimeout(function () {\n            if (!_destroyed) updateTextarea();\n          }, 50);\n        }\n\n        function textareaOnFocus() {\n          _textareaHasFocus = true;\n          addClass(_hostElement, strFocus);\n        }\n\n        function textareaOnFocusout() {\n          _textareaHasFocus = false;\n          textareaKeyDownKeyCodesList = [];\n          removeClass(_hostElement, strFocus);\n          updateTextarea(true);\n        }\n\n        function textareaOnKeyDown(event) {\n          var keyCode = event.keyCode;\n\n          if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {\n            if (!textareaKeyDownKeyCodesList[LEXICON.l]) {\n              updateTextarea();\n              textareaUpdateIntervalID = setInterval(updateTextarea, 1000 / 60);\n            }\n\n            if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0) textareaKeyDownKeyCodesList.push(keyCode);\n          }\n        }\n\n        function textareaOnKeyUp(event) {\n          var keyCode = event.keyCode;\n          var index = inArray(keyCode, textareaKeyDownKeyCodesList);\n\n          if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {\n            if (index > -1) textareaKeyDownKeyCodesList.splice(index, 1);\n            if (!textareaKeyDownKeyCodesList[LEXICON.l]) updateTextarea(true);\n          }\n        }\n\n        function contentOnTransitionEnd(event) {\n          if (_autoUpdateCache === true) return;\n          event = event.originalEvent || event;\n          if (isSizeAffectingCSSProperty(event.propertyName)) _base.update(_strAuto);\n        }\n\n        function viewportOnScroll(event) {\n          if (!_sleeping) {\n            if (scrollStopTimeoutId !== undefined) clearTimeout(scrollStopTimeoutId);else {\n              if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(true);\n              if (!nativeOverlayScrollbarsAreActive()) addClass(_hostElement, _classNameHostScrolling);\n              dispatchCallback('onScrollStart', event);\n            } //if a scrollbars handle gets dragged, the mousemove event is responsible for refreshing the handle offset\n            //because if CSS scroll-snap is used, the handle offset gets only refreshed on every snap point\n            //this looks laggy & clunky, it looks much better if the offset refreshes with the mousemove\n\n            if (!_scrollbarsHandlesDefineScrollPos) {\n              refreshScrollbarHandleOffset(true);\n              refreshScrollbarHandleOffset(false);\n            }\n\n            dispatchCallback('onScroll', event);\n            scrollStopTimeoutId = setTimeout(function () {\n              if (!_destroyed) {\n                //OnScrollStop:\n                clearTimeout(scrollStopTimeoutId);\n                scrollStopTimeoutId = undefined;\n                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(false);\n                if (!nativeOverlayScrollbarsAreActive()) removeClass(_hostElement, _classNameHostScrolling);\n                dispatchCallback('onScrollStop', event);\n              }\n            }, scrollStopDelay);\n          }\n        }\n\n        if (_isTextarea) {\n          if (_msieVersion > 9 || !_autoUpdateRecommended) {\n            addDestroyEventListener(_targetElement, 'input', updateTextarea);\n          } else {\n            addDestroyEventListener(_targetElement, [_strKeyDownEvent, _strKeyUpEvent], [textareaOnKeyDown, textareaOnKeyUp]);\n          }\n\n          addDestroyEventListener(_targetElement, [_strScroll, 'drop', strFocus, strFocus + 'out'], [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]);\n        } else {\n          addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);\n        }\n\n        addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);\n      } //==== Scrollbars ====//\n\n      /**\r\n       * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)\r\n       * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n       */\n\n\n      function setupScrollbarsDOM(destroy) {\n        var selectOrGenerateScrollbarDOM = function (isHorizontal) {\n          var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;\n          var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);\n          var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);\n          var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);\n\n          if (!_domExists && !destroy) {\n            scrollbar.append(track);\n            track.append(handle);\n          }\n\n          return {\n            _scrollbar: scrollbar,\n            _track: track,\n            _handle: handle\n          };\n        };\n\n        function resetScrollbarDOM(isHorizontal) {\n          var scrollbarVars = getScrollbarVars(isHorizontal);\n          var scrollbar = scrollbarVars._scrollbar;\n          var track = scrollbarVars._track;\n          var handle = scrollbarVars._handle;\n\n          if (_domExists && _initialized) {\n            each([scrollbar, track, handle], function (i, elm) {\n              removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);\n            });\n          } else {\n            remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);\n          }\n        }\n\n        var horizontalElements;\n        var verticalElements;\n\n        if (!destroy) {\n          horizontalElements = selectOrGenerateScrollbarDOM(true);\n          verticalElements = selectOrGenerateScrollbarDOM();\n          _scrollbarHorizontalElement = horizontalElements._scrollbar;\n          _scrollbarHorizontalTrackElement = horizontalElements._track;\n          _scrollbarHorizontalHandleElement = horizontalElements._handle;\n          _scrollbarVerticalElement = verticalElements._scrollbar;\n          _scrollbarVerticalTrackElement = verticalElements._track;\n          _scrollbarVerticalHandleElement = verticalElements._handle;\n\n          if (!_domExists) {\n            _paddingElement.after(_scrollbarVerticalElement);\n\n            _paddingElement.after(_scrollbarHorizontalElement);\n          }\n        } else {\n          resetScrollbarDOM(true);\n          resetScrollbarDOM();\n        }\n      }\n      /**\r\n       * Initializes all scrollbar interactivity events. (track and handle dragging, clicking, scrolling)\r\n       * @param isHorizontal True if the target scrollbar is the horizontal scrollbar, false if the target scrollbar is the vertical scrollbar.\r\n       */\n\n\n      function setupScrollbarEvents(isHorizontal) {\n        var scrollbarVars = getScrollbarVars(isHorizontal);\n        var scrollbarVarsInfo = scrollbarVars._info;\n        var insideIFrame = _windowElementNative.top !== _windowElementNative;\n        var xy = scrollbarVars._x_y;\n        var XY = scrollbarVars._X_Y;\n        var scroll = _strScroll + scrollbarVars._Left_Top;\n        var strActive = 'active';\n        var strSnapHandle = 'snapHandle';\n        var scrollDurationFactor = 1;\n        var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl\n\n        var trackTimeout;\n        var mouseDownScroll;\n        var mouseDownOffset;\n        var mouseDownInvertedScale;\n\n        function getPointerPosition(event) {\n          return _msieVersion && insideIFrame ? event['screen' + XY] : COMPATIBILITY.page(event)[xy]; //use screen coordinates in EDGE & IE because the page values are incorrect in frames.\n        }\n\n        function getPreparedScrollbarsOption(name) {\n          return _currentPreparedOptions.scrollbars[name];\n        }\n\n        function increaseTrackScrollAmount() {\n          scrollDurationFactor = 0.5;\n        }\n\n        function decreaseTrackScrollAmount() {\n          scrollDurationFactor = 1;\n        }\n\n        function documentKeyDown(event) {\n          if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1) increaseTrackScrollAmount();\n        }\n\n        function documentKeyUp(event) {\n          if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1) decreaseTrackScrollAmount();\n        }\n\n        function onMouseTouchDownContinue(event) {\n          var originalEvent = event.originalEvent || event;\n          var isTouchEvent = originalEvent.touches !== undefined;\n          return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || isTouchEvent && !getPreparedScrollbarsOption('touchSupport') ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;\n        }\n\n        function documentDragMove(event) {\n          if (onMouseTouchDownContinue(event)) {\n            var trackLength = scrollbarVarsInfo._trackLength;\n            var handleLength = scrollbarVarsInfo._handleLength;\n            var scrollRange = scrollbarVarsInfo._maxScroll;\n            var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;\n            var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);\n            var scrollDelta = scrollRange * scrollDeltaPercent;\n            scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;\n            if (_isRTL && isHorizontal && !_rtlScrollBehavior.i) scrollDelta *= -1;\n\n            _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));\n\n            if (_scrollbarsHandlesDefineScrollPos) refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);\n            if (!_supportPassiveEvents) COMPATIBILITY.prvD(event);\n          } else documentMouseTouchUp(event);\n        }\n\n        function documentMouseTouchUp(event) {\n          event = event || event.originalEvent;\n          setupResponsiveEventListener(_documentElement, [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent], [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart], true);\n          if (_scrollbarsHandlesDefineScrollPos) refreshScrollbarHandleOffset(isHorizontal, true);\n          _scrollbarsHandlesDefineScrollPos = false;\n          removeClass(_bodyElement, _classNameDragging);\n          removeClass(scrollbarVars._handle, strActive);\n          removeClass(scrollbarVars._track, strActive);\n          removeClass(scrollbarVars._scrollbar, strActive);\n          mouseDownScroll = undefined;\n          mouseDownOffset = undefined;\n          mouseDownInvertedScale = 1;\n          decreaseTrackScrollAmount();\n\n          if (trackTimeout !== undefined) {\n            _base.scrollStop();\n\n            clearTimeout(trackTimeout);\n            trackTimeout = undefined;\n          }\n\n          if (event) {\n            var rect = _hostElementNative[LEXICON.bCR]();\n\n            var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom; //if mouse is outside host element\n\n            if (!mouseInsideHost) hostOnMouseLeave();\n            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(false);\n          }\n        }\n\n        function onHandleMouseTouchDown(event) {\n          if (onMouseTouchDownContinue(event)) onHandleMouseTouchDownAction(event);\n        }\n\n        function onHandleMouseTouchDownAction(event) {\n          mouseDownScroll = _viewportElement[scroll]();\n          mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;\n          if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL) mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;\n          mouseDownInvertedScale = getHostElementInvertedScale()[xy];\n          mouseDownOffset = getPointerPosition(event);\n          _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);\n          addClass(_bodyElement, _classNameDragging);\n          addClass(scrollbarVars._handle, strActive);\n          addClass(scrollbarVars._scrollbar, strActive);\n          setupResponsiveEventListener(_documentElement, [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent], [documentDragMove, documentMouseTouchUp, documentOnSelectStart]);\n          if (_msieVersion || !_documentMixed) COMPATIBILITY.prvD(event);\n          COMPATIBILITY.stpP(event);\n        }\n\n        function onTrackMouseTouchDown(event) {\n          if (onMouseTouchDownContinue(event)) {\n            var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h]);\n\n            var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];\n\n            var ctrlKey = event.ctrlKey;\n            var instantScroll = event.shiftKey;\n            var instantScrollTransition = instantScroll && ctrlKey;\n            var isFirstIteration = true;\n            var easing = 'linear';\n            var decreaseScroll;\n            var finishedCondition;\n\n            var scrollActionFinsished = function (transition) {\n              if (_scrollbarsHandlesDefineScrollPos) refreshScrollbarHandleOffset(isHorizontal, transition);\n            };\n\n            var scrollActionInstantFinished = function () {\n              scrollActionFinsished();\n              onHandleMouseTouchDownAction(event);\n            };\n\n            var scrollAction = function () {\n              if (!_destroyed) {\n                var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;\n                var handleOffset = scrollbarVarsInfo._handleOffset;\n                var trackLength = scrollbarVarsInfo._trackLength;\n                var handleLength = scrollbarVarsInfo._handleLength;\n                var scrollRange = scrollbarVarsInfo._maxScroll;\n                var currScroll = scrollbarVarsInfo._currentScroll;\n                var scrollDuration = 270 * scrollDurationFactor;\n                var timeoutDelay = isFirstIteration ? MATH.max(400, scrollDuration) : scrollDuration;\n                var instantScrollPosition = scrollRange * ((mouseOffset - handleLength / 2) / (trackLength - handleLength)); // 100% * positionPercent\n\n                var rtlIsNormal = _isRTL && isHorizontal && (!_rtlScrollBehavior.i && !_rtlScrollBehavior.n || _normalizeRTLCache);\n                var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;\n                var scrollObj = {};\n                var animationObj = {\n                  easing: easing,\n                  step: function (now) {\n                    if (_scrollbarsHandlesDefineScrollPos) {\n                      _viewportElement[scroll](now); //https://github.com/jquery/jquery/issues/4340\n\n\n                      refreshScrollbarHandleOffset(isHorizontal, now);\n                    }\n                  }\n                };\n                instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;\n                instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition; //_base.scrollStop();\n\n                if (instantScroll) {\n                  _viewportElement[scroll](instantScrollPosition); //scroll instantly to new position\n\n\n                  if (instantScrollTransition) {\n                    //get the scroll position after instant scroll (in case CSS Snap Points are used) to get the correct snapped scroll position\n                    //and the animation stops at the correct point\n                    instantScrollPosition = _viewportElement[scroll](); //scroll back to the position before instant scrolling so animation can be performed\n\n                    _viewportElement[scroll](currScroll);\n\n                    instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition;\n                    instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;\n                    scrollObj[xy] = instantScrollPosition;\n\n                    _base.scroll(scrollObj, extendDeep(animationObj, {\n                      duration: 130,\n                      complete: scrollActionInstantFinished\n                    }));\n                  } else scrollActionInstantFinished();\n                } else {\n                  decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;\n                  finishedCondition = rtlIsNormal ? decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset : decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset;\n\n                  if (finishedCondition) {\n                    clearTimeout(trackTimeout);\n\n                    _base.scrollStop();\n\n                    trackTimeout = undefined;\n                    scrollActionFinsished(true);\n                  } else {\n                    trackTimeout = setTimeout(scrollAction, timeoutDelay);\n                    scrollObj[xy] = (decreaseScroll ? '-=' : '+=') + scrollDistance;\n\n                    _base.scroll(scrollObj, extendDeep(animationObj, {\n                      duration: scrollDuration\n                    }));\n                  }\n\n                  isFirstIteration = false;\n                }\n              }\n            };\n\n            if (ctrlKey) increaseTrackScrollAmount();\n            mouseDownInvertedScale = getHostElementInvertedScale()[xy];\n            mouseDownOffset = COMPATIBILITY.page(event)[xy];\n            _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);\n            addClass(_bodyElement, _classNameDragging);\n            addClass(scrollbarVars._track, strActive);\n            addClass(scrollbarVars._scrollbar, strActive);\n            setupResponsiveEventListener(_documentElement, [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent], [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);\n            scrollAction();\n            COMPATIBILITY.prvD(event);\n            COMPATIBILITY.stpP(event);\n          }\n        }\n\n        function onTrackMouseTouchEnter(event) {\n          //make sure both scrollbars will stay visible if one scrollbar is hovered if autoHide is \"scroll\" or \"move\".\n          _scrollbarsHandleHovered = true;\n          if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(true);\n        }\n\n        function onTrackMouseTouchLeave(event) {\n          _scrollbarsHandleHovered = false;\n          if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(false);\n        }\n\n        function onScrollbarMouseTouchDown(event) {\n          COMPATIBILITY.stpP(event);\n        }\n\n        addDestroyEventListener(scrollbarVars._handle, _strMouseTouchDownEvent, onHandleMouseTouchDown);\n        addDestroyEventListener(scrollbarVars._track, [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave], [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]);\n        addDestroyEventListener(scrollbarVars._scrollbar, _strMouseTouchDownEvent, onScrollbarMouseTouchDown);\n\n        if (_supportTransition) {\n          addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function (event) {\n            if (event.target !== scrollbarVars._scrollbar[0]) return;\n            refreshScrollbarHandleLength(isHorizontal);\n            refreshScrollbarHandleOffset(isHorizontal);\n          });\n        }\n      }\n      /**\r\n       * Shows or hides the given scrollbar and applied a class name which indicates if the scrollbar is scrollable or not.\r\n       * @param isHorizontal True if the horizontal scrollbar is the target, false if the vertical scrollbar is the target.\r\n       * @param shallBeVisible True if the scrollbar shall be shown, false if hidden.\r\n       * @param canScroll True if the scrollbar is scrollable, false otherwise.\r\n       */\n\n\n      function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {\n        var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;\n        var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;\n        addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);\n        addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);\n      }\n      /**\r\n       * Autoshows / autohides both scrollbars with.\r\n       * @param shallBeVisible True if the scrollbars shall be autoshown (only the case if they are hidden by a autohide), false if the shall be auto hidden.\r\n       * @param delayfree True if the scrollbars shall be hidden without a delay, false or undefined otherwise.\r\n       */\n\n\n      function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {\n        clearTimeout(_scrollbarsAutoHideTimeoutId);\n\n        if (shallBeVisible) {\n          //if(_hasOverflowCache.x && _hideOverflowCache.xs)\n          removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden); //if(_hasOverflowCache.y && _hideOverflowCache.ys)\n\n          removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);\n        } else {\n          var anyActive;\n          var strActive = 'active';\n\n          var hide = function () {\n            if (!_scrollbarsHandleHovered && !_destroyed) {\n              anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);\n              if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave)) addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);\n              if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave)) addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);\n            }\n          };\n\n          if (_scrollbarsAutoHideDelay > 0 && delayfree !== true) _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);else hide();\n        }\n      }\n      /**\r\n       * Refreshes the handle length of the given scrollbar.\r\n       * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.\r\n       */\n\n\n      function refreshScrollbarHandleLength(isHorizontal) {\n        var handleCSS = {};\n        var scrollbarVars = getScrollbarVars(isHorizontal);\n        var scrollbarVarsInfo = scrollbarVars._info;\n        var digit = 1000000; //get and apply intended handle length\n\n        var handleRatio = MATH.min(1, (_hostSizeCache[scrollbarVars._w_h] - (_paddingAbsoluteCache ? isHorizontal ? _paddingX : _paddingY : 0)) / _contentScrollSizeCache[scrollbarVars._w_h]);\n        handleCSS[scrollbarVars._width_height] = MATH.floor(handleRatio * 100 * digit) / digit + '%'; //the last * digit / digit is for flooring to the 4th digit\n\n        if (!nativeOverlayScrollbarsAreActive()) scrollbarVars._handle.css(handleCSS); //measure the handle length to respect min & max length\n\n        scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]['offset' + scrollbarVars._Width_Height];\n        scrollbarVarsInfo._handleLengthRatio = handleRatio;\n      }\n      /**\r\n       * Refreshes the handle offset of the given scrollbar.\r\n       * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.\r\n       * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)\r\n       */\n\n\n      function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {\n        var transition = type(scrollOrTransition) == TYPES.b;\n        var transitionDuration = 250;\n        var isRTLisHorizontal = _isRTL && isHorizontal;\n        var scrollbarVars = getScrollbarVars(isHorizontal);\n        var scrollbarVarsInfo = scrollbarVars._info;\n        var strTranslateBrace = 'translate(';\n\n        var strTransform = VENDORS._cssProperty('transform');\n\n        var strTransition = VENDORS._cssProperty('transition');\n\n        var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();\n        var currentScroll = scrollOrTransition === undefined || transition ? nativeScroll : scrollOrTransition; //measure the handle length to respect min & max length\n\n        var handleLength = scrollbarVarsInfo._handleLength;\n        var trackLength = scrollbarVars._track[0]['offset' + scrollbarVars._Width_Height];\n        var handleTrackDiff = trackLength - handleLength;\n        var handleCSS = {};\n        var transformOffset;\n        var translateValue; //DONT use the variable '_contentScrollSizeCache[scrollbarVars._w_h]' instead of '_viewportElement[0]['scroll' + scrollbarVars._Width_Height]'\n        // because its a bit behind during the small delay when content size updates\n        //(delay = mutationObserverContentLag, if its 0 then this var could be used)\n\n        var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative['client' + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1); //* -1 if rtl scroll max is negative\n\n        var getScrollRatio = function (base) {\n          return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));\n        };\n\n        var getHandleOffset = function (scrollRatio) {\n          var offset = handleTrackDiff * scrollRatio;\n          offset = isNaN(offset) ? 0 : offset;\n          offset = isRTLisHorizontal && !_rtlScrollBehavior.i ? trackLength - handleLength - offset : offset;\n          offset = MATH.max(0, offset);\n          return offset;\n        };\n\n        var scrollRatio = getScrollRatio(nativeScroll);\n        var unsnappedScrollRatio = getScrollRatio(currentScroll);\n        var handleOffset = getHandleOffset(unsnappedScrollRatio);\n        var snappedHandleOffset = getHandleOffset(scrollRatio);\n        scrollbarVarsInfo._maxScroll = maxScroll;\n        scrollbarVarsInfo._currentScroll = nativeScroll;\n        scrollbarVarsInfo._currentScrollRatio = scrollRatio;\n\n        if (_supportTransform) {\n          transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset; //in px\n          //transformOffset = (transformOffset / trackLength * 100) * (trackLength / handleLength); //in %\n\n          translateValue = isHorizontal ? strTranslateBrace + transformOffset + 'px, 0)' : strTranslateBrace + '0, ' + transformOffset + 'px)';\n          handleCSS[strTransform] = translateValue; //apply or clear up transition\n\n          if (_supportTransition) handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ', ' + (strTransform + _strSpace + transitionDuration + 'ms') : _strEmpty;\n        } else handleCSS[scrollbarVars._left_top] = handleOffset; //only apply css if offset has changed and overflow exists.\n\n\n        if (!nativeOverlayScrollbarsAreActive()) {\n          scrollbarVars._handle.css(handleCSS); //clear up transition\n\n\n          if (_supportTransform && _supportTransition && transition) {\n            scrollbarVars._handle.one(_strTransitionEndEvent, function () {\n              if (!_destroyed) scrollbarVars._handle.css(strTransition, _strEmpty);\n            });\n          }\n        }\n\n        scrollbarVarsInfo._handleOffset = handleOffset;\n        scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;\n        scrollbarVarsInfo._trackLength = trackLength;\n      }\n      /**\r\n       * Refreshes the interactivity of the given scrollbar element.\r\n       * @param isTrack True if the track element is the target, false if the handle element is the target.\r\n       * @param value True for interactivity false for no interactivity.\r\n       */\n\n\n      function refreshScrollbarsInteractive(isTrack, value) {\n        var action = value ? 'removeClass' : 'addClass';\n        var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;\n        var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;\n        var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;\n        element1[action](className);\n        element2[action](className);\n      }\n      /**\r\n       * Returns a object which is used for fast access for specific variables.\r\n       * @param isHorizontal True if the horizontal scrollbar vars shall be accessed, false if the vertical scrollbar vars shall be accessed.\r\n       * @returns {{wh: string, WH: string, lt: string, _wh: string, _lt: string, t: *, h: *, c: {}, s: *}}\r\n       */\n\n\n      function getScrollbarVars(isHorizontal) {\n        return {\n          _width_height: isHorizontal ? _strWidth : _strHeight,\n          _Width_Height: isHorizontal ? 'Width' : 'Height',\n          _left_top: isHorizontal ? _strLeft : _strTop,\n          _Left_Top: isHorizontal ? 'Left' : 'Top',\n          _x_y: isHorizontal ? _strX : _strY,\n          _X_Y: isHorizontal ? 'X' : 'Y',\n          _w_h: isHorizontal ? 'w' : 'h',\n          _l_t: isHorizontal ? 'l' : 't',\n          _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,\n          _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,\n          _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,\n          _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo\n        };\n      } //==== Scrollbar Corner ====//\n\n      /**\r\n       * Builds or destroys the scrollbar corner DOM element.\r\n       * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n       */\n\n\n      function setupScrollbarCornerDOM(destroy) {\n        _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);\n\n        if (!destroy) {\n          if (!_domExists) {\n            _hostElement.append(_scrollbarCornerElement);\n          }\n        } else {\n          if (_domExists && _initialized) {\n            removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);\n          } else {\n            remove(_scrollbarCornerElement);\n          }\n        }\n      }\n      /**\r\n       * Initializes all scrollbar corner interactivity events.\r\n       */\n\n\n      function setupScrollbarCornerEvents() {\n        var insideIFrame = _windowElementNative.top !== _windowElementNative;\n        var mouseDownPosition = {};\n        var mouseDownSize = {};\n        var mouseDownInvertedScale = {};\n        var reconnectMutationObserver;\n\n        function documentDragMove(event) {\n          if (onMouseTouchDownContinue(event)) {\n            var pageOffset = getCoordinates(event);\n            var hostElementCSS = {};\n            if (_resizeHorizontal || _resizeBoth) hostElementCSS[_strWidth] = mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x;\n            if (_resizeVertical || _resizeBoth) hostElementCSS[_strHeight] = mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y;\n\n            _hostElement.css(hostElementCSS);\n\n            COMPATIBILITY.stpP(event);\n          } else {\n            documentMouseTouchUp(event);\n          }\n        }\n\n        function documentMouseTouchUp(event) {\n          var eventIsTrusted = event !== undefined;\n          setupResponsiveEventListener(_documentElement, [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent], [documentOnSelectStart, documentDragMove, documentMouseTouchUp], true);\n          removeClass(_bodyElement, _classNameDragging);\n          if (_scrollbarCornerElement.releaseCapture) _scrollbarCornerElement.releaseCapture();\n\n          if (eventIsTrusted) {\n            if (reconnectMutationObserver) connectMutationObservers();\n\n            _base.update(_strAuto);\n          }\n\n          reconnectMutationObserver = false;\n        }\n\n        function onMouseTouchDownContinue(event) {\n          var originalEvent = event.originalEvent || event;\n          var isTouchEvent = originalEvent.touches !== undefined;\n          return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;\n        }\n\n        function getCoordinates(event) {\n          return _msieVersion && insideIFrame ? {\n            x: event.screenX,\n            y: event.screenY\n          } : COMPATIBILITY.page(event);\n        }\n\n        addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function (event) {\n          if (onMouseTouchDownContinue(event) && !_resizeNone) {\n            if (_mutationObserversConnected) {\n              reconnectMutationObserver = true;\n              disconnectMutationObservers();\n            }\n\n            mouseDownPosition = getCoordinates(event);\n            mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);\n            mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);\n            mouseDownInvertedScale = getHostElementInvertedScale();\n            setupResponsiveEventListener(_documentElement, [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent], [documentOnSelectStart, documentDragMove, documentMouseTouchUp]);\n            addClass(_bodyElement, _classNameDragging);\n            if (_scrollbarCornerElement.setCapture) _scrollbarCornerElement.setCapture();\n            COMPATIBILITY.prvD(event);\n            COMPATIBILITY.stpP(event);\n          }\n        });\n      } //==== Utils ====//\n\n      /**\r\n       * Calls the callback with the given name. The Context of this callback is always _base (this).\r\n       * @param name The name of the target which shall be called.\r\n       * @param args The args with which the callback shall be called.\r\n       * @param dependent Boolean which decides whether the callback shall be fired, undefined is like a \"true\" value.\r\n       */\n\n\n      function dispatchCallback(name, args, dependent) {\n        if (dependent === false) return;\n\n        if (_initialized) {\n          var callback = _currentPreparedOptions.callbacks[name];\n          var extensionOnName = name;\n          var ext;\n          if (extensionOnName.substr(0, 2) === 'on') extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);\n          if (type(callback) == TYPES.f) callback.call(_base, args);\n          each(_extensions, function () {\n            ext = this;\n            if (type(ext.on) == TYPES.f) ext.on(extensionOnName, args);\n          });\n        } else if (!_destroyed) _callbacksInitQeueue.push({\n          n: name,\n          a: args\n        });\n      }\n      /**\r\n       * Sets the \"top, right, bottom, left\" properties, with a given prefix, of the given css object.\r\n       * @param targetCSSObject The css object to which the values shall be applied.\r\n       * @param prefix The prefix of the \"top, right, bottom, left\" css properties. (example: 'padding-' is a valid prefix)\r\n       * @param values A array of values which shall be applied to the \"top, right, bottom, left\" -properties. The array order is [top, right, bottom, left].\r\n       * If this argument is undefined the value '' (empty string) will be applied to all properties.\r\n       */\n\n\n      function setTopRightBottomLeft(targetCSSObject, prefix, values) {\n        prefix = prefix || _strEmpty;\n        values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];\n        targetCSSObject[prefix + _strTop] = values[0];\n        targetCSSObject[prefix + _strRight] = values[1];\n        targetCSSObject[prefix + _strBottom] = values[2];\n        targetCSSObject[prefix + _strLeft] = values[3];\n      }\n      /**\r\n       * Gets the \"top, right, bottom, left\" CSS properties of the CSS property with the given prefix from the host element.\r\n       * @param prefix The prefix of the \"top, right, bottom, left\" css properties. (example: 'padding-' is a valid prefix)\r\n       * @param suffix The suffix of the \"top, right, bottom, left\" css properties. (example: 'border-' is a valid prefix with '-width' is a valid suffix)\r\n       * @param zeroX True if the x axis shall be 0.\r\n       * @param zeroY True if the y axis shall be 0.\r\n       * @returns {{}} The object which contains the numbers of the read CSS properties.\r\n       */\n\n\n      function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {\n        suffix = suffix || _strEmpty;\n        prefix = prefix || _strEmpty;\n        return {\n          t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),\n          r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),\n          b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),\n          l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))\n        };\n      }\n      /**\r\n       * Returns the computed CSS transition string from the given element.\r\n       * @param element The element from which the transition string shall be returned.\r\n       * @returns {string} The CSS transition string from the given element.\r\n       */\n\n\n      function getCSSTransitionString(element) {\n        var transitionStr = VENDORS._cssProperty('transition');\n\n        var assembledValue = element.css(transitionStr);\n        if (assembledValue) return assembledValue;\n        var regExpString = '\\\\s*(' + '([^,(]+(\\\\(.+?\\\\))?)+' + ')[\\\\s,]*';\n        var regExpMain = new RegExp(regExpString);\n        var regExpValidate = new RegExp('^(' + regExpString + ')+$');\n        var properties = 'property duration timing-function delay'.split(' ');\n        var result = [];\n        var strResult;\n        var valueArray;\n        var i = 0;\n        var j;\n\n        var splitCssStyleByComma = function (str) {\n          strResult = [];\n          if (!str.match(regExpValidate)) return str;\n\n          while (str.match(regExpMain)) {\n            strResult.push(RegExp.$1);\n            str = str.replace(regExpMain, _strEmpty);\n          }\n\n          return strResult;\n        };\n\n        for (; i < properties[LEXICON.l]; i++) {\n          valueArray = splitCssStyleByComma(element.css(transitionStr + '-' + properties[i]));\n\n          for (j = 0; j < valueArray[LEXICON.l]; j++) result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];\n        }\n\n        return result.join(', ');\n      }\n      /**\r\n       * Generates a Regular Expression which matches with a string which starts with 'os-host'.\r\n       * @param {boolean} withCurrClassNameOption The Regular Expression also matches if the string is the current ClassName option (multiple values splitted by space possible).\r\n       * @param {boolean} withOldClassNameOption The Regular Expression also matches if the string is the old ClassName option (multiple values splitted by space possible).\r\n       */\n\n\n      function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {\n        var i;\n        var split;\n        var appendix;\n\n        var appendClasses = function (classes, condition) {\n          appendix = '';\n\n          if (condition && typeof classes == TYPES.s) {\n            split = classes.split(_strSpace);\n\n            for (i = 0; i < split[LEXICON.l]; i++) appendix += '|' + split[i] + '$'; // split[i].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') for escaping regex characters\n\n          }\n\n          return appendix;\n        };\n\n        return new RegExp('(^' + _classNameHostElement + '([-_].+|)$)' + appendClasses(_classNameCache, withCurrClassNameOption) + appendClasses(_oldClassName, withOldClassNameOption), 'g');\n      }\n      /**\r\n       * Calculates the host-elements inverted scale. (invertedScale = 1 / scale)\r\n       * @returns {{x: number, y: number}} The scale of the host-element.\r\n       */\n\n\n      function getHostElementInvertedScale() {\n        var rect = _paddingElementNative[LEXICON.bCR]();\n\n        return {\n          x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,\n          y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1\n        };\n      }\n      /**\r\n       * Checks whether the given object is a HTMLElement.\r\n       * @param o The object which shall be checked.\r\n       * @returns {boolean} True the given object is a HTMLElement, false otherwise.\r\n       */\n\n\n      function isHTMLElement(o) {\n        var strOwnerDocument = 'ownerDocument';\n        var strHTMLElement = 'HTMLElement';\n        var wnd = o && o[strOwnerDocument] ? o[strOwnerDocument].parentWindow || window : window;\n        return typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : //DOM2\n        o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s;\n      }\n      /**\r\n       * Compares 2 arrays and returns the differences between them as a array.\r\n       * @param a1 The first array which shall be compared.\r\n       * @param a2 The second array which shall be compared.\r\n       * @returns {Array} The differences between the two arrays.\r\n       */\n\n\n      function getArrayDifferences(a1, a2) {\n        var a = [];\n        var diff = [];\n        var i;\n        var k;\n\n        for (i = 0; i < a1.length; i++) a[a1[i]] = true;\n\n        for (i = 0; i < a2.length; i++) {\n          if (a[a2[i]]) delete a[a2[i]];else a[a2[i]] = true;\n        }\n\n        for (k in a) diff.push(k);\n\n        return diff;\n      }\n      /**\r\n       * Returns Zero or the number to which the value can be parsed.\r\n       * @param value The value which shall be parsed.\r\n       * @param toFloat Indicates whether the number shall be parsed to a float.\r\n       */\n\n\n      function parseToZeroOrNumber(value, toFloat) {\n        var num = toFloat ? parseFloat(value) : parseInt(value, 10);\n        return isNaN(num) ? 0 : num;\n      }\n      /**\r\n       * Gets several information of the textarea and returns them as a object or undefined if the browser doesn't support it.\r\n       * @returns {{cursorRow: Number, cursorCol, rows: Number, cols: number, wRow: number, pos: number, max : number}} or undefined if not supported.\r\n       */\n\n\n      function getTextareaInfo() {\n        //read needed values\n        var textareaCursorPosition = _targetElementNative.selectionStart;\n        if (textareaCursorPosition === undefined) return;\n\n        var textareaValue = _targetElement.val();\n\n        var textareaLength = textareaValue[LEXICON.l];\n        var textareaRowSplit = textareaValue.split('\\n');\n        var textareaLastRow = textareaRowSplit[LEXICON.l];\n        var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split('\\n');\n        var widestRow = 0;\n        var textareaLastCol = 0;\n        var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];\n        var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];\n        var rowCols;\n        var i; //get widest Row and the last column of the textarea\n\n        for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {\n          rowCols = textareaRowSplit[i][LEXICON.l];\n\n          if (rowCols > textareaLastCol) {\n            widestRow = i + 1;\n            textareaLastCol = rowCols;\n          }\n        }\n\n        return {\n          _cursorRow: cursorRow,\n          //cursorRow\n          _cursorColumn: cursorCol,\n          //cursorCol\n          _rows: textareaLastRow,\n          //rows\n          _columns: textareaLastCol,\n          //cols\n          _widestRow: widestRow,\n          //wRow\n          _cursorPosition: textareaCursorPosition,\n          //pos\n          _cursorMax: textareaLength //max\n\n        };\n      }\n      /**\r\n       * Determines whether native overlay scrollbars are active.\r\n       * @returns {boolean} True if native overlay scrollbars are active, false otherwise.\r\n       */\n\n\n      function nativeOverlayScrollbarsAreActive() {\n        return _ignoreOverlayScrollbarHidingCache && _nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y;\n      }\n      /**\r\n       * Gets the element which is used to measure the content size.\r\n       * @returns {*} TextareaCover if target element is textarea else the ContentElement.\r\n       */\n\n\n      function getContentMeasureElement() {\n        return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;\n      }\n      /**\r\n       * Generates a string which represents a HTML div with the given classes or attributes.\r\n       * @param classesOrAttrs The class of the div as string or a object which represents the attributes of the div. (The class attribute can also be written as \"className\".)\r\n       * @param content The content of the div as string.\r\n       * @returns {string} The concated string which represents a HTML div and its content.\r\n       */\n\n\n      function generateDiv(classesOrAttrs, content) {\n        return '<div ' + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ? 'class=\"' + classesOrAttrs + '\"' : function () {\n          var key;\n          var attrs = _strEmpty;\n\n          if (FRAMEWORK.isPlainObject(classesOrAttrs)) {\n            for (key in classesOrAttrs) attrs += (key === 'c' ? 'class' : key) + '=\"' + classesOrAttrs[key] + '\" ';\n          }\n\n          return attrs;\n        }() : _strEmpty) + '>' + (content || _strEmpty) + '</div>';\n      }\n      /**\r\n       * Selects or generates a div with the given class attribute.\r\n       * @param className The class names (divided by spaces) of the div which shall be selected or generated.\r\n       * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)\r\n       * If its a boolean it decides whether only the children of the host element shall be selected.\r\n       * @returns {*} The generated or selected element.\r\n       */\n\n\n      function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {\n        var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;\n        var selectParent = onlyChildren ? _hostElement : selectParentOrOnlyChildren || _hostElement;\n        return _domExists && !selectParent[LEXICON.l] ? null : _domExists ? selectParent[onlyChildren ? 'children' : 'find'](_strDot + className.replace(/\\s/g, _strDot)).eq(0) : FRAMEWORK(generateDiv(className));\n      }\n      /**\r\n       * Gets the value of the given property from the given object.\r\n       * @param obj The object from which the property value shall be got.\r\n       * @param path The property of which the value shall be got.\r\n       * @returns {*} Returns the value of the searched property or undefined of the property wasn't found.\r\n       */\n\n\n      function getObjectPropVal(obj, path) {\n        var splits = path.split(_strDot);\n        var i = 0;\n        var val;\n\n        for (; i < splits.length; i++) {\n          if (!obj[LEXICON.hOP](splits[i])) return;\n          val = obj[splits[i]];\n          if (i < splits.length && type(val) == TYPES.o) obj = val;\n        }\n\n        return val;\n      }\n      /**\r\n       * Sets the value of the given property from the given object.\r\n       * @param obj The object from which the property value shall be set.\r\n       * @param path The property of which the value shall be set.\r\n       * @param val The value of the property which shall be set.\r\n       */\n\n\n      function setObjectPropVal(obj, path, val) {\n        var splits = path.split(_strDot);\n        var splitsLength = splits.length;\n        var i = 0;\n        var extendObj = {};\n        var extendObjRoot = extendObj;\n\n        for (; i < splitsLength; i++) extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;\n\n        FRAMEWORK.extend(obj, extendObjRoot, true);\n      }\n      /**\t\r\n       * Runs a action for each selector inside the updateOnLoad option.\t\r\n       * @param {Function} action The action for each updateOnLoad selector, the arguments the function takes is the index and the value (the selector).\t\r\n       */\n\n\n      function eachUpdateOnLoad(action) {\n        var updateOnLoad = _currentPreparedOptions.updateOnLoad;\n        updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;\n\n        if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {\n          each(updateOnLoad, action);\n        }\n      } //==== Utils Cache ====//\n\n      /**\r\n       * Compares two values or objects and returns true if they aren't equal.\r\n       * @param current The first value or object which shall be compared.\r\n       * @param cache The second value or object which shall be compared.\r\n       * @param force If true the returned value is always true.\r\n       * @returns {boolean} True if both values or objects aren't equal or force is true, false otherwise.\r\n       */\n\n\n      function checkCache(current, cache, force) {\n        if (force) return force;\n\n        if (type(current) == TYPES.o && type(cache) == TYPES.o) {\n          for (var prop in current) {\n            if (prop !== 'c') {\n              if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {\n                if (checkCache(current[prop], cache[prop])) return true;\n              } else {\n                return true;\n              }\n            }\n          }\n        } else {\n          return current !== cache;\n        }\n\n        return false;\n      } //==== Shortcuts ====//\n\n      /**\r\n       * jQuery extend method shortcut with a appended \"true\" as first argument.\r\n       */\n\n\n      function extendDeep() {\n        return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));\n      }\n      /**\r\n       * jQuery addClass method shortcut.\r\n       */\n\n\n      function addClass(el, classes) {\n        return _frameworkProto.addClass.call(el, classes);\n      }\n      /**\r\n       * jQuery removeClass method shortcut.\r\n       */\n\n\n      function removeClass(el, classes) {\n        return _frameworkProto.removeClass.call(el, classes);\n      }\n      /**\r\n       * Adds or removes the given classes dependent on the boolean value. True for add, false for remove.\r\n       */\n\n\n      function addRemoveClass(el, classes, doAdd) {\n        return doAdd ? addClass(el, classes) : removeClass(el, classes);\n      }\n      /**\r\n       * jQuery remove method shortcut.\r\n       */\n\n\n      function remove(el) {\n        return _frameworkProto.remove.call(el);\n      }\n      /**\r\n       * Finds the first child element with the given selector of the given element.\r\n       * @param el The root element from which the selector shall be valid.\r\n       * @param selector The selector of the searched element.\r\n       * @returns {*} The first element which is a child of the given element and matches the givens selector.\r\n       */\n\n\n      function findFirst(el, selector) {\n        return _frameworkProto.find.call(el, selector).eq(0);\n      } //==== API ====//\n\n      /**\r\n       * Puts the instance to sleep. It wont respond to any changes in the DOM and won't update. Scrollbar Interactivity is also disabled as well as the resize handle.\r\n       * This behavior can be reset by calling the update method.\r\n       */\n\n\n      _base.sleep = function () {\n        _sleeping = true;\n      };\n      /**\r\n       * Updates the plugin and DOM to the current options.\r\n       * This method should only be called if a update is 100% required.\r\n       * @param force True if every property shall be updated and the cache shall be ignored.\r\n       * !INTERNAL USAGE! : force can be a string \"auto\", \"sync\" or \"zoom\" too\r\n       * if \"auto\" then before a real update the content size and host element attributes gets checked, and if they changed only then the update method will be called.\r\n       * if \"sync\" then the async update process (MutationObserver or UpdateLoop) gets synchronized and a corresponding update takes place if one was needed due to pending changes.\r\n       * if \"zoom\" then a update takes place where it's assumed that content and host size changed\r\n       * @returns {boolean|undefined} \r\n       * If force is \"sync\" then a boolean is returned which indicates whether a update was needed due to pending changes.\r\n       * If force is \"auto\" then a boolean is returned whether a update was needed due to attribute or size changes.\r\n       * undefined otherwise.\r\n       */\n\n\n      _base.update = function (force) {\n        if (_destroyed) return;\n        var attrsChanged;\n        var contentSizeC;\n        var isString = type(force) == TYPES.s;\n        var doUpdateAuto;\n        var mutHost;\n        var mutContent;\n\n        if (isString) {\n          if (force === _strAuto) {\n            attrsChanged = meaningfulAttrsChanged();\n            contentSizeC = updateAutoContentSizeChanged();\n            doUpdateAuto = attrsChanged || contentSizeC;\n\n            if (doUpdateAuto) {\n              update({\n                _contentSizeChanged: contentSizeC,\n                _changedOptions: _initialized ? undefined : _currentPreparedOptions\n              });\n            }\n          } else if (force === _strSync) {\n            if (_mutationObserversConnected) {\n              mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());\n              mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());\n            } else {\n              mutHost = _base.update(_strAuto);\n            }\n          } else if (force === 'zoom') {\n            update({\n              _hostSizeChanged: true,\n              _contentSizeChanged: true\n            });\n          }\n        } else {\n          force = _sleeping || force;\n          _sleeping = false;\n          if (!_base.update(_strSync) || force) update({\n            _force: force\n          });\n        }\n\n        updateElementsOnLoad();\n        return doUpdateAuto || mutHost || mutContent;\n      };\n      /**\r\n       Gets or sets the current options. The update method will be called automatically if new options were set.\r\n       * @param newOptions If new options are given, then the new options will be set, if new options aren't given (undefined or a not a plain object) then the current options will be returned.\r\n       * @param value If new options is a property path string, then this value will be used to set the option to which the property path string leads.\r\n       * @returns {*}\r\n       */\n\n\n      _base.options = function (newOptions, value) {\n        var option = {};\n        var changedOps; //return current options if newOptions are undefined or empty\n\n        if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {\n          if (type(newOptions) == TYPES.s) {\n            if (arguments.length > 1) {\n              setObjectPropVal(option, newOptions, value);\n              changedOps = setOptions(option);\n            } else return getObjectPropVal(_currentOptions, newOptions);\n          } else return _currentOptions;\n        } else {\n          changedOps = setOptions(newOptions);\n        }\n\n        if (!FRAMEWORK.isEmptyObject(changedOps)) {\n          update({\n            _changedOptions: changedOps\n          });\n        }\n      };\n      /**\r\n       * Restore the DOM, disconnects all observers, remove all resize observers and put the instance to sleep.\r\n       */\n\n\n      _base.destroy = function () {\n        if (_destroyed) return; //remove this instance from auto update loop\n\n        autoUpdateLoop.remove(_base); //disconnect all mutation observers\n\n        disconnectMutationObservers(); //remove all resize observers\n\n        setupResizeObserver(_sizeObserverElement);\n        setupResizeObserver(_sizeAutoObserverElement); //remove all extensions\n\n        for (var extName in _extensions) _base.removeExt(extName); //remove all 'destroy' events\n\n\n        while (_destroyEvents[LEXICON.l] > 0) _destroyEvents.pop()(); //remove all events from host element\n\n\n        setupHostMouseTouchEvents(true); //remove all helper / detection elements\n\n        if (_contentGlueElement) remove(_contentGlueElement);\n        if (_contentArrangeElement) remove(_contentArrangeElement);\n        if (_sizeAutoObserverAdded) remove(_sizeAutoObserverElement); //remove all generated DOM\n\n        setupScrollbarsDOM(true);\n        setupScrollbarCornerDOM(true);\n        setupStructureDOM(true); //remove all generated image load events\n\n        for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++) FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);\n\n        _updateOnLoadElms = undefined;\n        _destroyed = true;\n        _sleeping = true; //remove this instance from the instances list\n\n        INSTANCES(pluginTargetElement, 0);\n        dispatchCallback('onDestroyed'); //remove all properties and methods\n        //for (var property in _base)\n        //    delete _base[property];\n        //_base = undefined;\n      };\n      /**\r\n       * Scrolls to a given position or element.\r\n       * @param coordinates\r\n       * 1. Can be \"coordinates\" which looks like:\r\n       *    { x : ?, y : ? } OR          Object with x and y properties\r\n       *    { left : ?, top : ? } OR     Object with left and top properties\r\n       *    { l : ?, t : ? } OR          Object with l and t properties\r\n       *    [ ?, ? ] OR                  Array where the first two element are the coordinates (first is x, second is y)\r\n       *    ?                            A single value which stays for both axis\r\n       *    A value can be a number, a string or a calculation.\r\n       *\r\n       *    Operators:\r\n       *    [NONE]  The current scroll will be overwritten by the value.\r\n       *    '+='    The value will be added to the current scroll offset\r\n       *    '-='    The value will be subtracted from the current scroll offset\r\n       *    '*='    The current scroll wil be multiplicated by the value.\r\n       *    '/='    The current scroll wil be divided by the value.\r\n       *\r\n       *    Units:\r\n       *    [NONE]  The value is the final scroll amount.                   final = (value * 1)\r\n       *    'px'    Same as none\r\n       *    '%'     The value is dependent on the current scroll value.     final = ((currentScrollValue / 100) * value)\r\n       *    'vw'    The value is multiplicated by the viewport width.       final = (value * viewportWidth)\r\n       *    'vh'    The value is multiplicated by the viewport height.      final = (value * viewportHeight)\r\n       *\r\n       *    example final values:\r\n       *    200, '200px', '50%', '1vw', '1vh', '+=200', '/=1vw', '*=2px', '-=5vh', '+=33%', '+= 50% - 2px', '-= 1vw - 50%'\r\n       *\r\n       * 2. Can be a HTML or jQuery element:\r\n       *    The final scroll offset is the offset (without margin) of the given HTML / jQuery element.\r\n       *\r\n       * 3. Can be a object with a HTML or jQuery element with additional settings:\r\n       *    {\r\n       *      el : [HTMLElement, jQuery element],             MUST be specified, else this object isn't valid.\r\n       *      scroll : [string, array, object],               Default value is 'always'.\r\n       *      block : [string, array, object],                Default value is 'begin'.\r\n       *      margin : [number, boolean, array, object]       Default value is false.\r\n       *    }\r\n       *\r\n       *    Possible scroll settings are:\r\n       *    'always'      Scrolls always.\r\n       *    'ifneeded'    Scrolls only if the element isnt fully in view.\r\n       *    'never'       Scrolls never.\r\n       *\r\n       *    Possible block settings are:\r\n       *    'begin'   Both axis shall be docked to the \"begin\" edge. - The element will be docked to the top and left edge of the viewport.\r\n       *    'end'     Both axis shall be docked to the \"end\" edge. - The element will be docked to the bottom and right edge of the viewport. (If direction is RTL to the bottom and left edge.)\r\n       *    'center'  Both axis shall be docked to \"center\". - The element will be centered in the viewport.\r\n       *    'nearest' The element will be docked to the nearest edge(s).\r\n       *\r\n       *    Possible margin settings are: -- The actual margin of the element wont be affect, this option affects only the final scroll offset.\r\n       *    [BOOLEAN]                                         If true the css margin of the element will be used, if false no margin will be used.\r\n       *    [NUMBER]                                          The margin will be used for all edges.\r\n       *\r\n       * @param duration The duration of the scroll animation, OR a jQuery animation configuration object.\r\n       * @param easing The animation easing.\r\n       * @param complete The animation complete callback.\r\n       * @returns {{\r\n       *   position: {x: number, y: number},\r\n       *   ratio: {x: number, y: number},\r\n       *   max: {x: number, y: number},\r\n       *   handleOffset: {x: number, y: number},\r\n       *   handleLength: {x: number, y: number},\r\n       *   handleLengthRatio: {x: number, y: number}, t\r\n       *   rackLength: {x: number, y: number},\r\n       *   isRTL: boolean,\r\n       *   isRTLNormalized: boolean\r\n       *  }}\r\n       */\n\n\n      _base.scroll = function (coordinates, duration, easing, complete) {\n        if (arguments.length === 0 || coordinates === undefined) {\n          var infoX = _scrollHorizontalInfo;\n          var infoY = _scrollVerticalInfo;\n          var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;\n          var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;\n          var scrollX = infoX._currentScroll;\n          var scrollXRatio = infoX._currentScrollRatio;\n          var maxScrollX = infoX._maxScroll;\n          scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;\n          scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;\n          scrollX *= normalizeNegate ? -1 : 1;\n          maxScrollX *= normalizeNegate ? -1 : 1;\n          return {\n            position: {\n              x: scrollX,\n              y: infoY._currentScroll\n            },\n            ratio: {\n              x: scrollXRatio,\n              y: infoY._currentScrollRatio\n            },\n            max: {\n              x: maxScrollX,\n              y: infoY._maxScroll\n            },\n            handleOffset: {\n              x: infoX._handleOffset,\n              y: infoY._handleOffset\n            },\n            handleLength: {\n              x: infoX._handleLength,\n              y: infoY._handleLength\n            },\n            handleLengthRatio: {\n              x: infoX._handleLengthRatio,\n              y: infoY._handleLengthRatio\n            },\n            trackLength: {\n              x: infoX._trackLength,\n              y: infoY._trackLength\n            },\n            snappedHandleOffset: {\n              x: infoX._snappedHandleOffset,\n              y: infoY._snappedHandleOffset\n            },\n            isRTL: _isRTL,\n            isRTLNormalized: _normalizeRTLCache\n          };\n        }\n\n        _base.update(_strSync);\n\n        var normalizeRTL = _normalizeRTLCache;\n        var coordinatesXAxisProps = [_strX, _strLeft, 'l'];\n        var coordinatesYAxisProps = [_strY, _strTop, 't'];\n        var coordinatesOperators = ['+=', '-=', '*=', '/='];\n        var durationIsObject = type(duration) == TYPES.o;\n        var completeCallback = durationIsObject ? duration.complete : complete;\n        var i;\n        var finalScroll = {};\n        var specialEasing = {};\n        var doScrollLeft;\n        var doScrollTop;\n        var animationOptions;\n        var strEnd = 'end';\n        var strBegin = 'begin';\n        var strCenter = 'center';\n        var strNearest = 'nearest';\n        var strAlways = 'always';\n        var strNever = 'never';\n        var strIfNeeded = 'ifneeded';\n        var strLength = LEXICON.l;\n        var settingsAxis;\n        var settingsScroll;\n        var settingsBlock;\n        var settingsMargin;\n        var finalElement;\n        var elementObjSettingsAxisValues = [_strX, _strY, 'xy', 'yx'];\n        var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];\n        var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];\n        var coordinatesIsElementObj = coordinates[LEXICON.hOP]('el');\n        var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;\n        var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;\n        var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);\n\n        var updateScrollbarInfos = function () {\n          if (doScrollLeft) refreshScrollbarHandleOffset(true);\n          if (doScrollTop) refreshScrollbarHandleOffset(false);\n        };\n\n        var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined : function () {\n          updateScrollbarInfos();\n          completeCallback();\n        };\n\n        function checkSettingsStringValue(currValue, allowedValues) {\n          for (i = 0; i < allowedValues[strLength]; i++) {\n            if (currValue === allowedValues[i]) return true;\n          }\n\n          return false;\n        }\n\n        function getRawScroll(isX, coordinates) {\n          var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;\n          coordinates = type(coordinates) == TYPES.s || type(coordinates) == TYPES.n ? [coordinates, coordinates] : coordinates;\n          if (COMPATIBILITY.isA(coordinates)) return isX ? coordinates[0] : coordinates[1];else if (type(coordinates) == TYPES.o) {\n            //decides RTL normalization \"hack\" with .n\n            //normalizeRTL = type(coordinates.n) == TYPES.b ? coordinates.n : normalizeRTL; \n            for (i = 0; i < coordinateProps[strLength]; i++) if (coordinateProps[i] in coordinates) return coordinates[coordinateProps[i]];\n          }\n        }\n\n        function getFinalScroll(isX, rawScroll) {\n          var isString = type(rawScroll) == TYPES.s;\n          var operator;\n          var amount;\n          var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;\n          var currScroll = scrollInfo._currentScroll;\n          var maxScroll = scrollInfo._maxScroll;\n          var mult = ' * ';\n          var finalValue;\n          var isRTLisX = _isRTL && isX;\n          var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;\n          var strReplace = 'replace';\n          var evalFunc = eval;\n          var possibleOperator;\n\n          if (isString) {\n            //check operator\n            if (rawScroll[strLength] > 2) {\n              possibleOperator = rawScroll.substr(0, 2);\n              if (inArray(possibleOperator, coordinatesOperators) > -1) operator = possibleOperator;\n            } //calculate units and shortcuts\n\n\n            rawScroll = operator ? rawScroll.substr(2) : rawScroll;\n            rawScroll = rawScroll[strReplace](/min/g, 0) //'min' = 0%\n            [strReplace](/</g, 0) //'<'   = 0%\n            [strReplace](/max/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent) //'max' = 100%\n            [strReplace](/>/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent) //'>'   = 100%\n            [strReplace](/px/g, _strEmpty)[strReplace](/%/g, mult + maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100.0)[strReplace](/vw/g, mult + _viewportSize.w)[strReplace](/vh/g, mult + _viewportSize.h);\n            amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);\n          } else {\n            amount = rawScroll;\n          }\n\n          if (amount !== undefined && !isNaN(amount) && type(amount) == TYPES.n) {\n            var normalizeIsRTLisX = normalizeRTL && isRTLisX;\n            var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);\n            var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;\n            var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;\n            operatorCurrScroll = invert ? maxScroll - operatorCurrScroll : operatorCurrScroll;\n\n            switch (operator) {\n              case '+=':\n                finalValue = operatorCurrScroll + amount;\n                break;\n\n              case '-=':\n                finalValue = operatorCurrScroll - amount;\n                break;\n\n              case '*=':\n                finalValue = operatorCurrScroll * amount;\n                break;\n\n              case '/=':\n                finalValue = operatorCurrScroll / amount;\n                break;\n\n              default:\n                finalValue = amount;\n                break;\n            }\n\n            finalValue = invert ? maxScroll - finalValue : finalValue;\n            finalValue *= negate ? -1 : 1;\n            finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));\n          }\n\n          return finalValue === currScroll ? undefined : finalValue;\n        }\n\n        function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {\n          var resultDefault = [defaultValue, defaultValue];\n          var valueType = type(value);\n          var valueArrLength;\n          var valueArrItem; //value can be [ string, or array of two strings ]\n\n          if (valueType == valueInternalType) {\n            value = [value, value];\n          } else if (valueType == TYPES.a) {\n            valueArrLength = value[strLength];\n            if (valueArrLength > 2 || valueArrLength < 1) value = resultDefault;else {\n              if (valueArrLength === 1) value[1] = defaultValue;\n\n              for (i = 0; i < valueArrLength; i++) {\n                valueArrItem = value[i];\n\n                if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {\n                  value = resultDefault;\n                  break;\n                }\n              }\n            }\n          } else if (valueType == TYPES.o) value = [value[_strX] || defaultValue, value[_strY] || defaultValue];else value = resultDefault;\n\n          return {\n            x: value[0],\n            y: value[1]\n          };\n        }\n\n        function generateMargin(marginTopRightBottomLeftArray) {\n          var result = [];\n          var currValue;\n          var currValueType;\n          var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];\n\n          for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {\n            if (i === valueDirections[strLength]) break;\n            currValue = marginTopRightBottomLeftArray[i];\n            currValueType = type(currValue);\n            if (currValueType == TYPES.b) result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);else result.push(currValueType == TYPES.n ? currValue : 0);\n          }\n\n          return result;\n        }\n\n        if (possibleElementIsJQuery || possibleElementIsHTMLElement) {\n          //get settings\n          var margin = coordinatesIsElementObj ? coordinates.margin : 0;\n          var axis = coordinatesIsElementObj ? coordinates.axis : 0;\n          var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;\n          var block = coordinatesIsElementObj ? coordinates.block : 0;\n          var marginDefault = [0, 0, 0, 0];\n          var marginType = type(margin);\n          var marginLength;\n          finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);\n\n          if (finalElement[strLength] > 0) {\n            //margin can be [ boolean, number, array of 2, array of 4, object ]\n            if (marginType == TYPES.n || marginType == TYPES.b) margin = generateMargin([margin, margin, margin, margin]);else if (marginType == TYPES.a) {\n              marginLength = margin[strLength];\n              if (marginLength === 2) margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);else if (marginLength >= 4) margin = generateMargin(margin);else margin = marginDefault;\n            } else if (marginType == TYPES.o) margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);else margin = marginDefault; //block = type(block) === TYPES.b ? block ? [ strNearest, strBegin ] : [ strNearest, strEnd ] : block;\n\n            settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : 'xy';\n            settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);\n            settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);\n            settingsMargin = margin;\n            var viewportScroll = {\n              l: _scrollHorizontalInfo._currentScroll,\n              t: _scrollVerticalInfo._currentScroll\n            }; // use padding element instead of viewport element because padding element has never padding, margin or position applied.\n\n            var viewportOffset = _paddingElement.offset(); //get coordinates\n\n\n            var elementOffset = finalElement.offset();\n            var doNotScroll = {\n              x: settingsScroll.x == strNever || settingsAxis == _strY,\n              y: settingsScroll.y == strNever || settingsAxis == _strX\n            };\n            elementOffset[_strTop] -= settingsMargin[0];\n            elementOffset[_strLeft] -= settingsMargin[3];\n            var elementScrollCoordinates = {\n              x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),\n              y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)\n            };\n\n            if (_isRTL) {\n              if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i) elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);\n              if (_rtlScrollBehavior.n && normalizeRTL) elementScrollCoordinates.x *= -1;\n              if (_rtlScrollBehavior.i && normalizeRTL) elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));\n            } //measuring is required\n\n\n            if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {\n              var measuringElm = finalElement[0];\n              var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {\n                width: measuringElm[LEXICON.oW],\n                height: measuringElm[LEXICON.oH]\n              };\n              var elementSize = {\n                w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],\n                h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]\n              };\n\n              var finalizeBlock = function (isX) {\n                var vars = getScrollbarVars(isX);\n                var wh = vars._w_h;\n                var lt = vars._left_top;\n                var xy = vars._x_y;\n                var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);\n                var blockIsCenter = settingsBlock[xy] == strCenter;\n                var blockIsNearest = settingsBlock[xy] == strNearest;\n                var scrollNever = settingsScroll[xy] == strNever;\n                var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;\n                var vpSize = _viewportSize[wh];\n                var vpOffset = viewportOffset[lt];\n                var elSize = elementSize[wh];\n                var elOffset = elementOffset[lt];\n                var divide = blockIsCenter ? 2 : 1;\n                var elementCenterOffset = elOffset + elSize / 2;\n                var viewportCenterOffset = vpOffset + vpSize / 2;\n                var isInView = elSize <= vpSize && elOffset >= vpOffset && elOffset + elSize <= vpOffset + vpSize;\n                if (scrollNever) doNotScroll[xy] = true;else if (!doNotScroll[xy]) {\n                  if (blockIsNearest || scrollIfNeeded) {\n                    doNotScroll[xy] = scrollIfNeeded ? isInView : false;\n                    blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;\n                  }\n\n                  elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? (vpSize / divide - elSize / divide) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;\n                }\n              };\n\n              finalizeBlock(true);\n              finalizeBlock(false);\n            }\n\n            if (doNotScroll.y) delete elementScrollCoordinates.y;\n            if (doNotScroll.x) delete elementScrollCoordinates.x;\n            coordinates = elementScrollCoordinates;\n          }\n        }\n\n        finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));\n        finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));\n        doScrollLeft = finalScroll[_strScrollLeft] !== undefined;\n        doScrollTop = finalScroll[_strScrollTop] !== undefined;\n\n        if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {\n          if (durationIsObject) {\n            duration.complete = proxyCompleteCallback;\n\n            _viewportElement.animate(finalScroll, duration);\n          } else {\n            animationOptions = {\n              duration: duration,\n              complete: proxyCompleteCallback\n            };\n\n            if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {\n              specialEasing[_strScrollLeft] = easing[0] || easing.x;\n              specialEasing[_strScrollTop] = easing[1] || easing.y;\n              animationOptions.specialEasing = specialEasing;\n            } else {\n              animationOptions.easing = easing;\n            }\n\n            _viewportElement.animate(finalScroll, animationOptions);\n          }\n        } else {\n          if (doScrollLeft) _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);\n          if (doScrollTop) _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);\n          updateScrollbarInfos();\n        }\n      };\n      /**\r\n       * Stops all scroll animations.\r\n       * @returns {*} The current OverlayScrollbars instance (for chaining).\r\n       */\n\n\n      _base.scrollStop = function (param1, param2, param3) {\n        _viewportElement.stop(param1, param2, param3);\n\n        return _base;\n      };\n      /**\r\n       * Returns all relevant elements.\r\n       * @param elementName The name of the element which shall be returned.\r\n       * @returns {{target: *, host: *, padding: *, viewport: *, content: *, scrollbarHorizontal: {scrollbar: *, track: *, handle: *}, scrollbarVertical: {scrollbar: *, track: *, handle: *}, scrollbarCorner: *} | *}\r\n       */\n\n\n      _base.getElements = function (elementName) {\n        var obj = {\n          target: _targetElementNative,\n          host: _hostElementNative,\n          padding: _paddingElementNative,\n          viewport: _viewportElementNative,\n          content: _contentElementNative,\n          scrollbarHorizontal: {\n            scrollbar: _scrollbarHorizontalElement[0],\n            track: _scrollbarHorizontalTrackElement[0],\n            handle: _scrollbarHorizontalHandleElement[0]\n          },\n          scrollbarVertical: {\n            scrollbar: _scrollbarVerticalElement[0],\n            track: _scrollbarVerticalTrackElement[0],\n            handle: _scrollbarVerticalHandleElement[0]\n          },\n          scrollbarCorner: _scrollbarCornerElement[0]\n        };\n        return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;\n      };\n      /**\r\n       * Returns a object which describes the current state of this instance.\r\n       * @param stateProperty A specific property from the state object which shall be returned.\r\n       * @returns {{widthAuto, heightAuto, overflowAmount, hideOverflow, hasOverflow, contentScrollSize, viewportSize, hostSize, autoUpdate} | *}\r\n       */\n\n\n      _base.getState = function (stateProperty) {\n        function prepare(obj) {\n          if (!FRAMEWORK.isPlainObject(obj)) return obj;\n          var extended = extendDeep({}, obj);\n\n          var changePropertyName = function (from, to) {\n            if (extended[LEXICON.hOP](from)) {\n              extended[to] = extended[from];\n              delete extended[from];\n            }\n          };\n\n          changePropertyName('w', _strWidth); //change w to width\n\n          changePropertyName('h', _strHeight); //change h to height\n\n          delete extended.c; //delete c (the 'changed' prop)\n\n          return extended;\n        }\n\n        ;\n        var obj = {\n          destroyed: !!prepare(_destroyed),\n          sleeping: !!prepare(_sleeping),\n          autoUpdate: prepare(!_mutationObserversConnected),\n          widthAuto: prepare(_widthAutoCache),\n          heightAuto: prepare(_heightAutoCache),\n          padding: prepare(_cssPaddingCache),\n          overflowAmount: prepare(_overflowAmountCache),\n          hideOverflow: prepare(_hideOverflowCache),\n          hasOverflow: prepare(_hasOverflowCache),\n          contentScrollSize: prepare(_contentScrollSizeCache),\n          viewportSize: prepare(_viewportSize),\n          hostSize: prepare(_hostSizeCache),\n          documentMixed: prepare(_documentMixed)\n        };\n        return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;\n      };\n      /**\r\n       * Gets all or specific extension instance.\r\n       * @param extName The name of the extension from which the instance shall be got.\r\n       * @returns {{}} The instance of the extension with the given name or undefined if the instance couldn't be found.\r\n       */\n\n\n      _base.ext = function (extName) {\n        var result;\n\n        var privateMethods = _extensionsPrivateMethods.split(' ');\n\n        var i = 0;\n\n        if (type(extName) == TYPES.s) {\n          if (_extensions[LEXICON.hOP](extName)) {\n            result = extendDeep({}, _extensions[extName]);\n\n            for (; i < privateMethods.length; i++) delete result[privateMethods[i]];\n          }\n        } else {\n          result = {};\n\n          for (i in _extensions) result[i] = extendDeep({}, _base.ext(i));\n        }\n\n        return result;\n      };\n      /**\r\n       * Adds a extension to this instance.\r\n       * @param extName The name of the extension which shall be added.\r\n       * @param extensionOptions The extension options which shall be used.\r\n       * @returns {{}} The instance of the added extension or undefined if the extension couldn't be added properly.\r\n       */\n\n\n      _base.addExt = function (extName, extensionOptions) {\n        var registeredExtensionObj = _plugin.extension(extName);\n\n        var instance;\n        var instanceAdded;\n        var instanceContract;\n        var contractResult;\n        var contractFulfilled = true;\n\n        if (registeredExtensionObj) {\n          if (!_extensions[LEXICON.hOP](extName)) {\n            instance = registeredExtensionObj.extensionFactory.call(_base, extendDeep({}, registeredExtensionObj.defaultOptions), FRAMEWORK, COMPATIBILITY);\n\n            if (instance) {\n              instanceContract = instance.contract;\n\n              if (type(instanceContract) == TYPES.f) {\n                contractResult = instanceContract(window);\n                contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;\n              }\n\n              if (contractFulfilled) {\n                _extensions[extName] = instance;\n                instanceAdded = instance.added;\n                if (type(instanceAdded) == TYPES.f) instanceAdded(extensionOptions);\n                return _base.ext(extName);\n              }\n            }\n          } else return _base.ext(extName);\n        } else console.warn(\"A extension with the name \\\"\" + extName + \"\\\" isn't registered.\");\n      };\n      /**\r\n       * Removes a extension from this instance.\r\n       * @param extName The name of the extension which shall be removed.\r\n       * @returns {boolean} True if the extension was removed, false otherwise e.g. if the extension wasn't added before.\r\n       */\n\n\n      _base.removeExt = function (extName) {\n        var instance = _extensions[extName];\n        var instanceRemoved;\n\n        if (instance) {\n          delete _extensions[extName];\n          instanceRemoved = instance.removed;\n          if (type(instanceRemoved) == TYPES.f) instanceRemoved();\n          return true;\n        }\n\n        return false;\n      };\n      /**\r\n       * Constructs the plugin.\r\n       * @param targetElement The element to which the plugin shall be applied.\r\n       * @param options The initial options of the plugin.\r\n       * @param extensions The extension(s) which shall be added right after the initialization.\r\n       * @returns {boolean} True if the plugin was successfully initialized, false otherwise.\r\n       */\n\n\n      function construct(targetElement, options, extensions) {\n        _defaultOptions = globals.defaultOptions;\n        _nativeScrollbarStyling = globals.nativeScrollbarStyling;\n        _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);\n        _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);\n        _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);\n        _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior); //parse & set options but don't update\n\n        setOptions(extendDeep({}, _defaultOptions, options));\n        _cssCalc = globals.cssCalc;\n        _msieVersion = globals.msie;\n        _autoUpdateRecommended = globals.autoUpdateRecommended;\n        _supportTransition = globals.supportTransition;\n        _supportTransform = globals.supportTransform;\n        _supportPassiveEvents = globals.supportPassiveEvents;\n        _supportResizeObserver = globals.supportResizeObserver;\n        _supportMutationObserver = globals.supportMutationObserver;\n        _restrictedMeasuring = globals.restrictedMeasuring;\n        _documentElement = FRAMEWORK(targetElement.ownerDocument);\n        _documentElementNative = _documentElement[0];\n        _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);\n        _windowElementNative = _windowElement[0];\n        _htmlElement = findFirst(_documentElement, 'html');\n        _bodyElement = findFirst(_htmlElement, 'body');\n        _targetElement = FRAMEWORK(targetElement);\n        _targetElementNative = _targetElement[0];\n        _isTextarea = _targetElement.is('textarea');\n        _isBody = _targetElement.is('body');\n        _documentMixed = _documentElementNative !== document;\n        /* On a div Element The if checks only whether:\r\n         * - the targetElement has the class \"os-host\"\r\n         * - the targetElement has a a child with the class \"os-padding\"\r\n         * \r\n         * If that's the case, its assumed the DOM has already the following structure:\r\n         * (The \".os-host\" element is the targetElement)\r\n         *\r\n         *  <div class=\"os-host\">\r\n         *      <div class=\"os-resize-observer-host\"></div>\r\n         *      <div class=\"os-padding\">\r\n         *          <div class=\"os-viewport\">\r\n         *              <div class=\"os-content\"></div>\r\n         *          </div>\r\n         *      </div>\r\n         *      <div class=\"os-scrollbar os-scrollbar-horizontal \">\r\n         *          <div class=\"os-scrollbar-track\">\r\n         *              <div class=\"os-scrollbar-handle\"></div>\r\n         *          </div>\r\n         *      </div>\r\n         *      <div class=\"os-scrollbar os-scrollbar-vertical\">\r\n         *          <div class=\"os-scrollbar-track\">\r\n         *              <div class=\"os-scrollbar-handle\"></div>\r\n         *          </div>\r\n         *      </div>\r\n         *      <div class=\"os-scrollbar-corner\"></div>\r\n         *  </div>\r\n         *\r\n         * =====================================================================================\r\n         * \r\n         * On a Textarea Element The if checks only whether:\r\n         * - the targetElement has the class \"os-textarea\" \r\n         * - the targetElement is inside a element with the class \"os-content\" \r\n         * \r\n         * If that's the case, its assumed the DOM has already the following structure:\r\n         * (The \".os-textarea\" (textarea) element is the targetElement)\r\n         *\r\n         *  <div class=\"os-host-textarea\">\r\n         *      <div class=\"os-resize-observer-host\"></div>\r\n         *      <div class=\"os-padding os-text-inherit\">\r\n         *          <div class=\"os-viewport os-text-inherit\">\r\n         *              <div class=\"os-content os-text-inherit\">\r\n         *                  <div class=\"os-textarea-cover\"></div>\r\n         *                  <textarea class=\"os-textarea os-text-inherit\"></textarea>\r\n         *              </div>\r\n         *          </div>\r\n         *      </div>\r\n         *      <div class=\"os-scrollbar os-scrollbar-horizontal \">\r\n         *          <div class=\"os-scrollbar-track\">\r\n         *              <div class=\"os-scrollbar-handle\"></div>\r\n         *          </div>\r\n         *      </div>\r\n         *      <div class=\"os-scrollbar os-scrollbar-vertical\">\r\n         *          <div class=\"os-scrollbar-track\">\r\n         *              <div class=\"os-scrollbar-handle\"></div>\r\n         *          </div>\r\n         *      </div>\r\n         *      <div class=\"os-scrollbar-corner\"></div>\r\n         *  </div>\r\n         */\n\n        _domExists = _isTextarea ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement) : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];\n        var initBodyScroll;\n        var bodyMouseTouchDownListener; //check if the plugin hasn't to be initialized\n\n        if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {\n          dispatchCallback('onInitializationWithdrawn');\n\n          if (_domExists) {\n            setupStructureDOM(true);\n            setupScrollbarsDOM(true);\n            setupScrollbarCornerDOM(true);\n          }\n\n          _destroyed = true;\n          _sleeping = true;\n          return _base;\n        }\n\n        if (_isBody) {\n          initBodyScroll = {};\n          initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());\n          initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());\n\n          bodyMouseTouchDownListener = function () {\n            _viewportElement.removeAttr(LEXICON.ti);\n\n            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);\n          };\n        } //build OverlayScrollbars DOM\n\n\n        setupStructureDOM();\n        setupScrollbarsDOM();\n        setupScrollbarCornerDOM(); //create OverlayScrollbars events\n\n        setupStructureEvents();\n        setupScrollbarEvents(true);\n        setupScrollbarEvents(false);\n        setupScrollbarCornerEvents(); //create mutation observers\n\n        createMutationObservers(); //build resize observer for the host element\n\n        setupResizeObserver(_sizeObserverElement, hostOnResized);\n\n        if (_isBody) {\n          //apply the body scroll to handle it right in the update method\n          _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t); //set the focus on the viewport element so you dont have to click on the page to use keyboard keys (up / down / space) for scrolling\n\n\n          if (document.activeElement == targetElement && _viewportElementNative.focus) {\n            //set a tabindex to make the viewportElement focusable\n            _viewportElement.attr(LEXICON.ti, '-1');\n\n            _viewportElementNative.focus();\n            /* the tabindex has to be removed due to;\r\n             * If you set the tabindex attribute on an <div>, then its child content cannot be scrolled with the arrow keys unless you set tabindex on the content, too\r\n             * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\r\n             */\n\n\n            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);\n          }\n        } //update for the first time & initialize cache\n\n\n        _base.update(_strAuto); //the plugin is initialized now!\n\n\n        _initialized = true;\n        dispatchCallback('onInitialized'); //call all callbacks which would fire before the initialized was complete\n\n        each(_callbacksInitQeueue, function (index, value) {\n          dispatchCallback(value.n, value.a);\n        });\n        _callbacksInitQeueue = []; //add extensions\n\n        if (type(extensions) == TYPES.s) extensions = [extensions];\n        if (COMPATIBILITY.isA(extensions)) each(extensions, function (index, value) {\n          _base.addExt(value);\n        });else if (FRAMEWORK.isPlainObject(extensions)) each(extensions, function (key, value) {\n          _base.addExt(key, value);\n        }); //add the transition class for transitions AFTER the first update & AFTER the applied extensions (for preventing unwanted transitions)\n\n        setTimeout(function () {\n          if (_supportTransition && !_destroyed) addClass(_hostElement, _classNameHostTransition);\n        }, 333);\n        return _base;\n      }\n\n      if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {\n        INSTANCES(pluginTargetElement, _base);\n      }\n\n      return _base;\n    }\n    /**\r\n     * Initializes a new OverlayScrollbarsInstance object or changes options if already initialized or returns the current instance.\r\n     * @param pluginTargetElements The elements to which the Plugin shall be initialized.\r\n     * @param options The custom options with which the plugin shall be initialized.\r\n     * @param extensions The extension(s) which shall be added right after initialization.\r\n     * @returns {*}\r\n     */\n\n\n    _plugin = window[PLUGINNAME] = function (pluginTargetElements, options, extensions) {\n      if (arguments[LEXICON.l] === 0) return this;\n      var arr = [];\n      var optsIsPlainObj = FRAMEWORK.isPlainObject(options);\n      var inst;\n      var result; //pluginTargetElements is null or undefined\n\n      if (!pluginTargetElements) return optsIsPlainObj || !options ? result : arr;\n      /*\r\n         pluginTargetElements will be converted to:\r\n         1. A jQueryElement Array\r\n         2. A HTMLElement Array\r\n         3. A Array with a single HTML Element\r\n         so pluginTargetElements is always a array.\r\n      */\n\n      pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];\n      initOverlayScrollbarsStatics();\n\n      if (pluginTargetElements[LEXICON.l] > 0) {\n        if (optsIsPlainObj) {\n          FRAMEWORK.each(pluginTargetElements, function (i, v) {\n            inst = v;\n            if (inst !== undefined) arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));\n          });\n        } else {\n          FRAMEWORK.each(pluginTargetElements, function (i, v) {\n            inst = INSTANCES(v);\n            if (options === '!' && _plugin.valid(inst) || COMPATIBILITY.type(options) == TYPES.f && options(v, inst)) arr.push(inst);else if (options === undefined) arr.push(inst);\n          });\n        }\n\n        result = arr[LEXICON.l] === 1 ? arr[0] : arr;\n      }\n\n      return result;\n    };\n    /**\r\n     * Returns a object which contains global information about the plugin and each instance of it.\r\n     * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.\r\n     */\n\n\n    _plugin.globals = function () {\n      initOverlayScrollbarsStatics();\n      var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);\n      delete globals['msie'];\n      return globals;\n    };\n    /**\r\n     * Gets or Sets the default options for each new plugin initialization.\r\n     * @param newDefaultOptions The object with which the default options shall be extended.\r\n     */\n\n\n    _plugin.defaultOptions = function (newDefaultOptions) {\n      initOverlayScrollbarsStatics();\n      var currDefaultOptions = _pluginsGlobals.defaultOptions;\n      if (newDefaultOptions === undefined) return FRAMEWORK.extend(true, {}, currDefaultOptions); //set the new default options\n\n      _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);\n    };\n    /**\r\n     * Checks whether the passed instance is a non-destroyed OverlayScrollbars instance.\r\n     * @param osInstance The potential OverlayScrollbars instance which shall be checked.\r\n     * @returns {boolean} True if the passed value is a non-destroyed OverlayScrollbars instance, false otherwise.\r\n     */\n\n\n    _plugin.valid = function (osInstance) {\n      return osInstance instanceof _plugin && !osInstance.getState().destroyed;\n    };\n    /**\r\n     * Registers, Unregisters or returns a extension.\r\n     * Register: Pass the name and the extension. (defaultOptions is optional)\r\n     * Unregister: Pass the name and anything except a function as extension parameter.\r\n     * Get extension: Pass the name of the extension which shall be got.\r\n     * Get all extensions: Pass no arguments.\r\n     * @param extensionName The name of the extension which shall be registered, unregistered or returned.\r\n     * @param extension A function which generates the instance of the extension or anything other to remove a already registered extension.\r\n     * @param defaultOptions The default options which shall be used for the registered extension.\r\n     */\n\n\n    _plugin.extension = function (extensionName, extension, defaultOptions) {\n      var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;\n      var argLen = arguments[LEXICON.l];\n      var i = 0;\n\n      if (argLen < 1 || !extNameTypeString) {\n        //return a copy of all extension objects\n        return FRAMEWORK.extend(true, {\n          length: _pluginsExtensions[LEXICON.l]\n        }, _pluginsExtensions);\n      } else if (extNameTypeString) {\n        if (COMPATIBILITY.type(extension) == TYPES.f) {\n          //register extension\n          _pluginsExtensions.push({\n            name: extensionName,\n            extensionFactory: extension,\n            defaultOptions: defaultOptions\n          });\n        } else {\n          for (; i < _pluginsExtensions[LEXICON.l]; i++) {\n            if (_pluginsExtensions[i].name === extensionName) {\n              if (argLen > 1) _pluginsExtensions.splice(i, 1); //remove extension\n              else return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]); //return extension with the given name\n            }\n          }\n        }\n      }\n    };\n\n    return _plugin;\n  }();\n\n  if (JQUERY && JQUERY.fn) {\n    /**\r\n     * The jQuery initialization interface.\r\n     * @param options The initial options for the construction of the plugin. To initialize the plugin, this option has to be a object! If it isn't a object, the instance(s) are returned and the plugin wont be initialized.\r\n     * @param extensions The extension(s) which shall be added right after initialization.\r\n     * @returns {*} After initialization it returns the jQuery element array, else it returns the instance(s) of the elements which are selected.\r\n     */\n    JQUERY.fn.overlayScrollbars = function (options, extensions) {\n      var _elements = this;\n\n      if (JQUERY.isPlainObject(options)) {\n        JQUERY.each(_elements, function () {\n          PLUGIN(this, options, extensions);\n        });\n        return _elements;\n      } else return PLUGIN(_elements, options);\n    };\n  }\n\n  return PLUGIN;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb3ZlcmxheXNjcm9sbGJhcnMvanMvT3ZlcmxheVNjcm9sbGJhcnMuanM/ZGJlNSJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZGVmaW5lIiwiZG9jdW1lbnQiLCJ1bmRlZmluZWQiLCJ3aW5kb3ciLCJQTFVHSU5OQU1FIiwiVFlQRVMiLCJvIiwiZiIsImEiLCJzIiwiYiIsIm4iLCJ1IiwieiIsIkxFWElDT04iLCJjIiwiaSIsImwiLCJwIiwidGkiLCJvSCIsImNIIiwic0giLCJvVyIsImNXIiwic1ciLCJoT1AiLCJiQ1IiLCJWRU5ET1JTIiwianNDYWNoZSIsImNzc0NhY2hlIiwiY3NzUHJlZml4ZXMiLCJqc1ByZWZpeGVzIiwiZmlyc3RMZXR0ZXJUb1VwcGVyIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsIl9jc3NQcmVmaXhlcyIsIl9qc1ByZWZpeGVzIiwiX2Nzc1Byb3BlcnR5IiwibmFtZSIsInJlc3VsdCIsInVwcGVyY2FzZWROYW1lIiwiZWxtU3R5bGUiLCJjcmVhdGVFbGVtZW50IiwicmVzdWx0UG9zc2liaWxpdGllcyIsInYiLCJjdXJyVmVuZG9yV2l0aG91dERhc2hlcyIsImxlbmd0aCIsInJlcGxhY2UiLCJfY3NzUHJvcGVydHlWYWx1ZSIsInByb3BlcnR5IiwidmFsdWVzIiwic3VmZml4IiwiZHVtbXlTdHlsZSIsInBvc3NibGVWYWx1ZXMiLCJzcGxpdCIsInByZXBhcmVkU3VmZml4IiwicHJvcCIsImNzc1RleHQiLCJfanNBUEkiLCJpc0ludGVyZmFjZSIsImZhbGxiYWNrIiwidG9Mb3dlckNhc2UiLCJDT01QQVRJQklMSVRZIiwid2luZG93U2l6ZSIsIngiLCJpbm5lcldpZHRoIiwiZG9jdW1lbnRFbGVtZW50IiwiYm9keSIsImlubmVySGVpZ2h0IiwiYmluZCIsImZ1bmMiLCJ0aGlzT2JqIiwicHJvdG8iLCJhQXJncyIsIkFycmF5IiwiY2FsbCIsImFyZ3VtZW50cyIsImZOT1AiLCJmQm91bmQiLCJhcHBseSIsImNvbmNhdCIsIndXIiwid0giLCJtTyIsInJPIiwickFGIiwic2V0VGltZW91dCIsImNBRiIsImlkIiwiY2xlYXJUaW1lb3V0Iiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJzdHBQIiwiZXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJwcnZEIiwicHJldmVudERlZmF1bHQiLCJjYW5jZWxhYmxlIiwicmV0dXJuVmFsdWUiLCJwYWdlIiwib3JpZ2luYWxFdmVudCIsInN0clBhZ2UiLCJzdHJDbGllbnQiLCJzdHJYIiwic3RyWSIsInRhcmdldCIsInNyY0VsZW1lbnQiLCJldmVudERvYyIsIm93bmVyRG9jdW1lbnQiLCJkb2MiLCJ0b3VjaGVzIiwidG91Y2giLCJ5Iiwic2Nyb2xsTGVmdCIsImNsaWVudExlZnQiLCJzY3JvbGxUb3AiLCJjbGllbnRUb3AiLCJtQnRuIiwiYnV0dG9uIiwid2hpY2giLCJpbkEiLCJpdGVtIiwiYXJyIiwiZSIsImlzQSIsImRlZiIsImlzQXJyYXkiLCJ0eXBlIiwib2JqIiwiT2JqZWN0IiwidG9TdHJpbmciLCJNQVRIIiwiTWF0aCIsIkpRVUVSWSIsImpRdWVyeSIsIkVBU0lORyIsIl9lYXNpbmdzTWF0aCIsIlBJIiwiY29zIiwic2luIiwidyIsInBvdyIsInQiLCJzcXJ0IiwiYXNpbiIsImFicyIsInN3aW5nIiwiZCIsImxpbmVhciIsImVhc2VJblF1YWQiLCJlYXNlT3V0UXVhZCIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5DdWJpYyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5TaW5lIiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRTaW5lIiwiZWFzZUluRXhwbyIsImVhc2VPdXRFeHBvIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbkNpcmMiLCJlYXNlT3V0Q2lyYyIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5FbGFzdGljIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJlYXNlSW5PdXRCb3VuY2UiLCJGUkFNRVdPUksiLCJfcm5vdGh0bWx3aGl0ZSIsIl9zdHJTcGFjZSIsIl9zdHJFbXB0eSIsIl9zdHJTY3JvbGxMZWZ0IiwiX3N0clNjcm9sbFRvcCIsIl9hbmltYXRpb25zIiwiX3R5cGUiLCJfY3NzTnVtYmVyIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJjb2x1bW5Db3VudCIsImZpbGxPcGFjaXR5IiwiZmxleEdyb3ciLCJmbGV4U2hyaW5rIiwiZm9udFdlaWdodCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImV4dGVuZCIsInNyYyIsImNvcHlJc0FycmF5IiwiY29weSIsIm9wdGlvbnMiLCJjbG9uZSIsImRlZXAiLCJGYWtlalF1ZXJ5IiwiaXNQbGFpbk9iamVjdCIsImluQXJyYXkiLCJmcm9tSW5kZXgiLCJpc0Z1bmN0aW9uIiwiaXNFbXB0eU9iamVjdCIsImtleSIsImhhc093blByb3BlcnR5IiwiaGFzT3duQ29uc3RydWN0b3IiLCJoYXNJc1Byb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJlYWNoIiwiY2FsbGJhY2siLCJpc0FycmF5TGlrZSIsInN0cmlwQW5kQ29sbGFwc2UiLCJ2YWx1ZSIsInRva2VucyIsIm1hdGNoIiwiam9pbiIsIm1hdGNoZXMiLCJlbGVtIiwic2VsZWN0b3IiLCJub2RlTGlzdCIsInBhcmVudE5vZGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiZWwiLCJzdHJhdGVneSIsImNoaWxkIiwiaW5zZXJ0QWRqYWNlbnRIVE1MIiwibm9kZVR5cGUiLCJzZXRDU1NWYWwiLCJ2YWwiLCJwYXJzZUNTU1ZhbCIsInN0YXJ0TmV4dEFuaW1hdGlvbkluUSIsImFuaW1PYmoiLCJyZW1vdmVGcm9tUSIsImluZGV4IiwibmV4dEFuaW0iLCJxIiwic3BsaWNlIiwiYW5pbWF0ZSIsInByb3BzIiwiZHVyYXRpb24iLCJlYXNpbmciLCJjb21wbGV0ZSIsInNldEFuaW1hdGlvblZhbHVlIiwiZ3VhcmFudGVlZE5leHQiLCJoYXNPcHRpb25zIiwiZnJvbSIsInRvIiwic3RhcnQiLCJwcm9ncmVzcyIsInN0ZXAiLCJzcGVjaWFsRWFzaW5nIiwicHVzaCIsImNzcyIsInRpbWVOb3ciLCJlbmQiLCJwZXJjZW50IiwiZnJvbVZhbCIsInRvVmFsIiwiZWFzZWRWYWwiLCJ0aW1lU3RhcnQiLCJmcmFtZSIsImVsYXBzZWQiLCJxUG9zIiwicU9iaiIsInN0b3AiLCJtYXgiLCJwYXJzZUZsb2F0IiwicG9zIiwic3BlYWNpYWxFYXNpbmciLCJzdGFydFRpbWUiLCJjbGVhclEiLCJqdW1wVG9FbmQiLCJlbGVtZW50SXNWaXNpYmxlIiwiZ2V0Q2xpZW50UmVjdHMiLCJiYXNlIiwiZWxlbWVudHMiLCJlbG1zIiwiaW5uZXJIVE1MIiwiY2hpbGRyZW4iLCJzZWxmIiwib24iLCJldmVudE5hbWUiLCJoYW5kbGVyIiwiZXZlbnROYW1lTGVuZ3RoIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwiYXR0YWNoRXZlbnQiLCJvZmYiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25lIiwib25lRXZlbnROYW1lIiwib25lSGFuZGxlciIsInRyaWdnZXIiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJmaXJlRXZlbnQiLCJhcHBlbmQiLCJwcmVwZW5kIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyZW1vdmUiLCJyZW1vdmVDaGlsZCIsInVud3JhcCIsInBhcmVudHMiLCJwYXJlbnQiLCJmaXJzdENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwid3JhcEFsbCIsIndyYXBwZXJIVE1MIiwibm9kZXMiLCJ3cmFwcGVyIiwiZGVlcGVzdCIsInByZXZpb3VzU2libGluZyIsImNoaWxkTm9kZXMiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwid3JhcElubmVyIiwiY29udGVudHMiLCJ3cmFwIiwic3R5bGVzIiwiY3B0U3R5bGUiLCJnZXRDcHRTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJjdXJyZW50U3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiaGFzQ2xhc3MiLCJjbGFzc05hbWUiLCJjbGFzc05hbWVQcmVwYXJlZCIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiaW5kZXhPZiIsImFkZENsYXNzIiwiY2xhc3NlcyIsImN1ciIsImN1clZhbHVlIiwiY2xhenoiLCJmaW5hbFZhbHVlIiwic3VwcG9ydENsYXNzTGlzdCIsImVsbUNsYXNzTGlzdCIsImFkZCIsInJlbW92ZUNsYXNzIiwiaGlkZSIsImRpc3BsYXkiLCJzaG93IiwiYXR0ciIsImF0dHJOYW1lIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0ciIsInJlbW92ZUF0dHJpYnV0ZSIsIm9mZnNldCIsInJlY3QiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwidG9wIiwibGVmdCIsInBvc2l0aW9uIiwib2Zmc2V0VG9wIiwib2Zmc2V0TGVmdCIsImZpcnN0IiwiZXEiLCJsYXN0IiwiZmluZCIsImNoIiwiaXMiLCJjaGlsZHMiLCJqdW1wIiwiSU5TVEFOQ0VTIiwiX3RhcmdldHMiLCJfaW5zdGFuY2VQcm9wZXJ0eVN0cmluZyIsImluc3RhbmNlIiwiYXJnTGVuIiwiUExVR0lOIiwiX3BsdWdpbiIsIl9wbHVnaW5zR2xvYmFscyIsIl9wbHVnaW5zQXV0b1VwZGF0ZUxvb3AiLCJfcGx1Z2luc0V4dGVuc2lvbnMiLCJfcGx1Z2luc09wdGlvbnMiLCJwb3NzaWJsZVRlbXBsYXRlVHlwZXMiLCJyZXN0cmljdGVkU3RyaW5nc1NwbGl0IiwicmVzdHJpY3RlZFN0cmluZ3NQb3NzaWJpbGl0aWVzU3BsaXQiLCJjbGFzc05hbWVBbGxvd2VkVmFsdWVzIiwibnVtYmVyQWxsb3dlZFZhbHVlcyIsImJvb2xlYW5OdWxsQWxsb3dlZFZhbHVlcyIsImJvb2xlYW5UcnVlVGVtcGxhdGUiLCJib29sZWFuRmFsc2VUZW1wbGF0ZSIsImNhbGxiYWNrVGVtcGxhdGUiLCJ1cGRhdGVPbkxvYWRUZW1wbGF0ZSIsImluaGVyaXRlZEF0dHJzVGVtcGxhdGUiLCJyZXNpemVBbGxvd2VkVmFsdWVzIiwib3ZlcmZsb3dCZWhhdmlvckFsbG93ZWRWYWx1ZXMiLCJzY3JvbGxiYXJzVmlzaWJpbGl0eUFsbG93ZWRWYWx1ZXMiLCJzY3JvbGxiYXJzQXV0b0hpZGVBbGxvd2VkVmFsdWVzIiwib3B0aW9uc0RlZmF1bHRzQW5kVGVtcGxhdGUiLCJyZXNpemUiLCJzaXplQXV0b0NhcGFibGUiLCJjbGlwQWx3YXlzIiwibm9ybWFsaXplUlRMIiwicGFkZGluZ0Fic29sdXRlIiwiYXV0b1VwZGF0ZSIsImF1dG9VcGRhdGVJbnRlcnZhbCIsInVwZGF0ZU9uTG9hZCIsIm5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZCIsInNob3dOYXRpdmVTY3JvbGxiYXJzIiwiaW5pdGlhbGl6ZSIsIm92ZXJmbG93QmVoYXZpb3IiLCJzY3JvbGxiYXJzIiwidmlzaWJpbGl0eSIsImF1dG9IaWRlIiwiYXV0b0hpZGVEZWxheSIsImRyYWdTY3JvbGxpbmciLCJjbGlja1Njcm9sbGluZyIsInRvdWNoU3VwcG9ydCIsInNuYXBIYW5kbGUiLCJ0ZXh0YXJlYSIsImR5bldpZHRoIiwiZHluSGVpZ2h0IiwiaW5oZXJpdGVkQXR0cnMiLCJjYWxsYmFja3MiLCJvbkluaXRpYWxpemVkIiwib25Jbml0aWFsaXphdGlvbldpdGhkcmF3biIsIm9uRGVzdHJveWVkIiwib25TY3JvbGxTdGFydCIsIm9uU2Nyb2xsIiwib25TY3JvbGxTdG9wIiwib25PdmVyZmxvd0NoYW5nZWQiLCJvbk92ZXJmbG93QW1vdW50Q2hhbmdlZCIsIm9uRGlyZWN0aW9uQ2hhbmdlZCIsIm9uQ29udGVudFNpemVDaGFuZ2VkIiwib25Ib3N0U2l6ZUNoYW5nZWQiLCJvblVwZGF0ZWQiLCJjb252ZXJ0IiwidGVtcGxhdGUiLCJyZWN1cnNpdmUiLCJ2YWxUeXBlIiwiX2RlZmF1bHRzIiwiX3RlbXBsYXRlIiwiX3ZhbGlkYXRlIiwid3JpdGVFcnJvcnMiLCJkaWZmT2JqIiwidmFsaWRhdGVkT3B0aW9ucyIsInZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZCIsIm9iamVjdENvcHkiLCJpc0VtcHR5T2JqIiwiY2hlY2tPYmplY3RQcm9wcyIsImRhdGEiLCJkaWZmRGF0YSIsInByZXZQcm9wTmFtZSIsImlzVmFsaWQiLCJpc0RpZmYiLCJ0ZW1wbGF0ZVZhbHVlIiwidGVtcGxhdGVWYWx1ZVR5cGUiLCJ0ZW1wbGF0ZUlzQ29tcGxleCIsInRlbXBsYXRlVHlwZXMiLCJkYXRhRGlmZlZhbHVlIiwiZGF0YVZhbHVlIiwiZGF0YVZhbHVlVHlwZSIsInByb3BQcmVmaXgiLCJlcnJvciIsImVycm9yUG9zc2libGVUeXBlcyIsImVycm9yUmVzdHJpY3RlZFN0cmluZ3MiLCJyZXN0cmljdGVkU3RyaW5nVmFsdWVzU3BsaXQiLCJyZXN0cmljdGVkU3RyaW5nVmFsdWVzUG9zc2liaWxpdGllc1NwbGl0IiwiaXNSZXN0cmljdGVkVmFsdWUiLCJtYWluUG9zc2liaWxpdHkiLCJjdXJyVHlwZSIsImoiLCJjb25zb2xlIiwid2FybiIsIkpTT04iLCJzdHJpbmdpZnkiLCJfZGVmYXVsdCIsIl9wcmVwYXJlZCIsImluaXRPdmVybGF5U2Nyb2xsYmFyc1N0YXRpY3MiLCJPdmVybGF5U2Nyb2xsYmFyc0dsb2JhbHMiLCJPdmVybGF5U2Nyb2xsYmFyc0F1dG9VcGRhdGVMb29wIiwiZGVmYXVsdE9wdGlvbnMiLCJfYmFzZSIsInN0ck92ZXJmbG93Iiwic3RySGlkZGVuIiwic3RyU2Nyb2xsIiwiYm9keUVsZW1lbnQiLCJzY3JvbGxiYXJEdW1teUVsZW1lbnQiLCJzY3JvbGxiYXJEdW1teUVsZW1lbnQwIiwiZHVtbXlDb250YWluZXJDaGlsZCIsIm5hdGl2ZVNjcm9sbGJhclNpemUiLCJjYWxjTmF0aXZlU2Nyb2xsYmFyU2l6ZSIsIm5hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQiLCJtc2llIiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJzdHJJbmRleE9mIiwic3RyU3ViU3RyaW5nIiwidHJpZGVudCIsImVkZ2UiLCJydiIsInBhcnNlSW50RnVuYyIsInBhcnNlSW50IiwiYXV0b1VwZGF0ZUxvb3AiLCJhdXRvVXBkYXRlUmVjb21tZW5kZWQiLCJuYXRpdmVTY3JvbGxiYXJTdHlsaW5nIiwiZXgiLCJvdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplIiwiY3NzQ2FsYyIsInJlc3RyaWN0ZWRNZWFzdXJpbmciLCJzY3JvbGxTaXplIiwiaCIsInNjcm9sbFNpemUyIiwicnRsU2Nyb2xsQmVoYXZpb3IiLCJkdW1teUNvbnRhaW5lck9mZnNldCIsImR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXQiLCJkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0QWZ0ZXJTY3JvbGwiLCJzdXBwb3J0VHJhbnNmb3JtIiwic3VwcG9ydFRyYW5zaXRpb24iLCJzdXBwb3J0UGFzc2l2ZUV2ZW50cyIsInN1cHBvcnRzUGFzc2l2ZSIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic3VwcG9ydFJlc2l6ZU9ic2VydmVyIiwic3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXIiLCJ3aW5kb3dXaWR0aCIsIndpbmRvd0hlaWdodCIsIndpbmRvd0RwciIsImdldFdpbmRvd0RQUiIsIm9uUmVzaXplIiwibmV3VyIsIm5ld0giLCJkZWx0YVciLCJkZWx0YUgiLCJkZWx0YVdSYXRpbyIsInJvdW5kIiwiZGVsdGFIUmF0aW8iLCJhYnNEZWx0YVciLCJhYnNEZWx0YUgiLCJhYnNEZWx0YVdSYXRpbyIsImFic0RlbHRhSFJhdGlvIiwibmV3RFBSIiwiZGVsdGFJc0JpZ2dlciIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlSXNCaWdnZXJUaGFuT25lIiwiZHByQ2hhbmdlZCIsImlzWm9vbSIsIm9sZFNjcm9sbGJhclNpemUiLCJuZXdTY3JvbGxiYXJTaXplIiwidXBkYXRlIiwidmFsT25lIiwidmFsVHdvIiwiYWJzVmFsT25lIiwiYWJzVmFsVHdvIiwiZERQSSIsInNjcmVlbiIsImRldmljZVhEUEkiLCJzRFBJIiwibG9naWNhbFhEUEkiLCJkZXZpY2VQaXhlbFJhdGlvIiwibWVhc3VyZUVsZW1lbnQiLCJnbG9iYWxzIiwiX2luQXJyYXkiLCJfZ2V0Tm93IiwiX3N0ckF1dG9VcGRhdGUiLCJfc3RyQXV0b1VwZGF0ZUludGVydmFsIiwiX3N0ckxlbmd0aCIsIl9sb29waW5nSW5zdGFuY2VzIiwiX2xvb3BpbmdJbnN0YW5jZXNJbnRlcnZhbENhY2hlIiwiX2xvb3BJc0FjdGl2ZSIsIl9sb29wSW50ZXJ2YWxEZWZhdWx0IiwiX2xvb3BJbnRlcnZhbCIsIl9sb29wVGltZU9sZCIsIl9sb29wSUQiLCJsb29wIiwidGltZU5ldyIsInRpbWVEZWx0YSIsImxvd2VzdEludGVydmFsIiwiaW5zdGFuY2VPcHRpb25zIiwiaW5zdGFuY2VBdXRvVXBkYXRlQWxsb3dlZCIsImluc3RhbmNlQXV0b1VwZGF0ZUludGVydmFsIiwibWluIiwiT3ZlcmxheVNjcm9sbGJhcnNJbnN0YW5jZSIsInBsdWdpblRhcmdldEVsZW1lbnQiLCJleHRlbnNpb25zIiwiX2ZyYW1ld29ya1Byb3RvIiwiaXNIVE1MRWxlbWVudCIsImluc3QiLCJfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZCIsIl9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplIiwiX3J0bFNjcm9sbEJlaGF2aW9yIiwiX2F1dG9VcGRhdGVSZWNvbW1lbmRlZCIsIl9tc2llVmVyc2lvbiIsIl9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nIiwiX2Nzc0NhbGMiLCJfbmF0aXZlU2Nyb2xsYmFyU2l6ZSIsIl9zdXBwb3J0VHJhbnNpdGlvbiIsIl9zdXBwb3J0VHJhbnNmb3JtIiwiX3N1cHBvcnRQYXNzaXZlRXZlbnRzIiwiX3N1cHBvcnRSZXNpemVPYnNlcnZlciIsIl9zdXBwb3J0TXV0YXRpb25PYnNlcnZlciIsIl9yZXN0cmljdGVkTWVhc3VyaW5nIiwiX2luaXRpYWxpemVkIiwiX2Rlc3Ryb3llZCIsIl9pc1RleHRhcmVhIiwiX2lzQm9keSIsIl9kb2N1bWVudE1peGVkIiwiX2RvbUV4aXN0cyIsIl9pc0JvcmRlckJveCIsIl9zaXplQXV0b09ic2VydmVyQWRkZWQiLCJfcGFkZGluZ1giLCJfcGFkZGluZ1kiLCJfYm9yZGVyWCIsIl9ib3JkZXJZIiwiX21hcmdpblgiLCJfbWFyZ2luWSIsIl9pc1JUTCIsIl9zbGVlcGluZyIsIl9jb250ZW50Qm9yZGVyU2l6ZSIsIl9zY3JvbGxIb3Jpem9udGFsSW5mbyIsIl9zY3JvbGxWZXJ0aWNhbEluZm8iLCJfdmlld3BvcnRTaXplIiwiX25hdGl2ZVNjcm9sbGJhck1pblNpemUiLCJfc3RyTWludXNIaWRkZW4iLCJfc3RyTWFyZ2luTWludXMiLCJfc3RyUGFkZGluZ01pbnVzIiwiX3N0ckJvcmRlck1pbnVzIiwiX3N0clRvcCIsIl9zdHJSaWdodCIsIl9zdHJCb3R0b20iLCJfc3RyTGVmdCIsIl9zdHJNaW5NaW51cyIsIl9zdHJNYXhNaW51cyIsIl9zdHJXaWR0aCIsIl9zdHJIZWlnaHQiLCJfc3RyRmxvYXQiLCJfc3RyQXV0byIsIl9zdHJTeW5jIiwiX3N0clNjcm9sbCIsIl9zdHJIdW5kcmVkUGVyY2VudCIsIl9zdHJYIiwiX3N0clkiLCJfc3RyRG90IiwiX3N0clNjcm9sbGJhciIsIl9zdHJNaW51c0hvcml6b250YWwiLCJfc3RyTWludXNWZXJ0aWNhbCIsIl9zdHJNb3VzZVRvdWNoRG93bkV2ZW50IiwiX3N0ck1vdXNlVG91Y2hVcEV2ZW50IiwiX3N0ck1vdXNlVG91Y2hNb3ZlRXZlbnQiLCJfc3RyTW91c2VFbnRlciIsIl9zdHJNb3VzZUxlYXZlIiwiX3N0cktleURvd25FdmVudCIsIl9zdHJLZXlVcEV2ZW50IiwiX3N0clNlbGVjdFN0YXJ0RXZlbnQiLCJfc3RyVHJhbnNpdGlvbkVuZEV2ZW50IiwiX3N0clJlc2l6ZU9ic2VydmVyUHJvcGVydHkiLCJfY2Fzc05hbWVzUHJlZml4IiwiX2NsYXNzTmFtZUhUTUxFbGVtZW50IiwiX2NsYXNzTmFtZUhvc3RFbGVtZW50IiwiX2NsYXNzTmFtZUhvc3RFbGVtZW50Rm9yZWlnbiIsIl9jbGFzc05hbWVIb3N0VGV4dGFyZWFFbGVtZW50IiwiX2NsYXNzTmFtZUhvc3RTY3JvbGxiYXJIb3Jpem9udGFsSGlkZGVuIiwiX2NsYXNzTmFtZUhvc3RTY3JvbGxiYXJWZXJ0aWNhbEhpZGRlbiIsIl9jbGFzc05hbWVIb3N0VHJhbnNpdGlvbiIsIl9jbGFzc05hbWVIb3N0UlRMIiwiX2NsYXNzTmFtZUhvc3RSZXNpemVEaXNhYmxlZCIsIl9jbGFzc05hbWVIb3N0U2Nyb2xsaW5nIiwiX2NsYXNzTmFtZUhvc3RPdmVyZmxvdyIsIl9jbGFzc05hbWVIb3N0T3ZlcmZsb3dYIiwiX2NsYXNzTmFtZUhvc3RPdmVyZmxvd1kiLCJfY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50IiwiX2NsYXNzTmFtZVRleHRhcmVhQ292ZXJFbGVtZW50IiwiX2NsYXNzTmFtZVBhZGRpbmdFbGVtZW50IiwiX2NsYXNzTmFtZVZpZXdwb3J0RWxlbWVudCIsIl9jbGFzc05hbWVWaWV3cG9ydE5hdGl2ZVNjcm9sbGJhcnNJbnZpc2libGUiLCJfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQiLCJfY2xhc3NOYW1lQ29udGVudEVsZW1lbnQiLCJfY2xhc3NOYW1lQ29udGVudEFycmFuZ2VFbGVtZW50IiwiX2NsYXNzTmFtZUNvbnRlbnRHbHVlRWxlbWVudCIsIl9jbGFzc05hbWVTaXplQXV0b09ic2VydmVyRWxlbWVudCIsIl9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQiLCJfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRWxlbWVudCIsIl9jbGFzc05hbWVSZXNpemVPYnNlcnZlckl0ZW1GaW5hbEVsZW1lbnQiLCJfY2xhc3NOYW1lVGV4dEluaGVyaXQiLCJfY2xhc3NOYW1lU2Nyb2xsYmFyIiwiX2NsYXNzTmFtZVNjcm9sbGJhclRyYWNrIiwiX2NsYXNzTmFtZVNjcm9sbGJhclRyYWNrT2ZmIiwiX2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZSIsIl9jbGFzc05hbWVTY3JvbGxiYXJIYW5kbGVPZmYiLCJfY2xhc3NOYW1lU2Nyb2xsYmFyVW51c2FibGUiLCJfY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGRlbiIsIl9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXIiLCJfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplIiwiX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZUIiLCJfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplSCIsIl9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVWIiwiX2NsYXNzTmFtZVNjcm9sbGJhckhvcml6b250YWwiLCJfY2xhc3NOYW1lU2Nyb2xsYmFyVmVydGljYWwiLCJfY2xhc3NOYW1lRHJhZ2dpbmciLCJfY2xhc3NOYW1lVGhlbWVOb25lIiwiX2NsYXNzTmFtZXNEeW5hbWljRGVzdHJveSIsIl9jYWxsYmFja3NJbml0UWV1ZXVlIiwiX3ZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0IiwiX2RlZmF1bHRPcHRpb25zIiwiX2N1cnJlbnRPcHRpb25zIiwiX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMiLCJfZXh0ZW5zaW9ucyIsIl9leHRlbnNpb25zUHJpdmF0ZU1ldGhvZHMiLCJfbGFzdFVwZGF0ZVRpbWUiLCJfc3dhbGxvd2VkVXBkYXRlSGludHMiLCJfc3dhbGxvd2VkVXBkYXRlVGltZW91dCIsIl9zd2FsbG93VXBkYXRlTGFnIiwiX3VwZGF0ZU9uTG9hZEV2ZW50TmFtZSIsIl91cGRhdGVPbkxvYWRFbG1zIiwiX3dpbmRvd0VsZW1lbnQiLCJfZG9jdW1lbnRFbGVtZW50IiwiX2h0bWxFbGVtZW50IiwiX2JvZHlFbGVtZW50IiwiX3RhcmdldEVsZW1lbnQiLCJfaG9zdEVsZW1lbnQiLCJfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQiLCJfc2l6ZU9ic2VydmVyRWxlbWVudCIsIl9wYWRkaW5nRWxlbWVudCIsIl92aWV3cG9ydEVsZW1lbnQiLCJfY29udGVudEVsZW1lbnQiLCJfY29udGVudEFycmFuZ2VFbGVtZW50IiwiX2NvbnRlbnRHbHVlRWxlbWVudCIsIl90ZXh0YXJlYUNvdmVyRWxlbWVudCIsIl9zY3JvbGxiYXJDb3JuZXJFbGVtZW50IiwiX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50IiwiX3Njcm9sbGJhckhvcml6b250YWxUcmFja0VsZW1lbnQiLCJfc2Nyb2xsYmFySG9yaXpvbnRhbEhhbmRsZUVsZW1lbnQiLCJfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50IiwiX3Njcm9sbGJhclZlcnRpY2FsVHJhY2tFbGVtZW50IiwiX3Njcm9sbGJhclZlcnRpY2FsSGFuZGxlRWxlbWVudCIsIl93aW5kb3dFbGVtZW50TmF0aXZlIiwiX2RvY3VtZW50RWxlbWVudE5hdGl2ZSIsIl90YXJnZXRFbGVtZW50TmF0aXZlIiwiX2hvc3RFbGVtZW50TmF0aXZlIiwiX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50TmF0aXZlIiwiX3NpemVPYnNlcnZlckVsZW1lbnROYXRpdmUiLCJfcGFkZGluZ0VsZW1lbnROYXRpdmUiLCJfdmlld3BvcnRFbGVtZW50TmF0aXZlIiwiX2NvbnRlbnRFbGVtZW50TmF0aXZlIiwiX2hvc3RTaXplQ2FjaGUiLCJfY29udGVudFNjcm9sbFNpemVDYWNoZSIsIl9hcnJhbmdlQ29udGVudFNpemVDYWNoZSIsIl9oYXNPdmVyZmxvd0NhY2hlIiwiX2hpZGVPdmVyZmxvd0NhY2hlIiwiX3dpZHRoQXV0b0NhY2hlIiwiX2hlaWdodEF1dG9DYWNoZSIsIl9jc3NCb3hTaXppbmdDYWNoZSIsIl9jc3NQYWRkaW5nQ2FjaGUiLCJfY3NzQm9yZGVyQ2FjaGUiLCJfY3NzTWFyZ2luQ2FjaGUiLCJfY3NzRGlyZWN0aW9uQ2FjaGUiLCJfY3NzRGlyZWN0aW9uRGV0ZWN0ZWRDYWNoZSIsIl9wYWRkaW5nQWJzb2x1dGVDYWNoZSIsIl9jbGlwQWx3YXlzQ2FjaGUiLCJfY29udGVudEdsdWVTaXplQ2FjaGUiLCJfb3ZlcmZsb3dCZWhhdmlvckNhY2hlIiwiX292ZXJmbG93QW1vdW50Q2FjaGUiLCJfaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NhY2hlIiwiX2F1dG9VcGRhdGVDYWNoZSIsIl9zaXplQXV0b0NhcGFibGVDYWNoZSIsIl9jb250ZW50RWxlbWVudFNjcm9sbFNpemVDaGFuZ2VEZXRlY3RlZENhY2hlIiwiX2hvc3RFbGVtZW50U2l6ZUNoYW5nZURldGVjdGVkQ2FjaGUiLCJfc2Nyb2xsYmFyc1Zpc2liaWxpdHlDYWNoZSIsIl9zY3JvbGxiYXJzQXV0b0hpZGVDYWNoZSIsIl9zY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmdDYWNoZSIsIl9zY3JvbGxiYXJzRHJhZ1Njcm9sbGluZ0NhY2hlIiwiX3Jlc2l6ZUNhY2hlIiwiX25vcm1hbGl6ZVJUTENhY2hlIiwiX2NsYXNzTmFtZUNhY2hlIiwiX29sZENsYXNzTmFtZSIsIl90ZXh0YXJlYUF1dG9XcmFwcGluZ0NhY2hlIiwiX3RleHRhcmVhSW5mb0NhY2hlIiwiX3RleHRhcmVhU2l6ZUNhY2hlIiwiX3RleHRhcmVhRHluSGVpZ2h0Q2FjaGUiLCJfdGV4dGFyZWFEeW5XaWR0aENhY2hlIiwiX2JvZHlNaW5TaXplQ2FjaGUiLCJfdXBkYXRlQXV0b0NhY2hlIiwiX211dGF0aW9uT2JzZXJ2ZXJIb3N0IiwiX211dGF0aW9uT2JzZXJ2ZXJDb250ZW50IiwiX211dGF0aW9uT2JzZXJ2ZXJIb3N0Q2FsbGJhY2siLCJfbXV0YXRpb25PYnNlcnZlckNvbnRlbnRDYWxsYmFjayIsIl9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCIsIl9tdXRhdGlvbk9ic2VydmVyQXR0cnNUZXh0YXJlYSIsIl9tdXRhdGlvbk9ic2VydmVyQXR0cnNIb3N0IiwiX2Rlc3Ryb3lFdmVudHMiLCJfdGV4dGFyZWFIYXNGb2N1cyIsIl9zY3JvbGxiYXJzQXV0b0hpZGVUaW1lb3V0SWQiLCJfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZVRpbWVvdXRJZCIsIl9zY3JvbGxiYXJzQXV0b0hpZGVEZWxheSIsIl9zY3JvbGxiYXJzQXV0b0hpZGVOZXZlciIsIl9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwiLCJfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSIsIl9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZSIsIl9zY3JvbGxiYXJzSGFuZGxlSG92ZXJlZCIsIl9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcyIsIl9yZXNpemVOb25lIiwiX3Jlc2l6ZUJvdGgiLCJfcmVzaXplSG9yaXpvbnRhbCIsIl9yZXNpemVWZXJ0aWNhbCIsInNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIiLCJlbGVtZW50IiwiZXZlbnROYW1lcyIsImxpc3RlbmVyIiwicGFzc2l2ZSIsImNvbGxlY3RlZCIsIm1ldGhvZCIsIm9uT2ZmIiwiZXZlbnRzIiwiYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIiLCJzZXR1cFJlc2l6ZU9ic2VydmVyIiwidGFyZ2V0RWxlbWVudCIsIm9uRWxlbWVudFJlc2l6ZWRDYWxsYmFjayIsInJlc2l6ZU9ic2VydmVyIiwic3RyQW5pbWF0aW9uU3RhcnRFdmVudCIsInN0ckNoaWxkTm9kZXMiLCJjb25zdFNjcm9sbCIsImdlbmVyYXRlRGl2Iiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiZGlyIiwic3R5bGUiLCJvYnNlcnZlckVsZW1lbnQiLCJzaHJpbmtFbGVtZW50IiwiZXhwYW5kRWxlbWVudCIsImV4cGFuZEVsZW1lbnRDaGlsZCIsIndpZHRoQ2FjaGUiLCJoZWlnaHRDYWNoZSIsImlzRGlydHkiLCJyQUZJZCIsImN1cnJXaWR0aCIsImN1cnJIZWlnaHQiLCJmYWN0b3IiLCJyZXNldCIsIm9uUmVzaXplZCIsImV4cGFuZENoaWxkQ1NTIiwib2JzZXJ2ZXJFbGVtZW50Q1NTIiwic2V0VG9wUmlnaHRCb3R0b21MZWZ0IiwiaXNJRSIsImZpbmRGaXJzdCIsIm9ubG9hZCIsInduZCIsImNvbnRlbnREb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiZGlyZWN0aW9uQ2hhbmdlZCIsInNjcm9sbExlZnRWYWx1ZSIsInJlc2l6ZU9ic2VydmVyT2JqIiwiZGlzY29ubmVjdCIsImNyZWF0ZU11dGF0aW9uT2JzZXJ2ZXJzIiwibXV0YXRpb25PYnNlcnZlckNvbnRlbnRMYWciLCJtdXRhdGlvbk9ic2VydmVyIiwiY29udGVudExhc3RVcGRhdGUiLCJtdXRhdGlvblRhcmdldCIsIm11dGF0aW9uQXR0ck5hbWUiLCJtdXRhdGlvbklzQ2xhc3MiLCJvbGRNdXRhdGlvblZhbCIsIm5ld0NsYXNzVmFsIiwiaG9zdENsYXNzTmFtZVJlZ2V4IiwiY29udGVudFRpbWVvdXQiLCJzaXplQXV0byIsImFjdGlvbiIsIm11dGF0aW9ucyIsImRvVXBkYXRlIiwiZG9VcGRhdGVGb3JjZSIsIm11dGF0aW9uIiwibXV0YXRlZEF0dHJzIiwiYXR0cmlidXRlTmFtZSIsIm9sZFZhbHVlIiwiY3JlYXRlSG9zdENsYXNzTmFtZVJlZ0V4cCIsImZpbHRlciIsImhvc3RDbGFzc05hbWVzQ2hhbmdlZCIsInVwZGF0ZVZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0IiwiaXNVbmtub3duTXV0YXRpb24iLCJ0ZXh0YXJlYVVwZGF0ZSIsImNvbm5lY3RNdXRhdGlvbk9ic2VydmVycyIsImF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVPbGRWYWx1ZSIsImF0dHJpYnV0ZUZpbHRlciIsInN1YnRyZWUiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwiZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzIiwiaG9zdE9uUmVzaXplZCIsImNoYW5nZWQiLCJob3N0U2l6ZSIsImNoZWNrQ2FjaGUiLCJfaG9zdFNpemVDaGFuZ2VkIiwiaG9zdE9uTW91c2VFbnRlciIsInJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUiLCJob3N0T25Nb3VzZUxlYXZlIiwiaG9zdE9uTW91c2VNb3ZlIiwiZG9jdW1lbnRPblNlbGVjdFN0YXJ0IiwidXBkYXRlT25Mb2FkQ2FsbGJhY2siLCJlbG0iLCJlYWNoVXBkYXRlT25Mb2FkIiwidXBkYXRlT25Mb2FkU2VsZWN0b3IiLCJfY29udGVudFNpemVDaGFuZ2VkIiwic2V0dXBIb3N0TW91c2VUb3VjaEV2ZW50cyIsImRlc3Ryb3kiLCJib2R5TWluU2l6ZUNoYW5nZWQiLCJib2R5TWluU2l6ZSIsInBhcnNlVG9aZXJvT3JOdW1iZXIiLCJvbGRDbGFzc05hbWVzIiwibmV3Q2xhc3NOYW1lcyIsImN1cnJDbGFzc2VzIiwib2xkQ2xhc3NlcyIsImRpZmYiLCJnZXRBcnJheURpZmZlcmVuY2VzIiwiaWR4IiwicmVnZXgiLCJtdXRhdGlvblR5cGUiLCJzdHJDbG9zZXN0IiwidXBkYXRlQXV0b0NvbnRlbnRTaXplQ2hhbmdlZCIsImNvbnRlbnRNZWFzdXJlRWxlbWVudCIsImdldENvbnRlbnRNZWFzdXJlRWxlbWVudCIsInRleHRhcmVhVmFsdWVMZW5ndGgiLCJzZXRDU1MiLCJmbG9hdCIsImJvZHlNaW5TaXplQyIsImNvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZSIsIm1lYW5pbmdmdWxBdHRyc0NoYW5nZWQiLCJjdXJyIiwiY2FjaGUiLCJjaGFuZ2VkQXR0cnMiLCJjaGVja3MiLCJfZWxlbSIsIl9hdHRycyIsImNoZWNrIiwiaXNTaXplQWZmZWN0aW5nQ1NTUHJvcGVydHkiLCJwcm9wZXJ0eU5hbWUiLCJmbGV4QmFzaXMiLCJhZmZlY3RpbmdQcm9wc1giLCJhZmZlY3RpbmdQcm9wc1hDb250ZW50Qm94IiwiYWZmZWN0aW5nUHJvcHNZIiwiYWZmZWN0aW5nUHJvcHNZQ29udGVudEJveCIsIl9zdHJTIiwiX3N0clZTIiwiY2hlY2tYIiwiY2hlY2tZIiwic2l6ZUlzQWZmZWN0ZWQiLCJjaGVja1Byb3BlcnR5TmFtZSIsImF0dHJzIiwidGFyZ2V0QXR0ciIsIndyYXBBdHRyT2ZmIiwibWluV2lkdGgiLCJtaW5IZWlnaHQiLCJkb01lYXN1cmUiLCJvcmlnV2lkdGgiLCJ3aWR0aCIsIm9yaWdIZWlnaHQiLCJoZWlnaHQiLCJfb3JpZ2luYWxXaWR0aCIsIl9vcmlnaW5hbEhlaWdodCIsIl9keW5hbWljV2lkdGgiLCJfZHluYW1pY0hlaWdodCIsInVwZGF0ZUhpbnRzIiwiX2ZvcmNlIiwiaG9zdFNpemVDaGFuZ2VkIiwiY29udGVudFNpemVDaGFuZ2VkIiwiZm9yY2UiLCJjaGFuZ2VkT3B0aW9ucyIsIl9jaGFuZ2VkT3B0aW9ucyIsInN3YWxsb3ciLCJkaXNwbGF5SXNIaWRkZW4iLCJleHRlbmREZWVwIiwiY2hlY2tDYWNoZUF1dG9Gb3JjZSIsImN1cnJTY3JvbGwiLCJjdXJyZW50UHJlcGFyZWRPcHRpb25zU2Nyb2xsYmFycyIsImN1cnJlbnRQcmVwYXJlZE9wdGlvbnNUZXh0YXJlYSIsInNjcm9sbGJhcnNWaXNpYmlsaXR5Iiwic2Nyb2xsYmFyc1Zpc2liaWxpdHlDaGFuZ2VkIiwic2Nyb2xsYmFyc0F1dG9IaWRlIiwic2Nyb2xsYmFyc0F1dG9IaWRlQ2hhbmdlZCIsInNjcm9sbGJhcnNDbGlja1Njcm9sbGluZyIsInNjcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NoYW5nZWQiLCJzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZyIsInNjcm9sbGJhcnNEcmFnU2Nyb2xsaW5nQ2hhbmdlZCIsImNsYXNzTmFtZUNoYW5nZWQiLCJyZXNpemVDaGFuZ2VkIiwicGFkZGluZ0Fic29sdXRlQ2hhbmdlZCIsImNsaXBBbHdheXNDaGFuZ2VkIiwic2l6ZUF1dG9DYXBhYmxlQ2hhbmdlZCIsImlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmciLCJpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCIsImF1dG9VcGRhdGVDaGFuZ2VkIiwib3ZlcmZsb3dCZWhhdmlvckNoYW5nZWQiLCJ0ZXh0YXJlYUR5bldpZHRoIiwidGV4dGFyZWFEeW5XaWR0aENoYW5nZWQiLCJ0ZXh0YXJlYUR5bkhlaWdodCIsInRleHRhcmVhRHluSGVpZ2h0Q2hhbmdlZCIsIm9sZFNpemUiLCJuZXdTaXplIiwidGV4dGFyZWFBdXRvV3JhcHBpbmciLCJ0ZXh0YXJlYUF1dG9XcmFwcGluZ0NoYW5nZWQiLCJjc3NEaXJlY3Rpb24iLCJjc3NEaXJlY3Rpb25DaGFuZ2VkIiwiYm94U2l6aW5nIiwiYm94U2l6aW5nQ2hhbmdlZCIsInBhZGRpbmciLCJnZXRUb3BSaWdodEJvdHRvbUxlZnRIb3N0Iiwic2l6ZUF1dG9PYnNlcnZlckVsZW1lbnRCQ1JlY3QiLCJpc1JUTExlZnQiLCJpc1JUTFJpZ2h0Iiwid2lkdGhBdXRvUmVzaXplRGV0ZWN0aW9uIiwid2lkdGhBdXRvT2JzZXJ2ZXJEZXRlY3Rpb24iLCJyaWdodCIsInRtcEN1cnJIb3N0V2lkdGgiLCJ0bXBDdXJyQ29udGVudEdsdWVXaWR0aCIsInRtcE5ld0hvc3RXaWR0aCIsIndpZHRoQXV0byIsIndpZHRoQXV0b0NoYW5nZWQiLCJ3YXNXaWR0aEF1dG8iLCJoZWlnaHRBdXRvIiwiYm90dG9tIiwiaGVpZ2h0QXV0b0NoYW5nZWQiLCJ3YXNIZWlnaHRBdXRvIiwidXBkYXRlQm9yZGVyWCIsInVwZGF0ZUJvcmRlclkiLCJib3JkZXIiLCJtYXJnaW4iLCJjb250ZW50RWxlbWVudENTUyIsImNvbnRlbnRHbHVlRWxlbWVudENTUyIsImdldEhvc3RTaXplIiwiZ2V0Vmlld3BvcnRTaXplIiwicGFkZGluZ0Fic29sdXRlWCIsInIiLCJwYWRkaW5nQWJzb2x1dGVZIiwicGFkZGluZ0VsZW1lbnRDU1MiLCJ0ZXh0YXJlYUNTUyIsInBhZGRpbmdWYWx1ZXMiLCJ0ZXh0YXJlYVNpemUiLCJ0ZXh0YXJlYVNpemVDaGFuZ2VkIiwidGV4dGFyZWFEeW5PcmlnU2l6ZSIsInN0ck92ZXJmbG93WCIsInN0ck92ZXJmbG93WSIsInN0clZpc2libGUiLCJ2aWV3cG9ydEVsZW1lbnRSZXNldENTUyIsInJlc2V0WFRtcCIsInlzIiwicmVzZXRCb3R0b21UbXAiLCJ4cyIsImNvbnRlbnRTaXplIiwiaG9zdEFic29sdXRlUmVjdFNpemUiLCJjb250ZW50R2x1ZVNpemUiLCJ0ZXh0YXJlYUNvdmVyQ1NTIiwic2V0Q29udGVudEdsdWVFbGVtZW50Q1NTZnVuY3Rpb24iLCJob3Jpem9udGFsIiwic2Nyb2xsYmFyVmFycyIsImdldFNjcm9sbGJhclZhcnMiLCJ3aCIsIl93X2giLCJzdHJXSCIsIl93aWR0aF9oZWlnaHQiLCJhdXRvU2l6ZSIsImJvcmRlclNpemUiLCJwYWRkaW5nU2l6ZSIsIm1hcmdpblNpemUiLCJ2aWV3cG9ydFNpemUiLCJjb250ZW50U2Nyb2xsU2l6ZSIsImhpZGVPdmVyZmxvd0ZvcmNlVGV4dGFyZWEiLCJwcmV2aW91c092ZXJmbG93QW1vdW50Iiwib3ZlcmZsb3dCZWhhdmlvcklzVlMiLCJvdmVyZmxvd0JlaGF2aW9ySXNWSCIsIm92ZXJmbG93QmVoYXZpb3JJc1MiLCJvdmVyZmxvd0Ftb3VudCIsImhhc092ZXJmbG93IiwiaGlkZU92ZXJmbG93IiwiY2FuU2Nyb2xsIiwidmlld3BvcnRSZWN0Iiwic2V0T3ZlcmZsb3dWYXJpYWJsZXMiLCJzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQiLCJ4eUkiLCJfeF95IiwieHkiLCJ3aWR0aEhlaWdodCIsInNjcm9sbE1heCIsIl9MZWZ0X1RvcCIsImZyYWN0aW9uYWxPdmVyZmxvd0Ftb3VudCIsImNoZWNrRnJhY3Rpb25hbE92ZXJmbG93QW1vdW50IiwiYm9yZGVyRGVzaWduIiwiY29udGVudEFycmFuZ2VFbGVtZW50Q1NTIiwiYXJyYW5nZUNvbnRlbnQiLCJhcnJhbmdlQ2hhbmdlZCIsInNldENvbnRlbnRFbGVtZW50Q1NTIiwic3RyRGlyZWN0aW9uIiwiaW52ZXJ0ZWRBdXRvU2l6ZSIsImFkZFJlbW92ZUNsYXNzIiwidmlld3BvcnRFbGVtZW50Q1NTIiwic2V0Vmlld3BvcnRDU1MiLCJYWSIsIl9YX1kiLCJlbGVtZW50U3R5bGUiLCJkdW1wIiwid2Via2l0VHJhbnNmb3JtIiwiZmxvYXRUbXAiLCJwb3NMZWZ0V2l0aG91dEZsb2F0IiwicG9zTGVmdFdpdGhGbG9hdCIsInRleHRhcmVhSW5mbyIsImdldFRleHRhcmVhSW5mbyIsInRleHRhcmVhUm93c0NoYW5nZWQiLCJfcm93cyIsImN1cnNvclJvdyIsIl9jdXJzb3JSb3ciLCJjdXJzb3JDb2wiLCJfY3Vyc29yQ29sdW1uIiwid2lkZXN0Um93IiwiX3dpZGVzdFJvdyIsImxhc3RSb3ciLCJsYXN0Q29sIiwiX2NvbHVtbnMiLCJjdXJzb3JQb3MiLCJfY3Vyc29yUG9zaXRpb24iLCJjdXJzb3JNYXgiLCJfY3Vyc29yTWF4IiwiY3Vyc29ySXNMYXN0UG9zaXRpb24iLCJ0ZXh0YXJlYVNjcm9sbEFtb3VudCIsInNjcm9sbGJhcnNWaXNpYmlsaXR5VmlzaWJsZSIsInNjcm9sbGJhcnNWaXNpYmlsaXR5SGlkZGVuIiwic2Nyb2xsYmFyc1Zpc2liaWxpdHlBdXRvIiwicmVmcmVzaFNjcm9sbGJhcnNWaXNpYmlsaXR5Iiwic2hvd1giLCJzaG93WSIsInJlZnJlc2hTY3JvbGxiYXJBcHBlYXJhbmNlIiwicmVmcmVzaFNjcm9sbGJhckhhbmRsZUxlbmd0aCIsInJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQiLCJyZWZyZXNoU2Nyb2xsYmFyc0ludGVyYWN0aXZlIiwiZGlzcGF0Y2hDYWxsYmFjayIsImlzUlRMIiwieFNjcm9sbGFibGUiLCJ5U2Nyb2xsYWJsZSIsImNsaXBwZWQiLCJ1cGRhdGVFbGVtZW50c09uTG9hZCIsImZvcmNlZCIsInNldE9wdGlvbnMiLCJuZXdPcHRpb25zIiwidmFsaWRhdGVkT3B0cyIsInNldHVwU3RydWN0dXJlRE9NIiwic3RyUGFyZW50IiwiY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJIb3N0IiwiY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50RnVsbCIsInRleHRhcmVhQ2xhc3MiLCJhZG9wdEF0dHJzIiwiYWRvcHRBdHRyc01hcCIsImFwcGx5QWRvcHRlZEF0dHJzIiwiYXBwbHlBZG9wdGVkQXR0cnNFbG0iLCJob3N0RWxlbWVudENsYXNzTmFtZXMiLCJob3N0RWxlbWVudENTUyIsInNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzIiwic2V0dXBTdHJ1Y3R1cmVFdmVudHMiLCJ0ZXh0YXJlYUtleURvd25SZXN0cmljdGVkS2V5Q29kZXMiLCJ0ZXh0YXJlYUtleURvd25LZXlDb2Rlc0xpc3QiLCJ0ZXh0YXJlYVVwZGF0ZUludGVydmFsSUQiLCJzY3JvbGxTdG9wVGltZW91dElkIiwic2Nyb2xsU3RvcERlbGF5Iiwic3RyRm9jdXMiLCJ1cGRhdGVUZXh0YXJlYSIsImRvQ2xlYXJJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ0ZXh0YXJlYU9uU2Nyb2xsIiwidGV4dGFyZWFPbkRyb3AiLCJ0ZXh0YXJlYU9uRm9jdXMiLCJ0ZXh0YXJlYU9uRm9jdXNvdXQiLCJ0ZXh0YXJlYU9uS2V5RG93biIsImtleUNvZGUiLCJzZXRJbnRlcnZhbCIsInRleHRhcmVhT25LZXlVcCIsImNvbnRlbnRPblRyYW5zaXRpb25FbmQiLCJ2aWV3cG9ydE9uU2Nyb2xsIiwibmF0aXZlT3ZlcmxheVNjcm9sbGJhcnNBcmVBY3RpdmUiLCJzZXR1cFNjcm9sbGJhcnNET00iLCJzZWxlY3RPckdlbmVyYXRlU2Nyb2xsYmFyRE9NIiwiaXNIb3Jpem9udGFsIiwic2Nyb2xsYmFyQ2xhc3NOYW1lIiwic2Nyb2xsYmFyIiwidHJhY2siLCJoYW5kbGUiLCJfc2Nyb2xsYmFyIiwiX3RyYWNrIiwiX2hhbmRsZSIsInJlc2V0U2Nyb2xsYmFyRE9NIiwiaG9yaXpvbnRhbEVsZW1lbnRzIiwidmVydGljYWxFbGVtZW50cyIsInNldHVwU2Nyb2xsYmFyRXZlbnRzIiwic2Nyb2xsYmFyVmFyc0luZm8iLCJfaW5mbyIsImluc2lkZUlGcmFtZSIsInNjcm9sbCIsInN0ckFjdGl2ZSIsInN0clNuYXBIYW5kbGUiLCJzY3JvbGxEdXJhdGlvbkZhY3RvciIsImluY3JlYXNlRGVjcmVhc2VTY3JvbGxBbW91bnRLZXlDb2RlcyIsInRyYWNrVGltZW91dCIsIm1vdXNlRG93blNjcm9sbCIsIm1vdXNlRG93bk9mZnNldCIsIm1vdXNlRG93bkludmVydGVkU2NhbGUiLCJnZXRQb2ludGVyUG9zaXRpb24iLCJnZXRQcmVwYXJlZFNjcm9sbGJhcnNPcHRpb24iLCJpbmNyZWFzZVRyYWNrU2Nyb2xsQW1vdW50IiwiZGVjcmVhc2VUcmFja1Njcm9sbEFtb3VudCIsImRvY3VtZW50S2V5RG93biIsImRvY3VtZW50S2V5VXAiLCJvbk1vdXNlVG91Y2hEb3duQ29udGludWUiLCJpc1RvdWNoRXZlbnQiLCJkb2N1bWVudERyYWdNb3ZlIiwidHJhY2tMZW5ndGgiLCJfdHJhY2tMZW5ndGgiLCJoYW5kbGVMZW5ndGgiLCJfaGFuZGxlTGVuZ3RoIiwic2Nyb2xsUmFuZ2UiLCJfbWF4U2Nyb2xsIiwic2Nyb2xsUmF3Iiwic2Nyb2xsRGVsdGFQZXJjZW50Iiwic2Nyb2xsRGVsdGEiLCJpc0Zpbml0ZSIsImRvY3VtZW50TW91c2VUb3VjaFVwIiwic2Nyb2xsU3RvcCIsIm1vdXNlSW5zaWRlSG9zdCIsImNsaWVudFgiLCJjbGllbnRZIiwib25IYW5kbGVNb3VzZVRvdWNoRG93biIsIm9uSGFuZGxlTW91c2VUb3VjaERvd25BY3Rpb24iLCJpc05hTiIsImdldEhvc3RFbGVtZW50SW52ZXJ0ZWRTY2FsZSIsIm9uVHJhY2tNb3VzZVRvdWNoRG93biIsInNjcm9sbERpc3RhbmNlIiwidHJhY2tPZmZzZXQiLCJfbGVmdF90b3AiLCJjdHJsS2V5IiwiaW5zdGFudFNjcm9sbCIsInNoaWZ0S2V5IiwiaW5zdGFudFNjcm9sbFRyYW5zaXRpb24iLCJpc0ZpcnN0SXRlcmF0aW9uIiwiZGVjcmVhc2VTY3JvbGwiLCJmaW5pc2hlZENvbmRpdGlvbiIsInNjcm9sbEFjdGlvbkZpbnNpc2hlZCIsInRyYW5zaXRpb24iLCJzY3JvbGxBY3Rpb25JbnN0YW50RmluaXNoZWQiLCJzY3JvbGxBY3Rpb24iLCJtb3VzZU9mZnNldCIsImhhbmRsZU9mZnNldCIsIl9oYW5kbGVPZmZzZXQiLCJfY3VycmVudFNjcm9sbCIsInNjcm9sbER1cmF0aW9uIiwidGltZW91dERlbGF5IiwiaW5zdGFudFNjcm9sbFBvc2l0aW9uIiwicnRsSXNOb3JtYWwiLCJkZWNyZWFzZVNjcm9sbENvbmRpdGlvbiIsInNjcm9sbE9iaiIsImFuaW1hdGlvbk9iaiIsIm9uVHJhY2tNb3VzZVRvdWNoRW50ZXIiLCJvblRyYWNrTW91c2VUb3VjaExlYXZlIiwib25TY3JvbGxiYXJNb3VzZVRvdWNoRG93biIsInNoYWxsQmVWaXNpYmxlIiwic2Nyb2xsYmFySGlkZGVuQ2xhc3NOYW1lIiwic2Nyb2xsYmFyRWxlbWVudCIsImRlbGF5ZnJlZSIsImFueUFjdGl2ZSIsImhhbmRsZUNTUyIsImRpZ2l0IiwiaGFuZGxlUmF0aW8iLCJmbG9vciIsIl9XaWR0aF9IZWlnaHQiLCJfaGFuZGxlTGVuZ3RoUmF0aW8iLCJzY3JvbGxPclRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJpc1JUTGlzSG9yaXpvbnRhbCIsInN0clRyYW5zbGF0ZUJyYWNlIiwic3RyVHJhbnNmb3JtIiwic3RyVHJhbnNpdGlvbiIsIm5hdGl2ZVNjcm9sbCIsImN1cnJlbnRTY3JvbGwiLCJoYW5kbGVUcmFja0RpZmYiLCJ0cmFuc2Zvcm1PZmZzZXQiLCJ0cmFuc2xhdGVWYWx1ZSIsIm1heFNjcm9sbCIsImdldFNjcm9sbFJhdGlvIiwiZ2V0SGFuZGxlT2Zmc2V0Iiwic2Nyb2xsUmF0aW8iLCJ1bnNuYXBwZWRTY3JvbGxSYXRpbyIsInNuYXBwZWRIYW5kbGVPZmZzZXQiLCJfY3VycmVudFNjcm9sbFJhdGlvIiwiZ2V0Q1NTVHJhbnNpdGlvblN0cmluZyIsIl9zbmFwcGVkSGFuZGxlT2Zmc2V0IiwiaXNUcmFjayIsImVsZW1lbnQxIiwiZWxlbWVudDIiLCJfbF90Iiwic2V0dXBTY3JvbGxiYXJDb3JuZXJET00iLCJzZXR1cFNjcm9sbGJhckNvcm5lckV2ZW50cyIsIm1vdXNlRG93blBvc2l0aW9uIiwibW91c2VEb3duU2l6ZSIsInJlY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXIiLCJwYWdlT2Zmc2V0IiwiZ2V0Q29vcmRpbmF0ZXMiLCJldmVudElzVHJ1c3RlZCIsInJlbGVhc2VDYXB0dXJlIiwic2NyZWVuWCIsInNjcmVlblkiLCJzZXRDYXB0dXJlIiwiYXJncyIsImRlcGVuZGVudCIsImV4dGVuc2lvbk9uTmFtZSIsImV4dCIsInN1YnN0ciIsInRhcmdldENTU09iamVjdCIsInByZWZpeCIsInplcm9YIiwiemVyb1kiLCJ0cmFuc2l0aW9uU3RyIiwiYXNzZW1ibGVkVmFsdWUiLCJyZWdFeHBTdHJpbmciLCJyZWdFeHBNYWluIiwiUmVnRXhwIiwicmVnRXhwVmFsaWRhdGUiLCJwcm9wZXJ0aWVzIiwic3RyUmVzdWx0IiwidmFsdWVBcnJheSIsInNwbGl0Q3NzU3R5bGVCeUNvbW1hIiwiJDEiLCJ3aXRoQ3VyckNsYXNzTmFtZU9wdGlvbiIsIndpdGhPbGRDbGFzc05hbWVPcHRpb24iLCJhcHBlbmRpeCIsImFwcGVuZENsYXNzZXMiLCJjb25kaXRpb24iLCJzdHJPd25lckRvY3VtZW50Iiwic3RySFRNTEVsZW1lbnQiLCJwYXJlbnRXaW5kb3ciLCJub2RlTmFtZSIsImExIiwiYTIiLCJrIiwidG9GbG9hdCIsIm51bSIsInRleHRhcmVhQ3Vyc29yUG9zaXRpb24iLCJzZWxlY3Rpb25TdGFydCIsInRleHRhcmVhVmFsdWUiLCJ0ZXh0YXJlYUxlbmd0aCIsInRleHRhcmVhUm93U3BsaXQiLCJ0ZXh0YXJlYUxhc3RSb3ciLCJ0ZXh0YXJlYUN1cnJlbnRDdXJzb3JSb3dTcGxpdCIsInRleHRhcmVhTGFzdENvbCIsInJvd0NvbHMiLCJjbGFzc2VzT3JBdHRycyIsImNvbnRlbnQiLCJzZWxlY3RQYXJlbnRPck9ubHlDaGlsZHJlbiIsIm9ubHlDaGlsZHJlbiIsInNlbGVjdFBhcmVudCIsImdldE9iamVjdFByb3BWYWwiLCJwYXRoIiwic3BsaXRzIiwic2V0T2JqZWN0UHJvcFZhbCIsInNwbGl0c0xlbmd0aCIsImV4dGVuZE9iaiIsImV4dGVuZE9ialJvb3QiLCJjdXJyZW50IiwiZG9BZGQiLCJzbGVlcCIsImF0dHJzQ2hhbmdlZCIsImNvbnRlbnRTaXplQyIsImlzU3RyaW5nIiwiZG9VcGRhdGVBdXRvIiwibXV0SG9zdCIsIm11dENvbnRlbnQiLCJ0YWtlUmVjb3JkcyIsIm9wdGlvbiIsImNoYW5nZWRPcHMiLCJleHROYW1lIiwicmVtb3ZlRXh0IiwicG9wIiwiY29vcmRpbmF0ZXMiLCJpbmZvWCIsImluZm9ZIiwibm9ybWFsaXplSW52ZXJ0Iiwibm9ybWFsaXplTmVnYXRlIiwic2Nyb2xsWCIsInNjcm9sbFhSYXRpbyIsIm1heFNjcm9sbFgiLCJyYXRpbyIsImhhbmRsZUxlbmd0aFJhdGlvIiwiaXNSVExOb3JtYWxpemVkIiwiY29vcmRpbmF0ZXNYQXhpc1Byb3BzIiwiY29vcmRpbmF0ZXNZQXhpc1Byb3BzIiwiY29vcmRpbmF0ZXNPcGVyYXRvcnMiLCJkdXJhdGlvbklzT2JqZWN0IiwiY29tcGxldGVDYWxsYmFjayIsImZpbmFsU2Nyb2xsIiwiZG9TY3JvbGxMZWZ0IiwiZG9TY3JvbGxUb3AiLCJhbmltYXRpb25PcHRpb25zIiwic3RyRW5kIiwic3RyQmVnaW4iLCJzdHJDZW50ZXIiLCJzdHJOZWFyZXN0Iiwic3RyQWx3YXlzIiwic3RyTmV2ZXIiLCJzdHJJZk5lZWRlZCIsInN0ckxlbmd0aCIsInNldHRpbmdzQXhpcyIsInNldHRpbmdzU2Nyb2xsIiwic2V0dGluZ3NCbG9jayIsInNldHRpbmdzTWFyZ2luIiwiZmluYWxFbGVtZW50IiwiZWxlbWVudE9ialNldHRpbmdzQXhpc1ZhbHVlcyIsImVsZW1lbnRPYmpTZXR0aW5nc0Jsb2NrVmFsdWVzIiwiZWxlbWVudE9ialNldHRpbmdzU2Nyb2xsVmFsdWVzIiwiY29vcmRpbmF0ZXNJc0VsZW1lbnRPYmoiLCJwb3NzaWJsZUVsZW1lbnQiLCJwb3NzaWJsZUVsZW1lbnRJc0pRdWVyeSIsInBvc3NpYmxlRWxlbWVudElzSFRNTEVsZW1lbnQiLCJ1cGRhdGVTY3JvbGxiYXJJbmZvcyIsInByb3h5Q29tcGxldGVDYWxsYmFjayIsImNoZWNrU2V0dGluZ3NTdHJpbmdWYWx1ZSIsImN1cnJWYWx1ZSIsImFsbG93ZWRWYWx1ZXMiLCJnZXRSYXdTY3JvbGwiLCJpc1giLCJjb29yZGluYXRlUHJvcHMiLCJnZXRGaW5hbFNjcm9sbCIsInJhd1Njcm9sbCIsIm9wZXJhdG9yIiwiYW1vdW50Iiwic2Nyb2xsSW5mbyIsIm11bHQiLCJpc1JUTGlzWCIsIm5vcm1hbGl6ZVNob3J0Y3V0cyIsInN0clJlcGxhY2UiLCJldmFsRnVuYyIsImV2YWwiLCJwb3NzaWJsZU9wZXJhdG9yIiwidG9GaXhlZCIsIm5vcm1hbGl6ZUlzUlRMaXNYIiwib3BlcmF0b3JDdXJyU2Nyb2xsIiwiaW52ZXJ0IiwibmVnYXRlIiwiZ2V0UGVyQXhpc1ZhbHVlIiwidmFsdWVJbnRlcm5hbFR5cGUiLCJkZWZhdWx0VmFsdWUiLCJyZXN1bHREZWZhdWx0IiwidmFsdWVUeXBlIiwidmFsdWVBcnJMZW5ndGgiLCJ2YWx1ZUFyckl0ZW0iLCJnZW5lcmF0ZU1hcmdpbiIsIm1hcmdpblRvcFJpZ2h0Qm90dG9tTGVmdEFycmF5IiwiY3VyclZhbHVlVHlwZSIsInZhbHVlRGlyZWN0aW9ucyIsImF4aXMiLCJibG9jayIsIm1hcmdpbkRlZmF1bHQiLCJtYXJnaW5UeXBlIiwibWFyZ2luTGVuZ3RoIiwidmlld3BvcnRTY3JvbGwiLCJ2aWV3cG9ydE9mZnNldCIsImVsZW1lbnRPZmZzZXQiLCJkb05vdFNjcm9sbCIsImVsZW1lbnRTY3JvbGxDb29yZGluYXRlcyIsIm1lYXN1cmluZ0VsbSIsInJhd0VsZW1lbnRTaXplIiwiZWxlbWVudFNpemUiLCJmaW5hbGl6ZUJsb2NrIiwidmFycyIsImx0IiwiYmxvY2tJc0VuZCIsImJsb2NrSXNDZW50ZXIiLCJibG9ja0lzTmVhcmVzdCIsInNjcm9sbE5ldmVyIiwic2Nyb2xsSWZOZWVkZWQiLCJ2cFNpemUiLCJ2cE9mZnNldCIsImVsU2l6ZSIsImVsT2Zmc2V0IiwiZGl2aWRlIiwiZWxlbWVudENlbnRlck9mZnNldCIsInZpZXdwb3J0Q2VudGVyT2Zmc2V0IiwiaXNJblZpZXciLCJwYXJhbTEiLCJwYXJhbTIiLCJwYXJhbTMiLCJnZXRFbGVtZW50cyIsImVsZW1lbnROYW1lIiwiaG9zdCIsInZpZXdwb3J0Iiwic2Nyb2xsYmFySG9yaXpvbnRhbCIsInNjcm9sbGJhclZlcnRpY2FsIiwic2Nyb2xsYmFyQ29ybmVyIiwiZ2V0U3RhdGUiLCJzdGF0ZVByb3BlcnR5IiwicHJlcGFyZSIsImV4dGVuZGVkIiwiY2hhbmdlUHJvcGVydHlOYW1lIiwiZGVzdHJveWVkIiwic2xlZXBpbmciLCJkb2N1bWVudE1peGVkIiwicHJpdmF0ZU1ldGhvZHMiLCJhZGRFeHQiLCJleHRlbnNpb25PcHRpb25zIiwicmVnaXN0ZXJlZEV4dGVuc2lvbk9iaiIsImV4dGVuc2lvbiIsImluc3RhbmNlQWRkZWQiLCJpbnN0YW5jZUNvbnRyYWN0IiwiY29udHJhY3RSZXN1bHQiLCJjb250cmFjdEZ1bGZpbGxlZCIsImV4dGVuc2lvbkZhY3RvcnkiLCJjb250cmFjdCIsImFkZGVkIiwiaW5zdGFuY2VSZW1vdmVkIiwicmVtb3ZlZCIsImNvbnN0cnVjdCIsImluaXRCb2R5U2Nyb2xsIiwiYm9keU1vdXNlVG91Y2hEb3duTGlzdGVuZXIiLCJhY3RpdmVFbGVtZW50IiwiZm9jdXMiLCJ2YWxpZCIsInBsdWdpblRhcmdldEVsZW1lbnRzIiwib3B0c0lzUGxhaW5PYmoiLCJuZXdEZWZhdWx0T3B0aW9ucyIsImN1cnJEZWZhdWx0T3B0aW9ucyIsIm9zSW5zdGFuY2UiLCJleHRlbnNpb25OYW1lIiwiZXh0TmFtZVR5cGVTdHJpbmciLCJmbiIsIm92ZXJsYXlTY3JvbGxiYXJzIiwiX2VsZW1lbnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0FBYUMsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBMkI7QUFDeEIsTUFBSSxJQUFKLEVBQ0lDLG1DQUFPLFlBQVk7QUFBRSxXQUFPRCxPQUFPLENBQUNELE1BQUQsRUFBU0EsTUFBTSxDQUFDRyxRQUFoQixFQUEwQkMsU0FBMUIsQ0FBZDtBQUFxRCxHQUFwRTtBQUFBLG9HQUFOLENBREosS0FFSyxFQUdEO0FBQ1AsQ0FQQSxFQU9DLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDLElBUDFDLEVBUUcsVUFBVUEsTUFBVixFQUFrQkYsUUFBbEIsRUFBNEJDLFNBQTVCLEVBQXVDO0FBQ25DOztBQUNBLE1BQUlF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QixDQUFOO0FBQW9DLFNBQXpFO0FBQ0EsZUFBTzY2QixTQUFQO0FBQ0gsT0FIRCxNQUtJLE9BQU83bkMsTUFBTSxDQUFDNm5DLFNBQUQsRUFBWWp6QyxPQUFaLENBQWI7QUFDUCxLQVJEO0FBU0g7O0FBQ0QsU0FBT29MLE1BQVA7QUFDSCxDQTU5TUosQ0FBRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9vdmVybGF5c2Nyb2xsYmFycy9qcy9PdmVybGF5U2Nyb2xsYmFycy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiBPdmVybGF5U2Nyb2xsYmFyc1xyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vS2luZ1NvcmEvT3ZlcmxheVNjcm9sbGJhcnNcclxuICpcclxuICogVmVyc2lvbjogMS4xMi4wXHJcbiAqXHJcbiAqIENvcHlyaWdodCBLaW5nU29yYSB8IFJlbmUgSGFhcy5cclxuICogaHR0cHM6Ly9naXRodWIuY29tL0tpbmdTb3JhXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuICogRGF0ZTogMDUuMDQuMjAyMFxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG4gICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBmYWN0b3J5KGdsb2JhbCwgZ2xvYmFsLmRvY3VtZW50LCB1bmRlZmluZWQpOyB9KTtcclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGdsb2JhbCwgZ2xvYmFsLmRvY3VtZW50LCB1bmRlZmluZWQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGZhY3RvcnkoZ2xvYmFsLCBnbG9iYWwuZG9jdW1lbnQsIHVuZGVmaW5lZCk7XHJcbn0odHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLFxyXG4gICAgZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG4gICAgICAgICd1c2Ugc3RyaWN0JztcclxuICAgICAgICB2YXIgUExVR0lOTkFNRSA9ICdPdmVybGF5U2Nyb2xsYmFycyc7XHJcbiAgICAgICAgdmFyIFRZUEVTID0ge1xyXG4gICAgICAgICAgICBvOiAnb2JqZWN0JyxcclxuICAgICAgICAgICAgZjogJ2Z1bmN0aW9uJyxcclxuICAgICAgICAgICAgYTogJ2FycmF5JyxcclxuICAgICAgICAgICAgczogJ3N0cmluZycsXHJcbiAgICAgICAgICAgIGI6ICdib29sZWFuJyxcclxuICAgICAgICAgICAgbjogJ251bWJlcicsXHJcbiAgICAgICAgICAgIHU6ICd1bmRlZmluZWQnLFxyXG4gICAgICAgICAgICB6OiAnbnVsbCdcclxuICAgICAgICAgICAgLy9kIDogJ2RhdGUnLFxyXG4gICAgICAgICAgICAvL2UgOiAnZXJyb3InLFxyXG4gICAgICAgICAgICAvL3IgOiAncmVnZXhwJyxcclxuICAgICAgICAgICAgLy95IDogJ3N5bWJvbCdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBMRVhJQ09OID0ge1xyXG4gICAgICAgICAgICBjOiAnY2xhc3MnLFxyXG4gICAgICAgICAgICBzOiAnc3R5bGUnLFxyXG4gICAgICAgICAgICBpOiAnaWQnLFxyXG4gICAgICAgICAgICBsOiAnbGVuZ3RoJyxcclxuICAgICAgICAgICAgcDogJ3Byb3RvdHlwZScsXHJcbiAgICAgICAgICAgIHRpOiAndGFiaW5kZXgnLFxyXG4gICAgICAgICAgICBvSDogJ29mZnNldEhlaWdodCcsXHJcbiAgICAgICAgICAgIGNIOiAnY2xpZW50SGVpZ2h0JyxcclxuICAgICAgICAgICAgc0g6ICdzY3JvbGxIZWlnaHQnLFxyXG4gICAgICAgICAgICBvVzogJ29mZnNldFdpZHRoJyxcclxuICAgICAgICAgICAgY1c6ICdjbGllbnRXaWR0aCcsXHJcbiAgICAgICAgICAgIHNXOiAnc2Nyb2xsV2lkdGgnLFxyXG4gICAgICAgICAgICBoT1A6ICdoYXNPd25Qcm9wZXJ0eScsXHJcbiAgICAgICAgICAgIGJDUjogJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBWRU5ET1JTID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy9odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L1ZlbmRvcl9QcmVmaXhcclxuICAgICAgICAgICAgdmFyIGpzQ2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgdmFyIGNzc0NhY2hlID0ge307XHJcbiAgICAgICAgICAgIHZhciBjc3NQcmVmaXhlcyA9IFsnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJywgJy1tcy0nXTtcclxuICAgICAgICAgICAgdmFyIGpzUHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNUyddO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmaXJzdExldHRlclRvVXBwZXIoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgX2Nzc1ByZWZpeGVzOiBjc3NQcmVmaXhlcyxcclxuICAgICAgICAgICAgICAgIF9qc1ByZWZpeGVzOiBqc1ByZWZpeGVzLFxyXG4gICAgICAgICAgICAgICAgX2Nzc1Byb3BlcnR5OiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjc3NDYWNoZVtuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0NhY2hlW0xFWElDT04uaE9QXShuYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwcGVyY2FzZWROYW1lID0gZmlyc3RMZXR0ZXJUb1VwcGVyKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbG1TdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpW0xFWElDT04uc107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdFBvc3NpYmlsaXRpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyVmVuZG9yV2l0aG91dERhc2hlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBjc3NQcmVmaXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyVmVuZG9yV2l0aG91dERhc2hlcyA9IGNzc1ByZWZpeGVzW2ldLnJlcGxhY2UoLy0vZywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQb3NzaWJpbGl0aWVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSwgLy90cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NQcmVmaXhlc1tpXSArIG5hbWUsIC8vLXdlYmtpdC10cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyVmVuZG9yV2l0aG91dERhc2hlcyArIHVwcGVyY2FzZWROYW1lLCAvL3dlYmtpdFRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0TGV0dGVyVG9VcHBlcihjdXJyVmVuZG9yV2l0aG91dERhc2hlcykgKyB1cHBlcmNhc2VkTmFtZSAvL1dlYmtpdFRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2ID0gMDsgdiA8IHJlc3VsdFBvc3NpYmlsaXRpZXNbTEVYSUNPTi5sXTsgdisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxtU3R5bGVbcmVzdWx0UG9zc2liaWxpdGllc1t2XV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFBvc3NpYmlsaXRpZXNbdl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNzc0NhY2hlW25hbWVdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2Nzc1Byb3BlcnR5VmFsdWU6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWVzLCBzdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHByb3BlcnR5ICsgJyAnICsgdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjc3NDYWNoZVtuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0NhY2hlW0xFWElDT04uaE9QXShuYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR1bW15U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVtMRVhJQ09OLnNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NzYmxlVmFsdWVzID0gdmFsdWVzLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXBhcmVkU3VmZml4ID0gc3VmZml4IHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHBvc3NibGVWYWx1ZXNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyB2IDwgVkVORE9SUy5fY3NzUHJlZml4ZXNbTEVYSUNPTi5sXTsgdisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wID0gdiA8IDAgPyBwb3NzYmxlVmFsdWVzW2ldIDogVkVORE9SUy5fY3NzUHJlZml4ZXNbdl0gKyBwb3NzYmxlVmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbXlTdHlsZS5jc3NUZXh0ID0gcHJvcGVydHkgKyAnOicgKyBwcm9wICsgcHJlcGFyZWRTdWZmaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHVtbXlTdHlsZVtMRVhJQ09OLmxdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2FjaGVbbmFtZV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBfanNBUEk6IGZ1bmN0aW9uIChuYW1lLCBpc0ludGVyZmFjZSwgZmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGpzQ2FjaGVbbmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghanNDYWNoZVtMRVhJQ09OLmhPUF0obmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gd2luZG93W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGpzUHJlZml4ZXNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IHdpbmRvd1soaXNJbnRlcmZhY2UgPyBqc1ByZWZpeGVzW2ldIDoganNQcmVmaXhlc1tpXS50b0xvd2VyQ2FzZSgpKSArIGZpcnN0TGV0dGVyVG9VcHBlcihuYW1lKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzQ2FjaGVbbmFtZV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgZmFsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIHZhciBDT01QQVRJQklMSVRZID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gd2luZG93U2l6ZSh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geCA/IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtMRVhJQ09OLmNXXSB8fCBkb2N1bWVudC5ib2R5W0xFWElDT04uY1ddIDogd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtMRVhJQ09OLmNIXSB8fCBkb2N1bWVudC5ib2R5W0xFWElDT04uY0hdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgdGhpc09iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFRZUEVTLmYpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkNhbid0IGJpbmQgZnVuY3Rpb24hXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwcm90byA9IExFWElDT04ucDtcclxuICAgICAgICAgICAgICAgIHZhciBhQXJncyA9IEFycmF5W3Byb3RvXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZk5PUCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICAgICAgICAgIHZhciBmQm91bmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QID8gdGhpcyA6IHRoaXNPYmosIGFBcmdzLmNvbmNhdChBcnJheVtwcm90b10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7IH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZ1bmNbcHJvdG9dKVxyXG4gICAgICAgICAgICAgICAgICAgIGZOT1BbcHJvdG9dID0gZnVuY1twcm90b107IC8vIEZ1bmN0aW9uLnByb3RvdHlwZSBkb2Vzbid0IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgIGZCb3VuZFtwcm90b10gPSBuZXcgZk5PUCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmQm91bmQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgd2luZG93IHdpZHRoLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcnxudW1iZXJ9IFRoZSBjdXJyZW50IHdpbmRvdyB3aWR0aCBpbiBwaXhlbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgd1c6IGJpbmQod2luZG93U2l6ZSwgMCwgdHJ1ZSksXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHdpbmRvdyBoZWlnaHQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfG51bWJlcn0gVGhlIGN1cnJlbnQgd2luZG93IGhlaWdodCBpbiBwaXhlbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgd0g6IGJpbmQod2luZG93U2l6ZSwgMCksXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBNdXRhdGlvbk9ic2VydmVyIE9iamVjdCBvciB1bmRlZmluZWQgaWYgbm90IHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtNdXRhdGlvbk9ic2VydmVyfCp8dW5kZWZpbmVkfSBUaGUgTXV0YXRpb25zT2JzZXJ2ZXIgT2JqZWN0IG9yIHVuZGVmaW5lZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgbU86IGJpbmQoVkVORE9SUy5fanNBUEksIDAsICdNdXRhdGlvbk9ic2VydmVyJywgdHJ1ZSksXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBSZXNpemVPYnNlcnZlciBPYmplY3Qgb3IgdW5kZWZpbmVkIGlmIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7TXV0YXRpb25PYnNlcnZlcnwqfHVuZGVmaW5lZH0gVGhlIFJlc2l6ZU9ic2VydmVyIE9iamVjdCBvciB1bmRlZmluZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHJPOiBiaW5kKFZFTkRPUlMuX2pzQVBJLCAwLCAnUmVzaXplT2JzZXJ2ZXInLCB0cnVlKSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIFJlcXVlc3RBbmltYXRpb25GcmFtZSBtZXRob2Qgb3IgaXQncyBjb3JyZXNwb25kaW5nIHBvbHlmaWxsLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp8RnVuY3Rpb259IFRoZSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbWV0aG9kIG9yIGl0J3MgY29ycmVzcG9uZGluZyBwb2x5ZmlsbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgckFGOiBiaW5kKFZFTkRPUlMuX2pzQVBJLCAwLCAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJywgZmFsc2UsIGZ1bmN0aW9uIChmdW5jKSB7IHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmdW5jLCAxMDAwIC8gNjApOyB9KSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIENhbmNlbEFuaW1hdGlvbkZyYW1lIG1ldGhvZCBvciBpdCdzIGNvcnJlc3BvbmRpbmcgcG9seWZpbGwuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7KnxGdW5jdGlvbn0gVGhlIENhbmNlbEFuaW1hdGlvbkZyYW1lIG1ldGhvZCBvciBpdCdzIGNvcnJlc3BvbmRpbmcgcG9seWZpbGwuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGNBRjogYmluZChWRU5ET1JTLl9qc0FQSSwgMCwgJ2NhbmNlbEFuaW1hdGlvbkZyYW1lJywgZmFsc2UsIGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gd2luZG93LmNsZWFyVGltZW91dChpZCk7IH0pLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB0aW1lLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGN1cnJlbnQgdGltZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgbm93OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERhdGUubm93ICYmIERhdGUubm93KCkgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU3RvcHMgdGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBnaXZlbiBldmVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgb2Ygd2hpY2ggdGhlIHByb3BhZ2F0aW9uIHNoYWxsIGJlIHN0b3BlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgc3RwUDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgZ2l2ZW4gZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IG9mIHdoaWNoIHRoZSBkZWZhdWx0IGFjdGlvbiBzaGFsbCBiZSBwcmV2ZW50ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHBydkQ6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCAmJiBldmVudC5jYW5jZWxhYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBwYWdlWCBhbmQgcGFnZVkgdmFsdWVzIG9mIHRoZSBnaXZlbiBtb3VzZSBldmVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBldmVudCBUaGUgbW91c2UgZXZlbnQgb2Ygd2hpY2ggdGhlIHBhZ2VYIGFuZCBwYWdlWCBzaGFsbCBiZSBnb3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0geCA9IHBhZ2VYIHZhbHVlLCB5ID0gcGFnZVkgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHBhZ2U6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clBhZ2UgPSAncGFnZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckNsaWVudCA9ICdjbGllbnQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJYID0gJ1gnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJZID0gJ1knO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnREb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gZXZlbnREb2MuYm9keTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0b3VjaCBldmVudCByZXR1cm4gcmV0dXJuIHBhZ2VYL1kgb2YgaXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQudG91Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB0b3VjaFtzdHJQYWdlICsgc3RyWF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0b3VjaFtzdHJQYWdlICsgc3RyWV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbm90IG5hdGl2ZSBzdXBwb3J0ZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50W3N0clBhZ2UgKyBzdHJYXSAmJiBldmVudFtzdHJDbGllbnQgKyBzdHJYXSAmJiBldmVudFtzdHJDbGllbnQgKyBzdHJYXSAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogZXZlbnRbc3RyQ2xpZW50ICsgc3RyWF0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBldmVudFtzdHJDbGllbnQgKyBzdHJZXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogZXZlbnRbc3RyUGFnZSArIHN0clhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBldmVudFtzdHJQYWdlICsgc3RyWV1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGNsaWNrZWQgbW91c2UgYnV0dG9uIG9mIHRoZSBnaXZlbiBtb3VzZSBldmVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBldmVudCBUaGUgbW91c2UgZXZlbnQgb2Ygd2hpY2ggdGhlIGNsaWNrZWQgYnV0dG9uIHNoYWwgYmUgZ290LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB0aGUgY2xpY2tlZCBtb3VzZSBidXR0b24uICgwIDogbm9uZSB8IDEgOiBsZWZ0QnV0dG9uIHwgMiA6IG1pZGRsZUJ1dHRvbiB8IDMgOiByaWdodEJ1dHRvbilcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgbUJ0bjogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJ1dHRvbiAmIDEgPyAxIDogKGJ1dHRvbiAmIDIgPyAzIDogKGJ1dHRvbiAmIDQgPyAyIDogMCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC53aGljaDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBhIGl0ZW0gaXMgaW4gdGhlIGdpdmVuIGFycmF5IGFuZCByZXR1cm5zIGl0cyBpbmRleC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIG9mIHdoaWNoIHRoZSBwb3NpdGlvbiBpbiB0aGUgYXJyYXkgc2hhbGwgYmUgZGV0ZXJtaW5lZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhcnIgVGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHplcm8gYmFzZWQgaW5kZXggb2YgdGhlIGl0ZW0gb3IgLTEgaWYgdGhlIGl0ZW0gaXNuJ3QgaW4gdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpbkE6IGZ1bmN0aW9uIChpdGVtLCBhcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycltMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU29tZXRpZW1zIGluIElFIGEgXCJTQ1JJUFQ3MFwiIFBlcm1pc3Npb24gZGVuaWVkIGVycm9yIG9jY3VycyBpZiBIVE1MIGVsZW1lbnRzIGluIGEgaUZyYW1lIGFyZSBjb21wYXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gaXRlbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhcnIgVGhlIHBvdGVudGlhbCBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlzQTogZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBBcnJheS5pc0FycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWYgPyBkZWYoYXJyKSA6IHRoaXMudHlwZShhcnIpID09IFRZUEVTLmE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IFtbQ2xhc3NdXSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IG9mIHdoaWNoIHRoZSB0eXBlIHNoYWxsIGJlIGRldGVybWluZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHlwZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqICsgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iaiArICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3RbTEVYSUNPTi5wXS50b1N0cmluZy5jYWxsKG9iaikucmVwbGFjZSgvXlxcW29iamVjdCAoLispXFxdJC8sICckMScpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBiaW5kOiBiaW5kXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSB2ZW5kb3ItcHJlZml4ZWQgQ1NTIHByb3BlcnR5IGJ5IHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICogRm9yIGV4YW1wbGUgdGhlIGdpdmVuIG5hbWUgaXMgXCJ0cmFuc2Zvcm1cIiBhbmQgeW91J3JlIHVzaW5nIGEgb2xkIEZpcmVmb3ggYnJvd3NlciB0aGVuIHRoZSByZXR1cm5lZCB2YWx1ZSB3b3VsZCBiZSBcIi1tb3otdHJhbnNmb3JtXCIuXHJcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgYnJvd3NlciBkb2Vzbid0IG5lZWQgYSB2ZW5kb3ItcHJlZml4LCB0aGVuIHRoZSByZXR1cm5lZCBzdHJpbmcgaXMgdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgYXQgYWxsIChub3QgZXZlbiB3aXRoIGEgdmVuZG9yLXByZWZpeCkgdGhlIHJldHVybmVkIHZhbHVlIGlzIG51bGwuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcHJvcE5hbWUgVGhlIHVucHJlZml4ZWQgQ1NTIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSB2ZW5kb3ItcHJlZml4ZWQgQ1NTIHByb3BlcnR5IG9yIG51bGwgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBnaXZlbiBDU1MgcHJvcGVydHkuXHJcblxyXG4gICAgICAgICAgICAgICAgY3NzUHJvcDogZnVuY3Rpb24ocHJvcE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVkVORE9SUy5fY3NzUHJvcGVydHkocHJvcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCk7XHJcblxyXG5cclxuICAgICAgICB2YXIgTUFUSCA9IE1hdGg7XHJcbiAgICAgICAgdmFyIEpRVUVSWSA9IHdpbmRvdy5qUXVlcnk7XHJcbiAgICAgICAgdmFyIEVBU0lORyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfZWFzaW5nc01hdGggPSB7XHJcbiAgICAgICAgICAgICAgICBwOiBNQVRILlBJLFxyXG4gICAgICAgICAgICAgICAgYzogTUFUSC5jb3MsXHJcbiAgICAgICAgICAgICAgICBzOiBNQVRILnNpbixcclxuICAgICAgICAgICAgICAgIHc6IE1BVEgucG93LFxyXG4gICAgICAgICAgICAgICAgdDogTUFUSC5zcXJ0LFxyXG4gICAgICAgICAgICAgICAgbjogTUFUSC5hc2luLFxyXG4gICAgICAgICAgICAgICAgYTogTUFUSC5hYnMsXHJcbiAgICAgICAgICAgICAgICBvOiAxLjcwMTU4XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgeCA6IGN1cnJlbnQgcGVyY2VudCAoMCAtIDEpLFxyXG4gICAgICAgICAgICAgdCA6IGN1cnJlbnQgdGltZSAoZHVyYXRpb24gKiBwZXJjZW50KSxcclxuICAgICAgICAgICAgIGIgOiBzdGFydCB2YWx1ZSAoZnJvbSksXHJcbiAgICAgICAgICAgICBjIDogZW5kIHZhbHVlICh0byksXHJcbiAgICAgICAgICAgICBkIDogZHVyYXRpb25cclxuXHJcbiAgICAgICAgICAgICBlYXNpbmdOYW1lIDogZnVuY3Rpb24oeCwgdCwgYiwgYywgZCkgeyByZXR1cm4gZWFzZWRWYWx1ZTsgfVxyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzd2luZzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC41IC0gX2Vhc2luZ3NNYXRoLmMoeCAqIF9lYXNpbmdzTWF0aC5wKSAvIDI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGluZWFyOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtYyAqICh0IC89IGQpICogKHQgLSAyKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh0IC89IGQgLyAyKSA8IDEpID8gYyAvIDIgKiB0ICogdCArIGIgOiAtYyAvIDIgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbkN1YmljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICsgMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHQgLz0gZCAvIDIpIDwgMSkgPyBjIC8gMiAqIHQgKiB0ICogdCArIGIgOiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICsgMikgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0IC0gMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHQgLz0gZCAvIDIpIDwgMSkgPyBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKyBiIDogLWMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMikgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJblF1aW50OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKiB0ICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0ICogdCArIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh0IC89IGQgLyAyKSA8IDEpID8gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICogdCArIGIgOiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluU2luZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWMgKiBfZWFzaW5nc01hdGguYyh0IC8gZCAqIChfZWFzaW5nc01hdGgucCAvIDIpKSArIGMgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRTaW5lOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogX2Vhc2luZ3NNYXRoLnModCAvIGQgKiAoX2Vhc2luZ3NNYXRoLnAgLyAyKSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1jIC8gMiAqIChfZWFzaW5nc01hdGguYyhfZWFzaW5nc01hdGgucCAqIHQgLyBkKSAtIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5FeHBvOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodCA9PSAwKSA/IGIgOiBjICogX2Vhc2luZ3NNYXRoLncoMiwgMTAgKiAodCAvIGQgLSAxKSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRFeHBvOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodCA9PSBkKSA/IGIgKyBjIDogYyAqICgtX2Vhc2luZ3NNYXRoLncoMiwgLTEwICogdCAvIGQpICsgMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT0gMCkgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT0gZCkgcmV0dXJuIGIgKyBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSByZXR1cm4gYyAvIDIgKiBfZWFzaW5nc01hdGgudygyLCAxMCAqICh0IC0gMSkpICsgYjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAvIDIgKiAoLV9lYXNpbmdzTWF0aC53KDIsIC0xMCAqIC0tdCkgKyAyKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluQ2lyYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWMgKiAoX2Vhc2luZ3NNYXRoLnQoMSAtICh0IC89IGQpICogdCkgLSAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dENpcmM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiBfZWFzaW5nc01hdGgudCgxIC0gKHQgPSB0IC8gZCAtIDEpICogdCkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dENpcmM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodCAvPSBkIC8gMikgPCAxKSA/IC1jIC8gMiAqIChfZWFzaW5nc01hdGgudCgxIC0gdCAqIHQpIC0gMSkgKyBiIDogYyAvIDIgKiAoX2Vhc2luZ3NNYXRoLnQoMSAtICh0IC09IDIpICogdCkgKyAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluRWxhc3RpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IF9lYXNpbmdzTWF0aC5vOyB2YXIgcCA9IDA7IHZhciBhID0gYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSAwKSByZXR1cm4gYjsgaWYgKCh0IC89IGQpID09IDEpIHJldHVybiBiICsgYzsgaWYgKCFwKSBwID0gZCAqIC4zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhIDwgX2Vhc2luZ3NNYXRoLmEoYykpIHsgYSA9IGM7IHMgPSBwIC8gNDsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcyA9IHAgLyAoMiAqIF9lYXNpbmdzTWF0aC5wKSAqIF9lYXNpbmdzTWF0aC5uKGMgLyBhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLShhICogX2Vhc2luZ3NNYXRoLncoMiwgMTAgKiAodCAtPSAxKSkgKiBfZWFzaW5nc01hdGgucygodCAqIGQgLSBzKSAqICgyICogX2Vhc2luZ3NNYXRoLnApIC8gcCkpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0RWxhc3RpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IF9lYXNpbmdzTWF0aC5vOyB2YXIgcCA9IDA7IHZhciBhID0gYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSAwKSByZXR1cm4gYjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgLz0gZCkgPT0gMSkgcmV0dXJuIGIgKyBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcCkgcCA9IGQgKiAuMztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IF9lYXNpbmdzTWF0aC5hKGMpKSB7IGEgPSBjOyBzID0gcCAvIDQ7IH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHMgPSBwIC8gKDIgKiBfZWFzaW5nc01hdGgucCkgKiBfZWFzaW5nc01hdGgubihjIC8gYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgKiBfZWFzaW5nc01hdGgudygyLCAtMTAgKiB0KSAqIF9lYXNpbmdzTWF0aC5zKCh0ICogZCAtIHMpICogKDIgKiBfZWFzaW5nc01hdGgucCkgLyBwKSArIGMgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dEVsYXN0aWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBfZWFzaW5nc01hdGgubzsgdmFyIHAgPSAwOyB2YXIgYSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT0gMCkgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0IC89IGQgLyAyKSA9PSAyKSByZXR1cm4gYiArIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwKSBwID0gZCAqICguMyAqIDEuNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBfZWFzaW5nc01hdGguYShjKSkgeyBhID0gYzsgcyA9IHAgLyA0OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBzID0gcCAvICgyICogX2Vhc2luZ3NNYXRoLnApICogX2Vhc2luZ3NNYXRoLm4oYyAvIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgMSkgcmV0dXJuIC0uNSAqIChhICogX2Vhc2luZ3NNYXRoLncoMiwgMTAgKiAodCAtPSAxKSkgKiBfZWFzaW5nc01hdGgucygodCAqIGQgLSBzKSAqICgyICogX2Vhc2luZ3NNYXRoLnApIC8gcCkpICsgYjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAqIF9lYXNpbmdzTWF0aC53KDIsIC0xMCAqICh0IC09IDEpKSAqIF9lYXNpbmdzTWF0aC5zKCh0ICogZCAtIHMpICogKDIgKiBfZWFzaW5nc01hdGgucCkgLyBwKSAqIC41ICsgYyArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluQmFjazogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQsIHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gcyB8fCBfZWFzaW5nc01hdGgubztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0QmFjazogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQsIHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gcyB8fCBfZWFzaW5nc01hdGgubztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0QmFjazogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQsIHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gcyB8fCBfZWFzaW5nc01hdGgubztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh0IC89IGQgLyAyKSA8IDEpID8gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpICsgYiA6IGMgLyAyICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5Cb3VuY2U6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgLSB0aGlzLmVhc2VPdXRCb3VuY2UoeCwgZCAtIHQsIDAsIGMsIGQpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gNy41NjI1O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAvPSBkKSA8ICgxIC8gMi43NSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAobyAqIHQgKiB0KSArIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIgLyAyLjc1KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqIChvICogKHQgLT0gKDEuNSAvIDIuNzUpKSAqIHQgKyAuNzUpICsgYjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHQgPCAoMi41IC8gMi43NSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAobyAqICh0IC09ICgyLjI1IC8gMi43NSkpICogdCArIC45Mzc1KSArIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAobyAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAuOTg0Mzc1KSArIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dEJvdW5jZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHQgPCBkIC8gMikgPyB0aGlzLmVhc2VJbkJvdW5jZSh4LCB0ICogMiwgMCwgYywgZCkgKiAuNSArIGIgOiB0aGlzLmVhc2VPdXRCb3VuY2UoeCwgdCAqIDIgLSBkLCAwLCBjLCBkKSAqIC41ICsgYyAqIC41ICsgYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogVEVSTVMgT0YgVVNFIC0gRUFTSU5HIEVRVUFUSU9OU1xyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogT3BlbiBzb3VyY2UgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLiBcclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIENvcHlyaWdodCDDgsKpIDIwMDEgUm9iZXJ0IFBlbm5lclxyXG4gICAgICAgICAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgXHJcbiAgICAgICAgICAgICAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIFxyXG4gICAgICAgICAgICAgKiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAgICAgICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IFxyXG4gICAgICAgICAgICAgKiBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBcclxuICAgICAgICAgICAgICogcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2UgXHJcbiAgICAgICAgICAgICAqIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIFxyXG4gICAgICAgICAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcclxuICAgICAgICAgICAgICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAgICAgICAgICAgICAqICBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAgICAgICAgICAgICAqICBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEVcclxuICAgICAgICAgICAgICogIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBcclxuICAgICAgICAgICAgICogQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICAgICAgICAgICAgICogIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIFxyXG4gICAgICAgICAgICAgKiBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuIFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIHZhciBGUkFNRVdPUksgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3Jub3RodG1sd2hpdGUgPSAoL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nKTtcclxuICAgICAgICAgICAgdmFyIF9zdHJTcGFjZSA9ICcgJztcclxuICAgICAgICAgICAgdmFyIF9zdHJFbXB0eSA9ICcnO1xyXG4gICAgICAgICAgICB2YXIgX3N0clNjcm9sbExlZnQgPSAnc2Nyb2xsTGVmdCc7XHJcbiAgICAgICAgICAgIHZhciBfc3RyU2Nyb2xsVG9wID0gJ3Njcm9sbFRvcCc7XHJcbiAgICAgICAgICAgIHZhciBfYW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgX3R5cGUgPSBDT01QQVRJQklMSVRZLnR5cGU7XHJcbiAgICAgICAgICAgIHZhciBfY3NzTnVtYmVyID0ge1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db3VudDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmxleEdyb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmbGV4U2hyaW5rOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb3JkZXI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvcnBoYW5zOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgd2lkb3dzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgem9vbTogdHJ1ZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNyYywgY29weUlzQXJyYXksIGNvcHksIG5hbWUsIG9wdGlvbnMsIGNsb25lLCB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzW0xFWElDT04ubF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGVlcCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cclxuICAgICAgICAgICAgICAgIGlmIChfdHlwZSh0YXJnZXQpID09IFRZUEVTLmIpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWVwID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXHJcbiAgICAgICAgICAgICAgICBpZiAoX3R5cGUodGFyZ2V0KSAhPSBUWVBFUy5vICYmICFfdHlwZSh0YXJnZXQpID09IFRZUEVTLmYpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBGYWtlalF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgIC0taTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgob3B0aW9ucyA9IGFyZ3VtZW50c1tpXSkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1tuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBjb3B5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBjb3B5ICYmIChpc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IENPTVBBVElCSUxJVFkuaXNBKGNvcHkpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29weUlzQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgQ09NUEFUSUJJTElUWS5pc0Eoc3JjKSA/IHNyYyA6IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gY29weTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGluQXJyYXkoaXRlbSwgYXJyLCBmcm9tSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXggfHwgMDsgaSA8IGFycltMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gaXRlbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3R5cGUob2JqKSA9PSBUWVBFUy5mO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcclxuICAgICAgICAgICAgICAgIGlmICghb2JqIHx8IF90eXBlKG9iaikgIT0gVFlQRVMubylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm90byA9IExFWElDT04ucDtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdFtwcm90b10uaGFzT3duUHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzT3duQ29uc3RydWN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzSXNQcm90b3R5cGVPZiA9IG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3JbcHJvdG9dICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLmNvbnN0cnVjdG9yW3Byb3RvXSwgJ2lzUHJvdG90eXBlT2YnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNPd25Db25zdHJ1Y3RvciAmJiAhaGFzSXNQcm90b3R5cGVPZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7IC8qKi8gfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfdHlwZShrZXkpID09IFRZUEVTLnUgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBlYWNoKG9iaiwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgb2JqW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSAhIW9iaiAmJiBbTEVYSUNPTi5sXSBpbiBvYmogJiYgb2JqW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IF90eXBlKG9iaik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih0KSA/IGZhbHNlIDogKHQgPT0gVFlQRVMuYSB8fCBsZW5ndGggPT09IDAgfHwgX3R5cGUobGVuZ3RoKSA9PSBUWVBFUy5uICYmIGxlbmd0aCA+IDAgJiYgKGxlbmd0aCAtIDEpIGluIG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaChfcm5vdGh0bWx3aGl0ZSkgfHwgW107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zLmpvaW4oX3N0clNwYWNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hlcyhlbGVtLCBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVMaXN0ID0gKGVsZW0ucGFyZW50Tm9kZSB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgfHwgW107XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IG5vZGVMaXN0W0xFWElDT04ubF07XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUxpc3RbaV0gPT0gZWxlbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnNlcnRBZGphY2VudEVsZW1lbnQoZWwsIHN0cmF0ZWd5LCBjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaXNBKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZGphY2VudEVsZW1lbnQoZWwsIHN0cmF0ZWd5LCBjaGlsZFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdHlwZShjaGlsZCkgPT0gVFlQRVMucylcclxuICAgICAgICAgICAgICAgICAgICBlbC5pbnNlcnRBZGphY2VudEhUTUwoc3RyYXRlZ3ksIGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBlbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoc3RyYXRlZ3ksIGNoaWxkLm5vZGVUeXBlID8gY2hpbGQgOiBjaGlsZFswXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldENTU1ZhbChlbCwgcHJvcCwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbFtMRVhJQ09OLnNdW3Byb3BdICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsW0xFWElDT04uc11bcHJvcF0gPSBwYXJzZUNTU1ZhbChwcm9wLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlQ1NTVmFsKHByb3AsIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfY3NzTnVtYmVyW3Byb3AudG9Mb3dlckNhc2UoKV0gJiYgX3R5cGUodmFsKSA9PSBUWVBFUy5uKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCArPSAncHgnO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RhcnROZXh0QW5pbWF0aW9uSW5RKGFuaW1PYmosIHJlbW92ZUZyb21RKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEFuaW07XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlRnJvbVEgIT09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1PYmoucS5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbU9iai5xW0xFWElDT04ubF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dEFuaW0gPSBhbmltT2JqLnFbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZShhbmltT2JqLmVsLCBuZXh0QW5pbS5wcm9wcywgbmV4dEFuaW0uZHVyYXRpb24sIG5leHRBbmltLmVhc2luZywgbmV4dEFuaW0uY29tcGxldGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbkFycmF5KGFuaW1PYmosIF9hbmltYXRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2FuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0QW5pbWF0aW9uVmFsdWUoZWwsIHByb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gX3N0clNjcm9sbExlZnQgfHwgcHJvcCA9PT0gX3N0clNjcm9sbFRvcClcclxuICAgICAgICAgICAgICAgICAgICBlbFtwcm9wXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldENTU1ZhbChlbCwgcHJvcCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhbmltYXRlKGVsLCBwcm9wcywgb3B0aW9ucywgZWFzaW5nLCBjb21wbGV0ZSwgZ3VhcmFudGVlZE5leHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNPcHRpb25zID0gaXNQbGFpbk9iamVjdChvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbU9iajtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydDtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcztcclxuICAgICAgICAgICAgICAgIHZhciBzdGVwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwZWNpYWxFYXNpbmc7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IG9wdGlvbnMucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IG9wdGlvbnMuc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nID0gb3B0aW9ucy5zcGVjaWFsRWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZyA9IHNwZWNpYWxFYXNpbmcgfHwge307XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDQwMDtcclxuICAgICAgICAgICAgICAgIGVhc2luZyA9IGVhc2luZyB8fCAnc3dpbmcnO1xyXG4gICAgICAgICAgICAgICAgZ3VhcmFudGVlZE5leHQgPSBndWFyYW50ZWVkTmV4dCB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IF9hbmltYXRpb25zW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfYW5pbWF0aW9uc1tpXS5lbCA9PT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbU9iaiA9IF9hbmltYXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFhbmltT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbU9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxOiBbXVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgX2FuaW1hdGlvbnMucHVzaChhbmltT2JqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IF9zdHJTY3JvbGxMZWZ0IHx8IGtleSA9PT0gX3N0clNjcm9sbFRvcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVtrZXldID0gZWxba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21ba2V5XSA9IEZha2VqUXVlcnkoZWwpLmNzcyhrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGZyb20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbVtrZXldICE9PSBwcm9wc1trZXldICYmIHByb3BzW2tleV0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9ba2V5XSA9IHByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lTm93O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21WYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlYXNlZFZhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZVN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxhcHNlZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcVBvcyA9IGd1YXJhbnRlZWROZXh0ID8gMCA6IGluQXJyYXkocU9iaiwgYW5pbU9iai5xKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcU9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHRvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogaGFzT3B0aW9ucyA/IG9wdGlvbnMgOiBkdXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFQb3MgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFQb3MgPSBhbmltT2JqLnFbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbU9iai5xLnB1c2gocU9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocVBvcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lU3RhcnQgPSBDT01QQVRJQklMSVRZLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZU5vdyA9IENPTVBBVElCSUxJVFkubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxhcHNlZCA9ICh0aW1lTm93IC0gdGltZVN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBxT2JqLnN0b3AgfHwgZWxhcHNlZCA+PSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gMSAtICgoTUFUSC5tYXgoMCwgdGltZVN0YXJ0ICsgZHVyYXRpb24gLSB0aW1lTm93KSAvIGR1cmF0aW9uKSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVZhbCA9IHBhcnNlRmxvYXQoZnJvbVtrZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9WYWwgPSBwYXJzZUZsb2F0KHRvW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNlZFZhbCA9ICh0b1ZhbCAtIGZyb21WYWwpICogRUFTSU5HW3NwZWNpYWxFYXNpbmdba2V5XSB8fCBlYXNpbmddKHBlcmNlbnQsIHBlcmNlbnQgKiBkdXJhdGlvbiwgMCwgMSwgZHVyYXRpb24pICsgZnJvbVZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QW5pbWF0aW9uVmFsdWUoZWwsIGtleSwgZWFzZWRWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihzdGVwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcChlYXNlZFZhbCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IGVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3A6IGtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZnJvbVZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3c6IGVhc2VkVmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogdG9WYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwZXJjZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWFjaWFsRWFzaW5nOiBzcGVjaWFsRWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiB0aW1lU3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9ncmVzcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzKHt9LCBwZXJjZW50LCBNQVRILm1heCgwLCBkdXJhdGlvbiAtIGVsYXBzZWQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5leHRBbmltYXRpb25JblEoYW5pbU9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbXBsZXRlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcU9iai5mcmFtZSA9IENPTVBBVElCSUxJVFkuckFGKCkoZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFPYmouZnJhbWUgPSBDT01QQVRJQklMSVRZLnJBRigpKGZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHRvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFuaW1hdGlvblZhbHVlKGVsLCBrZXksIHRvW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnROZXh0QW5pbWF0aW9uSW5RKGFuaW1PYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZ3VhcmFudGVlZE5leHQpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnROZXh0QW5pbWF0aW9uSW5RKGFuaW1PYmopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdG9wKGVsLCBjbGVhclEsIGp1bXBUb0VuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1PYmo7XHJcbiAgICAgICAgICAgICAgICB2YXIgcU9iajtcclxuICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IF9hbmltYXRpb25zW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1PYmogPSBfYW5pbWF0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbU9iai5lbCA9PT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1PYmoucVtMRVhJQ09OLmxdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcU9iaiA9IGFuaW1PYmoucVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFPYmouc3RvcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLmNBRigpKHFPYmouZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbU9iai5xLnNwbGljZSgwLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanVtcFRvRW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHFPYmoucHJvcHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFuaW1hdGlvblZhbHVlKGVsLCBrZXksIHFPYmoucHJvcHNba2V5XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsZWFyUSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltT2JqLnEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5leHRBbmltYXRpb25JblEoYW5pbU9iaiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZWxlbWVudElzVmlzaWJsZShlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKGVsW0xFWElDT04ub1ddIHx8IGVsW0xFWElDT04ub0hdIHx8IGVsLmdldENsaWVudFJlY3RzKClbTEVYSUNPTi5sXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZha2VqUXVlcnkoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbTEVYSUNPTi5sXSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IG5ldyBGYWtlalF1ZXJ5KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBlbG1zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfdHlwZShzZWxlY3RvcikgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gJzwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1zID0gZWwuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGVsbXNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsbXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdHlwZShlbGVtZW50cykgIT0gVFlQRVMucyAmJiAoIWlzQXJyYXlMaWtlKGVsZW1lbnRzKSB8fCBlbGVtZW50cyA9PT0gd2luZG93IHx8IGVsZW1lbnRzID09PSBlbGVtZW50cy5zZWxmKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlW2ldID0gZWxlbWVudHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VbTEVYSUNPTi5sXSA9IGVsZW1lbnRzW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBGYWtlalF1ZXJ5W0xFWElDT04ucF0gPSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9FVkVOVFM6XHJcblxyXG4gICAgICAgICAgICAgICAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSAoZXZlbnROYW1lIHx8IF9zdHJFbXB0eSkubWF0Y2goX3Jub3RodG1sd2hpdGUpIHx8IFtfc3RyRW1wdHldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lTGVuZ3RoID0gZXZlbnROYW1lW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGV2ZW50TmFtZUxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZVtpXSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC5kZXRhY2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZXZlbnROYW1lTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWVbaV0sIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgb2ZmOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gKGV2ZW50TmFtZSB8fCBfc3RyRW1wdHkpLm1hdGNoKF9ybm90aHRtbHdoaXRlKSB8fCBbX3N0ckVtcHR5XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZUxlbmd0aCA9IGV2ZW50TmFtZVtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBldmVudE5hbWVMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWVbaV0sIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwuZGV0YWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGV2ZW50TmFtZUxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lW2ldLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIG9uZTogZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgX3N0ckVtcHR5KS5tYXRjaChfcm5vdGh0bWx3aGl0ZSkgfHwgW19zdHJFbXB0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IEZha2VqUXVlcnkodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZha2VqUXVlcnkuZWFjaChldmVudE5hbWUsIGZ1bmN0aW9uIChpLCBvbmVFdmVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbmVIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwub2ZmKG9uZUV2ZW50TmFtZSwgb25lSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwub24ob25lRXZlbnROYW1lLCBvbmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5maXJlRXZlbnQoJ29uJyArIGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLy9ET00gTk9ERSBJTlNFUlRJTkcgLyBSRU1PVklORzpcclxuXHJcbiAgICAgICAgICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBpbnNlcnRBZGphY2VudEVsZW1lbnQodGhpcywgJ2JlZm9yZWVuZCcsIGNoaWxkKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHByZXBlbmQ6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBpbnNlcnRBZGphY2VudEVsZW1lbnQodGhpcywgJ2FmdGVyYmVnaW4nLCBjaGlsZCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBpbnNlcnRBZGphY2VudEVsZW1lbnQodGhpcywgJ2JlZm9yZWJlZ2luJywgY2hpbGQpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBpbnNlcnRBZGphY2VudEVsZW1lbnQodGhpcywgJ2FmdGVyZW5kJywgY2hpbGQpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICB1bndyYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KHBhcmVudCwgcGFyZW50cykgPT09IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyZW50c1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBwYXJlbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWwuZmlyc3RDaGlsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWwuZmlyc3RDaGlsZCwgZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHdyYXBBbGw6IGZ1bmN0aW9uICh3cmFwcGVySFRNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBGYWtlalF1ZXJ5KHdyYXBwZXJIVE1MKVswXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVlcGVzdCA9IHdyYXBwZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVzWzBdLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IG5vZGVzWzBdLnByZXZpb3VzU2libGluZztcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGVlcGVzdC5jaGlsZE5vZGVzW0xFWElDT04ubF0gPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWVwZXN0ID0gZGVlcGVzdC5jaGlsZE5vZGVzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBub2Rlc1tMRVhJQ09OLmxdIC0gaTsgZGVlcGVzdC5maXJzdENoaWxkID09PSBub2Rlc1swXSAmJiBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBlc3QuYXBwZW5kQ2hpbGQobm9kZXNbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmcgPyBwcmV2aW91c1NpYmxpbmcubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIG5leHRTaWJsaW5nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHdyYXBJbm5lcjogZnVuY3Rpb24gKHdyYXBwZXJIVE1MKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IEZha2VqUXVlcnkodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IGVsLmNvbnRlbnRzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudHNbTEVYSUNPTi5sXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLndyYXBBbGwod3JhcHBlckhUTUwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmQod3JhcHBlckhUTUwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICB3cmFwOiBmdW5jdGlvbiAod3JhcHBlckhUTUwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgRmFrZWpRdWVyeSh0aGlzKS53cmFwQWxsKHdyYXBwZXJIVE1MKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL0RPTSBOT0RFIE1BTklQVUxBVElPTiAvIElORk9STUFUSU9OOlxyXG5cclxuICAgICAgICAgICAgICAgIGNzczogZnVuY3Rpb24gKHN0eWxlcywgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNwdFN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRDcHRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdHlwZShzdHlsZXMpID09IFRZUEVTLnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHRTdHlsZSA9IGdldENwdFN0eWxlID8gZ2V0Q3B0U3R5bGUoZWwsIG51bGwpIDogZWwuY3VycmVudFN0eWxlW3N0eWxlc107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9odHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTcgY2FuIGJlIG51bGwgc29tZXRpbWVzIGlmIGlmcmFtZSB3aXRoIGRpc3BsYXk6IG5vbmUgKGZpcmVmb3ggb25seSEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q3B0U3R5bGUgPyBjcHRTdHlsZSAhPSBudWxsID8gY3B0U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZXMpIDogZWxbTEVYSUNPTi5zXVtzdHlsZXNdIDogY3B0U3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDU1NWYWwodGhpcywgc3R5bGVzLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc3R5bGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENTU1ZhbCh0aGlzLCBrZXksIHN0eWxlc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLCBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lUHJlcGFyZWQgPSBfc3RyU3BhY2UgKyBjbGFzc05hbWUgKyBfc3RyU3BhY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTGlzdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gdGhpc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0xpc3QgPSBlbGVtLmNsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtLm5vZGVUeXBlID09PSAxICYmIChfc3RyU3BhY2UgKyBzdHJpcEFuZENvbGxhcHNlKGVsZW0uY2xhc3NOYW1lICsgX3N0ckVtcHR5KSArIF9zdHJTcGFjZSkuaW5kZXhPZihjbGFzc05hbWVQcmVwYXJlZCkgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1clZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGF6ejtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3VwcG9ydENsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxtQ2xhc3NMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NlcyA9IGNsYXNzTmFtZS5tYXRjaChfcm5vdGh0bWx3aGl0ZSkgfHwgW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSB0aGlzW2krK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG1DbGFzc0xpc3QgPSBlbGVtLmNsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0Q2xhc3NMaXN0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydENsYXNzTGlzdCA9IGVsbUNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0Q2xhc3NMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbdisrXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbUNsYXNzTGlzdC5hZGQoY2xhenopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVmFsdWUgPSBlbGVtLmNsYXNzTmFtZSArIF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmIChfc3RyU3BhY2UgKyBzdHJpcEFuZENvbGxhcHNlKGN1clZhbHVlKSArIF9zdHJTcGFjZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbdisrXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLmluZGV4T2YoX3N0clNwYWNlICsgY2xhenogKyBfc3RyU3BhY2UpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgKz0gY2xhenogKyBfc3RyU3BhY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZShjdXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xheno7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1cHBvcnRDbGFzc0xpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsbUNsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2goX3Jub3RodG1sd2hpdGUpIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gdGhpc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtQ2xhc3NMaXN0ID0gZWxlbS5jbGFzc0xpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydENsYXNzTGlzdCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRDbGFzc0xpc3QgPSBlbG1DbGFzc0xpc3QgIT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydENsYXNzTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW3YrK10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG1DbGFzc0xpc3QucmVtb3ZlKGNsYXp6KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clZhbHVlID0gZWxlbS5jbGFzc05hbWUgKyBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoX3N0clNwYWNlICsgc3RyaXBBbmRDb2xsYXBzZShjdXJWYWx1ZSkgKyBfc3RyU3BhY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW3YrK10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1ci5pbmRleE9mKF9zdHJTcGFjZSArIGNsYXp6ICsgX3N0clNwYWNlKSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKF9zdHJTcGFjZSArIGNsYXp6ICsgX3N0clNwYWNlLCBfc3RyU3BhY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clZhbHVlICE9PSBmaW5hbFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgdGhpc1tMRVhJQ09OLnNdLmRpc3BsYXkgPSAnbm9uZSc7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IHRoaXNbTEVYSUNPTi5zXS5kaXNwbGF5ID0gJ2Jsb2NrJzsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGF0dHI6IGZ1bmN0aW9uIChhdHRyTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbCA9IHRoaXNbaSsrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZWxbTEVYSUNPTi5iQ1JdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtfc3RyU2Nyb2xsVG9wXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgc2Nyb2xsVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyBzY3JvbGxMZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZWwub2Zmc2V0VG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlbC5vZmZzZXRMZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWwgPSB0aGlzW2krK10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxbX3N0clNjcm9sbExlZnRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFtfc3RyU2Nyb2xsTGVmdF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWwgPSB0aGlzW2krK10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxbX3N0clNjcm9sbFRvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsW19zdHJTY3JvbGxUb3BdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICB2YWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL0RPTSBUUkFWRVJTQUwgLyBGSUxURVJJTkc6XHJcblxyXG4gICAgICAgICAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcSgwKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgbGFzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKC0xKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZXE6IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWtlalF1ZXJ5KHRoaXNbaW5kZXggPj0gMCA/IGluZGV4IDogdGhpc1tMRVhJQ09OLmxdICsgaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoID0gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaFtMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFrZWpRdWVyeShjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaFtMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gY2hbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsLm1hdGNoZXMgJiYgZWwubWF0Y2hlcyhzZWxlY3RvcikpIHx8IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFrZWpRdWVyeShjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmVudDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID8gRmFrZWpRdWVyeShwYXJlbnQpLmlzKHNlbGVjdG9yKSA6IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFrZWpRdWVyeShwYXJlbnRzKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgaXM6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdGhpc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnOnZpc2libGUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGUoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICc6aGlkZGVuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZWxlbWVudElzVmlzaWJsZShlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWwubWF0Y2hlcyAmJiBlbC5tYXRjaGVzKHNlbGVjdG9yKSkgfHwgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgY29udGVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHMgPSB0aGlzLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudHMucHVzaChjaGlsZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFrZWpRdWVyeShjb250ZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlYWNoKHRoaXMsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vQU5JTUFUSU9OOlxyXG5cclxuICAgICAgICAgICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChwcm9wcywgZHVyYXRpb24sIGVhc2luZywgY29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgYW5pbWF0ZSh0aGlzLCBwcm9wcywgZHVyYXRpb24sIGVhc2luZywgY29tcGxldGUpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKGNsZWFyUSwganVtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBzdG9wKHRoaXMsIGNsZWFyUSwganVtcCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZXh0ZW5kKEZha2VqUXVlcnksIHtcclxuICAgICAgICAgICAgICAgIGV4dGVuZDogZXh0ZW5kLFxyXG4gICAgICAgICAgICAgICAgaW5BcnJheTogaW5BcnJheSxcclxuICAgICAgICAgICAgICAgIGlzRW1wdHlPYmplY3Q6IGlzRW1wdHlPYmplY3QsXHJcbiAgICAgICAgICAgICAgICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgZWFjaDogZWFjaFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBGYWtlalF1ZXJ5O1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgdmFyIElOU1RBTkNFUyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGFyZ2V0cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlUHJvcGVydHlTdHJpbmcgPSAnX19vdmVybGF5U2Nyb2xsYmFyc19fJztcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlciwgdW5yZWdpc3RlciBvciBnZXQgYSBjZXJ0YWluIChvciBhbGwpIGluc3RhbmNlcy5cclxuICAgICAgICAgICAgICogUmVnaXN0ZXI6IFBhc3MgdGhlIHRhcmdldCBhbmQgdGhlIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgKiBVbnJlZ2lzdGVyOiBQYXNzIHRoZSB0YXJnZXQgYW5kIG51bGwuXHJcbiAgICAgICAgICAgICAqIEdldCBJbnN0YW5jZTogUGFzcyB0aGUgdGFyZ2V0IGZyb20gd2hpY2ggdGhlIGluc3RhbmNlIHNoYWxsIGJlIGdvdC5cclxuICAgICAgICAgICAgICogR2V0IFRhcmdldHM6IFBhc3Mgbm8gYXJndW1lbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGluc3RhbmNlIHNoYWxsIGJlIHJlZ2lzdGVyZWQgLyBmcm9tIHdoaWNoIHRoZSBpbnN0YW5jZSBzaGFsbCBiZSB1bnJlZ2lzdGVyZWQgLyB0aGUgaW5zdGFuY2Ugc2hhbGwgYmUgZ290XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfHZvaWR9IFJldHVybnMgdGhlIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHRhcmdldC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3VtZW50c1tMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBhbGwgdGFyZ2V0c1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGFyZ2V0cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlZ2lzdGVyIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtfaW5zdGFuY2VQcm9wZXJ0eVN0cmluZ10gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldHMucHVzaCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gQ09NUEFUSUJJTElUWS5pbkEodGFyZ2V0LCBfdGFyZ2V0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdW5yZWdpc3RlciBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbX2luc3RhbmNlUHJvcGVydHlTdHJpbmddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBpbnN0YW5jZSBmcm9tIHRhcmdldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGFyZ2V0c1tpbmRleF1bX2luc3RhbmNlUHJvcGVydHlTdHJpbmddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuICAgICAgICB2YXIgUExVR0lOID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9wbHVnaW47XHJcbiAgICAgICAgICAgIHZhciBfcGx1Z2luc0dsb2JhbHM7XHJcbiAgICAgICAgICAgIHZhciBfcGx1Z2luc0F1dG9VcGRhdGVMb29wO1xyXG4gICAgICAgICAgICB2YXIgX3BsdWdpbnNFeHRlbnNpb25zID0gW107XHJcbiAgICAgICAgICAgIHZhciBfcGx1Z2luc09wdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBDT01QQVRJQklMSVRZLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVUZW1wbGF0ZVR5cGVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIFRZUEVTLmIsIC8vYm9vbGVhblxyXG4gICAgICAgICAgICAgICAgICAgIFRZUEVTLm4sIC8vbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgVFlQRVMucywgLy9zdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBUWVBFUy5hLCAvL2FycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgVFlQRVMubywgLy9vYmplY3RcclxuICAgICAgICAgICAgICAgICAgICBUWVBFUy5mLCAvL2Z1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgVFlQRVMueiAgLy9udWxsXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3RyaWN0ZWRTdHJpbmdzU3BsaXQgPSAnICc7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdHJpY3RlZFN0cmluZ3NQb3NzaWJpbGl0aWVzU3BsaXQgPSAnOic7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lQWxsb3dlZFZhbHVlcyA9IFtUWVBFUy56LCBUWVBFUy5zXTtcclxuICAgICAgICAgICAgICAgIHZhciBudW1iZXJBbGxvd2VkVmFsdWVzID0gVFlQRVMubjtcclxuICAgICAgICAgICAgICAgIHZhciBib29sZWFuTnVsbEFsbG93ZWRWYWx1ZXMgPSBbVFlQRVMueiwgVFlQRVMuYl07XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9vbGVhblRydWVUZW1wbGF0ZSA9IFt0cnVlLCBUWVBFUy5iXTtcclxuICAgICAgICAgICAgICAgIHZhciBib29sZWFuRmFsc2VUZW1wbGF0ZSA9IFtmYWxzZSwgVFlQRVMuYl07XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tUZW1wbGF0ZSA9IFtudWxsLCBbVFlQRVMueiwgVFlQRVMuZl1dO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZU9uTG9hZFRlbXBsYXRlID0gW1snaW1nJ10sIFtUWVBFUy5zLCBUWVBFUy5hLCBUWVBFUy56XV07XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdGVkQXR0cnNUZW1wbGF0ZSA9IFtbJ3N0eWxlJywgJ2NsYXNzJ10sIFtUWVBFUy5zLCBUWVBFUy5hLCBUWVBFUy56XV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzaXplQWxsb3dlZFZhbHVlcyA9ICduOm5vbmUgYjpib3RoIGg6aG9yaXpvbnRhbCB2OnZlcnRpY2FsJztcclxuICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvd0JlaGF2aW9yQWxsb3dlZFZhbHVlcyA9ICd2LWg6dmlzaWJsZS1oaWRkZW4gdi1zOnZpc2libGUtc2Nyb2xsIHM6c2Nyb2xsIGg6aGlkZGVuJztcclxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzVmlzaWJpbGl0eUFsbG93ZWRWYWx1ZXMgPSAndjp2aXNpYmxlIGg6aGlkZGVuIGE6YXV0byc7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc0F1dG9IaWRlQWxsb3dlZFZhbHVlcyA9ICduOm5ldmVyIHM6c2Nyb2xsIGw6bGVhdmUgbTptb3ZlJztcclxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zRGVmYXVsdHNBbmRUZW1wbGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFsnb3MtdGhlbWUtZGFyaycsIGNsYXNzTmFtZUFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgICAgICAvL251bGwgfHwgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplOiBbJ25vbmUnLCByZXNpemVBbGxvd2VkVmFsdWVzXSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub25lIHx8IGJvdGggIHx8IGhvcml6b250YWwgfHwgdmVydGljYWwgfHwgbiB8fCBiIHx8IGggfHwgdlxyXG4gICAgICAgICAgICAgICAgICAgIHNpemVBdXRvQ2FwYWJsZTogYm9vbGVhblRydWVUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNsaXBBbHdheXM6IGJvb2xlYW5UcnVlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVJUTDogYm9vbGVhblRydWVUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdBYnNvbHV0ZTogYm9vbGVhbkZhbHNlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9VcGRhdGU6IFtudWxsLCBib29sZWFuTnVsbEFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZSB8fCBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1VwZGF0ZUludGVydmFsOiBbMzMsIG51bWJlckFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgICAgICAgICAgICAgLy9udW1iZXJcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVPbkxvYWQ6IHVwZGF0ZU9uTG9hZFRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N0cmluZyB8fCBhcnJheSB8fCBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dOYXRpdmVTY3JvbGxiYXJzOiBib29sZWFuRmFsc2VUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemU6IGJvb2xlYW5UcnVlVGVtcGxhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0JlaGF2aW9yOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IFsnc2Nyb2xsJywgb3ZlcmZsb3dCZWhhdmlvckFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgICAgICAgICAgLy92aXNpYmxlLWhpZGRlbiAgfHwgdmlzaWJsZS1zY3JvbGwgfHwgaGlkZGVuIHx8IHNjcm9sbCB8fCB2LWggfHwgdi1zIHx8IGggfHwgc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBbJ3Njcm9sbCcsIG92ZXJmbG93QmVoYXZpb3JBbGxvd2VkVmFsdWVzXSAgICAgICAgICAgICAgICAgICAgIC8vdmlzaWJsZS1oaWRkZW4gIHx8IHZpc2libGUtc2Nyb2xsIHx8IGhpZGRlbiB8fCBzY3JvbGwgfHwgdi1oIHx8IHYtcyB8fCBoIHx8IHNcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogWydhdXRvJywgc2Nyb2xsYmFyc1Zpc2liaWxpdHlBbGxvd2VkVmFsdWVzXSwgICAgICAgICAvL3Zpc2libGUgfHwgaGlkZGVuIHx8IGF1dG8gfHwgdiB8fCBoIHx8IGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0hpZGU6IFsnbmV2ZXInLCBzY3JvbGxiYXJzQXV0b0hpZGVBbGxvd2VkVmFsdWVzXSwgICAgICAgICAgICAvL25ldmVyIHx8IHNjcm9sbCB8fCBsZWF2ZSB8fCBtb3ZlIHx8IG4gfHwgcyB8fCBsIHx8IG1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0hpZGVEZWxheTogWzgwMCwgbnVtYmVyQWxsb3dlZFZhbHVlc10sICAgICAgICAgICAgICAgICAgICAgICAvL251bWJlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnU2Nyb2xsaW5nOiBib29sZWFuVHJ1ZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlja1Njcm9sbGluZzogYm9vbGVhbkZhbHNlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3VjaFN1cHBvcnQ6IGJvb2xlYW5UcnVlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwSGFuZGxlOiBib29sZWFuRmFsc2VUZW1wbGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHluV2lkdGg6IGJvb2xlYW5GYWxzZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHluSGVpZ2h0OiBib29sZWFuRmFsc2VUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGVkQXR0cnM6IGluaGVyaXRlZEF0dHJzVGVtcGxhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N0cmluZyB8fCBhcnJheSB8fCBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Jbml0aWFsaXplZDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Jbml0aWFsaXphdGlvbldpdGhkcmF3bjogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25EZXN0cm95ZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TY3JvbGxTdGFydDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TY3JvbGw6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TY3JvbGxTdG9wOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25PdmVyZmxvd0NoYW5nZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25PdmVyZmxvd0Ftb3VudENoYW5nZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25EaXJlY3Rpb25DaGFuZ2VkOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Db250ZW50U2l6ZUNoYW5nZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Ib3N0U2l6ZUNoYW5nZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25VcGRhdGVkOiBjYWxsYmFja1RlbXBsYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdXJzaXZlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ialtMRVhJQ09OLmhPUF0oa2V5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsVHlwZSA9IHR5cGUodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxUeXBlID09IFRZUEVTLmEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWxbdGVtcGxhdGUgPyAxIDogMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWxUeXBlID09IFRZUEVTLm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSByZWN1cnNpdmUodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZShGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHt9LCBvcHRpb25zRGVmYXVsdHNBbmRUZW1wbGF0ZSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9kZWZhdWx0czogY29udmVydCgpLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfdGVtcGxhdGU6IGNvbnZlcnQodHJ1ZSksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFZhbGlkYXRlcyB0aGUgcGFzc2VkIG9iamVjdCBieSB0aGUgcGFzc2VkIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB3aGljaCBzaGFsbCBiZSB2YWxpZGF0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSB3aGljaCBkZWZpbmVzIHRoZSBhbGxvd2VkIHZhbHVlcyBhbmQgdHlwZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHdyaXRlRXJyb3JzIFRydWUgaWYgZXJyb3JzIHNoYWxsIGJlIGxvZ2dlZCB0byB0aGUgY29uc29sZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZGlmZk9iaiBJZiBhIG9iamVjdCBpcyBwYXNzZWQgdGhlbiBvbmx5IHZhbGlkIGRpZmZlcmVuY2VzIHRvIHRoaXMgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3t9fSBBIG9iamVjdCB3aGljaCBjb250YWlucyB0d28gb2JqZWN0cyBjYWxsZWQgXCJkZWZhdWx0XCIgYW5kIFwicHJlcGFyZWRcIiB3aGljaCBjb250YWlucyBvbmx5IHRoZSB2YWxpZCBwcm9wZXJ0aWVzIG9mIHRoZSBwYXNzZWQgb3JpZ2luYWwgb2JqZWN0IGFuZCBkaXNjYXJkcyBub3QgZGlmZmVyZW50IHZhbHVlcyBjb21wYXJlZCB0byB0aGUgcGFzc2VkIGRpZmZPYmouXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgX3ZhbGlkYXRlOiBmdW5jdGlvbiAob2JqLCB0ZW1wbGF0ZSwgd3JpdGVFcnJvcnMsIGRpZmZPYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRlZE9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0Q29weSA9IEZSQU1FV09SSy5leHRlbmQodHJ1ZSwge30sIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbkFycmF5ID0gRlJBTUVXT1JLLmluQXJyYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0VtcHR5T2JqID0gRlJBTUVXT1JLLmlzRW1wdHlPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGVja09iamVjdFByb3BzID0gZnVuY3Rpb24gKGRhdGEsIHRlbXBsYXRlLCBkaWZmRGF0YSwgdmFsaWRhdGVkT3B0aW9ucywgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkLCBwcmV2UHJvcE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVbTEVYSUNPTi5oT1BdKHByb3ApICYmIGRhdGFbTEVYSUNPTi5oT1BdKHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0RpZmYgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVmFsdWUgPSB0ZW1wbGF0ZVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVmFsdWVUeXBlID0gdHlwZSh0ZW1wbGF0ZVZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlSXNDb21wbGV4ID0gdGVtcGxhdGVWYWx1ZVR5cGUgPT0gVFlQRVMubztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVHlwZXMgPSAhQ09NUEFUSUJJTElUWS5pc0EodGVtcGxhdGVWYWx1ZSkgPyBbdGVtcGxhdGVWYWx1ZV0gOiB0ZW1wbGF0ZVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YURpZmZWYWx1ZSA9IGRpZmZEYXRhW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVZhbHVlID0gZGF0YVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFWYWx1ZVR5cGUgPSB0eXBlKGRhdGFWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wUHJlZml4ID0gcHJldlByb3BOYW1lID8gcHJldlByb3BOYW1lICsgJy4nIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IFwiVGhlIG9wdGlvbiBcXFwiXCIgKyBwcm9wUHJlZml4ICsgcHJvcCArIFwiXFxcIiB3YXNuJ3Qgc2V0LCBiZWNhdXNlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvclBvc3NpYmxlVHlwZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yUmVzdHJpY3RlZFN0cmluZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNTcGxpdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNQb3NzaWJpbGl0aWVzU3BsaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1Jlc3RyaWN0ZWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1haW5Qb3NzaWJpbGl0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YURpZmZWYWx1ZSA9IGRhdGFEaWZmVmFsdWUgPT09IHVuZGVmaW5lZCA/IHt9IDogZGF0YURpZmZWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIHRlbXBsYXRlIGhhcyBhIG9iamVjdCBhcyB2YWx1ZSwgaXQgbWVhbnMgdGhhdCB0aGUgb3B0aW9ucyBhcmUgY29tcGxleCAodmVyc2NoYWNodGVsdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlSXNDb21wbGV4ICYmIGRhdGFWYWx1ZVR5cGUgPT0gVFlQRVMubykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkT3B0aW9uc1twcm9wXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkW3Byb3BdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja09iamVjdFByb3BzKGRhdGFWYWx1ZSwgdGVtcGxhdGVWYWx1ZSwgZGF0YURpZmZWYWx1ZSwgdmFsaWRhdGVkT3B0aW9uc1twcm9wXSwgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkW3Byb3BdLCBwcm9wUHJlZml4ICsgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksuZWFjaChbZGF0YSwgdmFsaWRhdGVkT3B0aW9ucywgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkXSwgZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5T2JqKHZhbHVlW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRlbXBsYXRlSXNDb21wbGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcGxhdGVUeXBlc1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyVHlwZSA9IHRlbXBsYXRlVHlwZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVWYWx1ZVR5cGUgPSB0eXBlKGN1cnJUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGN1cnJ0eXBlIGlzIHN0cmluZyBhbmQgc3RhcnRzIHdpdGggcmVzdHJpY3RlZFN0cmluZ1ByZWZpeCBhbmQgZW5kIHdpdGggcmVzdHJpY3RlZFN0cmluZ1N1ZmZpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVzdHJpY3RlZFZhbHVlID0gdGVtcGxhdGVWYWx1ZVR5cGUgPT0gVFlQRVMucyAmJiBpbkFycmF5KGN1cnJUeXBlLCBwb3NzaWJsZVRlbXBsYXRlVHlwZXMpID09PSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JQb3NzaWJsZVR5cGVzLnB1c2goVFlQRVMucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NwbGl0IGl0IGludG8gYSBhcnJheSB3aGljaCBjb250YWlucyBhbGwgcG9zc2libGUgdmFsdWVzIGZvciBleGFtcGxlOiBbXCJ5Onllc1wiLCBcIm46bm9cIiwgXCJtOm1heWJlXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNTcGxpdCA9IGN1cnJUeXBlLnNwbGl0KHJlc3RyaWN0ZWRTdHJpbmdzU3BsaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3RyaWN0ZWRTdHJpbmdzID0gZXJyb3JSZXN0cmljdGVkU3RyaW5ncy5jb25jYXQocmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1NwbGl0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2ID0gMDsgdiA8IHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNTcGxpdFtMRVhJQ09OLmxdOyB2KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3BsaXQgdGhlIHBvc3NpYmxlIHZhbHVlcyBpbnRvIHRoZWlyIHBvc3NpYmlsaXRlaXMgZm9yIGV4YW1wbGU6IFtcInlcIiwgXCJ5ZXNcIl0gLT4gdGhlIGZpcnN0IGlzIGFsd2F5cyB0aGUgbWFpblBvc3NpYmlsaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0cmljdGVkU3RyaW5nVmFsdWVzUG9zc2liaWxpdGllc1NwbGl0ID0gcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1NwbGl0W3ZdLnNwbGl0KHJlc3RyaWN0ZWRTdHJpbmdzUG9zc2liaWxpdGllc1NwbGl0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5Qb3NzaWJpbGl0eSA9IHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNQb3NzaWJpbGl0aWVzU3BsaXRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1Bvc3NpYmlsaXRpZXNTcGxpdFtMRVhJQ09OLmxdOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGFueSBwb3NzaWJpbGl0eSBtYXRjaGVzIHdpdGggdGhlIGRhdGFWYWx1ZSwgaXRzIHZhbGlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWYWx1ZSA9PT0gcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1Bvc3NpYmlsaXRpZXNTcGxpdFtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUG9zc2libGVUeXBlcy5wdXNoKGN1cnJUeXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmFsdWVUeXBlID09PSBjdXJyVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGlmZiA9IGRhdGFWYWx1ZSAhPT0gZGF0YURpZmZWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGlmZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkT3B0aW9uc1twcm9wXSA9IGRhdGFWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFZhbHVlID8gaW5BcnJheShkYXRhRGlmZlZhbHVlLCByZXN0cmljdGVkU3RyaW5nVmFsdWVzUG9zc2liaWxpdGllc1NwbGl0KSA8IDAgOiBpc0RpZmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZFtwcm9wXSA9IGlzUmVzdHJpY3RlZFZhbHVlID8gbWFpblBvc3NpYmlsaXR5IDogZGF0YVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod3JpdGVFcnJvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IgKyBcIiBpdCBkb2Vzbid0IGFjY2VwdCB0aGUgdHlwZSBbIFwiICsgZGF0YVZhbHVlVHlwZS50b1VwcGVyQ2FzZSgpICsgXCIgXSB3aXRoIHRoZSB2YWx1ZSBvZiBcXFwiXCIgKyBkYXRhVmFsdWUgKyBcIlxcXCIuXFxyXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFjY2VwdGVkIHR5cGVzIGFyZTogWyBcIiArIGVycm9yUG9zc2libGVUeXBlcy5qb2luKCcsICcpLnRvVXBwZXJDYXNlKCkgKyBcIiBdLlwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yUmVzdHJpY3RlZFN0cmluZ3NbbGVuZ3RoXSA+IDAgPyBcIlxcclxcblZhbGlkIHN0cmluZ3MgYXJlOiBbIFwiICsgZXJyb3JSZXN0cmljdGVkU3RyaW5ncy5qb2luKCcsICcpLnNwbGl0KHJlc3RyaWN0ZWRTdHJpbmdzUG9zc2liaWxpdGllc1NwbGl0KS5qb2luKCcsICcpICsgXCIgXS5cIiA6ICcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGF0YVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tPYmplY3RQcm9wcyhvYmplY3RDb3B5LCB0ZW1wbGF0ZSwgZGlmZk9iaiB8fCB7fSwgdmFsaWRhdGVkT3B0aW9ucywgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIHZhbHVlcyB3aGljaCBhcmVuJ3Qgc3BlY2lmaWVkIGluIHRoZSB0ZW1wbGF0ZSB0byB0aGUgZmluaXNoZWQgdmFsaWRhdGVkIG9iamVjdCB0byBwcmV2ZW50IHRoZW0gZnJvbSBiZWluZyBkaXNjYXJkZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoa2VlcEZvcmVpZ25Qcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB2YWxpZGF0ZWRPcHRpb25zLCBvYmplY3RDb3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSy5leHRlbmQodHJ1ZSwgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkLCBvYmplY3RDb3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqKG9iamVjdENvcHkpICYmIHdyaXRlRXJyb3JzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGRpc2NhcmRlZCBkdWUgdG8gaW52YWxpZGl0eTpcXHJcXG4nICsgd2luZG93LkpTT04uc3RyaW5naWZ5KG9iamVjdENvcHksIG51bGwsIDIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVmYXVsdDogdmFsaWRhdGVkT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcmVwYXJlZDogdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KCkpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBvYmplY3Qgd2hpY2ggY29udGFpbnMgZ2xvYmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwbHVnaW4gYW5kIGVhY2ggaW5zdGFuY2Ugb2YgaXQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbml0T3ZlcmxheVNjcm9sbGJhcnNTdGF0aWNzKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfcGx1Z2luc0dsb2JhbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgX3BsdWdpbnNHbG9iYWxzID0gbmV3IE92ZXJsYXlTY3JvbGxiYXJzR2xvYmFscyhfcGx1Z2luc09wdGlvbnMuX2RlZmF1bHRzKTtcclxuICAgICAgICAgICAgICAgIGlmICghX3BsdWdpbnNBdXRvVXBkYXRlTG9vcClcclxuICAgICAgICAgICAgICAgICAgICBfcGx1Z2luc0F1dG9VcGRhdGVMb29wID0gbmV3IE92ZXJsYXlTY3JvbGxiYXJzQXV0b1VwZGF0ZUxvb3AoX3BsdWdpbnNHbG9iYWxzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBnbG9iYWwgb2JqZWN0IGZvciB0aGUgT3ZlcmxheVNjcm9sbGJhcnMgb2JqZWN0cy4gSXQgY29udGFpbnMgcmVzb3VyY2VzIHdoaWNoIGV2ZXJ5IE92ZXJsYXlTY3JvbGxiYXJzIG9iamVjdCBuZWVkcy4gVGhpcyBvYmplY3QgaXMgaW5pdGlhbGl6ZWQgb25seSBvbmNlOiBpZiB0aGUgZmlyc3QgT3ZlcmxheVNjcm9sbGJhcnMgb2JqZWN0IGdldHMgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBkZWZhdWx0T3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE92ZXJsYXlTY3JvbGxiYXJzR2xvYmFscyhkZWZhdWx0T3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iYXNlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBzdHJPdmVyZmxvdyA9ICdvdmVyZmxvdyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RySGlkZGVuID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyU2Nyb2xsID0gJ3Njcm9sbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9keUVsZW1lbnQgPSBGUkFNRVdPUksoJ2JvZHknKTtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJEdW1teUVsZW1lbnQgPSBGUkFNRVdPUksoJzxkaXYgaWQ9XCJvcy1kdW1teS1zY3JvbGxiYXItc2l6ZVwiPjxkaXY+PC9kaXY+PC9kaXY+Jyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyRHVtbXlFbGVtZW50MCA9IHNjcm9sbGJhckR1bW15RWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgIHZhciBkdW1teUNvbnRhaW5lckNoaWxkID0gRlJBTUVXT1JLKHNjcm9sbGJhckR1bW15RWxlbWVudC5jaGlsZHJlbignZGl2JykuZXEoMCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvZHlFbGVtZW50LmFwcGVuZChzY3JvbGxiYXJEdW1teUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmhpZGUoKS5zaG93KCk7IC8vZml4IElFOCBidWcgKGluY29ycmVjdCBtZWFzdXJpbmcpXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZVNjcm9sbGJhclNpemUgPSBjYWxjTmF0aXZlU2Nyb2xsYmFyU2l6ZShzY3JvbGxiYXJEdW1teUVsZW1lbnQwKTtcclxuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IG5hdGl2ZVNjcm9sbGJhclNpemUueCA9PT0gMCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBuYXRpdmVTY3JvbGxiYXJTaXplLnkgPT09IDBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgbXNpZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckluZGV4T2YgPSAnaW5kZXhPZic7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clN1YlN0cmluZyA9ICdzdWJzdHJpbmcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2llID0gdWFbc3RySW5kZXhPZl0oJ01TSUUgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWRlbnQgPSB1YVtzdHJJbmRleE9mXSgnVHJpZGVudC8nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IHVhW3N0ckluZGV4T2ZdKCdFZGdlLycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBydiA9IHVhW3N0ckluZGV4T2ZdKCdydjonKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZUludEZ1bmMgPSBwYXJzZUludDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgMTAgb3Igb2xkZXIgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zaWUgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUludEZ1bmModWFbc3RyU3ViU3RyaW5nXShtc2llICsgNSwgdWFbc3RySW5kZXhPZl0oJy4nLCBtc2llKSksIDEwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJpZGVudCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlSW50RnVuYyh1YVtzdHJTdWJTdHJpbmddKHJ2ICsgMywgdWFbc3RySW5kZXhPZl0oJy4nLCBydikpLCAxMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVkZ2UgKElFIDEyKykgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWRnZSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlSW50RnVuYyh1YVtzdHJTdWJTdHJpbmddKGVkZ2UgKyA1LCB1YVtzdHJJbmRleE9mXSgnLicsIGVkZ2UpKSwgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciBicm93c2VyXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgRlJBTUVXT1JLLmV4dGVuZChfYmFzZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBtc2llOiBtc2llLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9VcGRhdGVMb29wOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlUmVjb21tZW5kZWQ6ICFDT01QQVRJQklMSVRZLm1PKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlU2Nyb2xsYmFyU2l6ZTogbmF0aXZlU2Nyb2xsYmFyU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkOiBuYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVNjcm9sbGJhclN0eWxpbmc6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmFkZENsYXNzKCdvcy12aWV3cG9ydC1uYXRpdmUtc2Nyb2xsYmFycy1pbnZpc2libGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChzY3JvbGxiYXJEdW1teUVsZW1lbnQuY3NzKCdzY3JvbGxiYXItd2lkdGgnKSA9PT0gJ25vbmUnICYmIChtc2llID4gOSB8fCAhbXNpZSkpIHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGJhckR1bW15RWxlbWVudDAsICc6Oi13ZWJraXQtc2Nyb2xsYmFyJykuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpID09PSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7IH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZml4IG9wZXJhIGJ1Zzogc2Nyb2xsYmFyIHN0eWxlcyB3aWxsIG9ubHkgYXBwZWFyIGlmIG92ZXJmbG93IHZhbHVlIGlzIHNjcm9sbCBvciBhdXRvIGR1cmluZyB0aGUgYWN0aXZhdGlvbiBvZiB0aGUgc3R5bGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYW5kIHNldCBvdmVyZmxvdyB0byBzY3JvbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJEdW1teUVsZW1lbnQuY3NzKHN0ck92ZXJmbG93LCBzdHJIaWRkZW4pLmhpZGUoKS5jc3Moc3RyT3ZlcmZsb3csIHN0clNjcm9sbCkuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybiAoc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLm9IXSAtIHNjcm9sbGJhckR1bW15RWxlbWVudDBbTEVYSUNPTi5jSF0pID09PSAwICYmIChzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04ub1ddIC0gc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLmNXXSkgPT09IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZTogeyB4OiAzMCwgeTogMzAgfSxcclxuICAgICAgICAgICAgICAgICAgICBjc3NDYWxjOiBWRU5ET1JTLl9jc3NQcm9wZXJ0eVZhbHVlKCd3aWR0aCcsICdjYWxjJywgJygxcHgpJykgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICByZXN0cmljdGVkTWVhc3VyaW5nOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2h0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MzkzMDVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zaW5jZSAxLjExLjAgYWx3YXlzIGZhbHNlIC0+IGZpeGVkIHZpYSBDU1MgKGhvcGVmdWxseSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmNzcyhzdHJPdmVyZmxvdywgc3RySGlkZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04uc1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLnNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQuY3NzKHN0ck92ZXJmbG93LCAndmlzaWJsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsU2l6ZTIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04uc1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLnNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNjcm9sbFNpemUudyAtIHNjcm9sbFNpemUyLncpICE9PSAwIHx8IChzY3JvbGxTaXplLmggLSBzY3JvbGxTaXplMi5oKSAhPT0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ0bFNjcm9sbEJlaGF2aW9yOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQuY3NzKHsgJ292ZXJmbG93LXknOiBzdHJIaWRkZW4sICdvdmVyZmxvdy14Jzogc3RyU2Nyb2xsLCAnZGlyZWN0aW9uJzogJ3J0bCcgfSkuc2Nyb2xsTGVmdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1bW15Q29udGFpbmVyT2Zmc2V0ID0gc2Nyb2xsYmFyRHVtbXlFbGVtZW50Lm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHVtbXlDb250YWluZXJDaGlsZE9mZnNldCA9IGR1bW15Q29udGFpbmVyQ2hpbGQub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL0tpbmdTb3JhL092ZXJsYXlTY3JvbGxiYXJzL2lzc3Vlcy8xODdcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LnNjcm9sbExlZnQoLTk5OSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0QWZ0ZXJTY3JvbGwgPSBkdW1teUNvbnRhaW5lckNoaWxkLm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vcmlnaW4gZGlyZWN0aW9uID0gZGV0ZXJtaW5lcyBpZiB0aGUgemVybyBzY3JvbGwgcG9zaXRpb24gaXMgb24gdGhlIGxlZnQgb3IgcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8naScgbWVhbnMgJ2ludmVydCcgKGkgPT09IHRydWUgbWVhbnMgdGhhdCB0aGUgYXhpcyBtdXN0IGJlIGludmVydGVkIHRvIGJlIGNvcnJlY3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgPSBvbiB0aGUgbGVmdCBzaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZhbHNlID0gb24gdGhlIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk6IGR1bW15Q29udGFpbmVyT2Zmc2V0LmxlZnQgPT09IGR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbmVnYXRpdmUgPSBkZXRlcm1pbmVzIGlmIHRoZSBtYXhpbXVtIHNjcm9sbCBpcyBwb3NpdGl2ZSBvciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8nbicgbWVhbnMgJ25lZ2F0ZScgKG4gPT09IHRydWUgbWVhbnMgdGhhdCB0aGUgYXhpcyBtdXN0IGJlIG5lZ2F0ZWQgdG8gYmUgY29ycmVjdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSA9IG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZhbHNlID0gcG9zaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG46IGR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXQubGVmdCAhPT0gZHVtbXlDb250YWluZXJDaGlsZE9mZnNldEFmdGVyU2Nyb2xsLmxlZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRUcmFuc2Zvcm06ICEhVkVORE9SUy5fY3NzUHJvcGVydHkoJ3RyYW5zZm9ybScpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRUcmFuc2l0aW9uOiAhIVZFTkRPUlMuX2Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uJyksXHJcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydFBhc3NpdmVFdmVudHM6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydFJlc2l6ZU9ic2VydmVyOiAhIUNPTVBBVElCSUxJVFkuck8oKSxcclxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0TXV0YXRpb25PYnNlcnZlcjogISFDT01QQVRJQklMSVRZLm1PKClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHNjcm9sbGJhckR1bW15RWxlbWVudC5yZW1vdmVBdHRyKExFWElDT04ucykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9DYXRjaCB6b29tIGV2ZW50OlxyXG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIG5hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWJzID0gTUFUSC5hYnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gQ09NUEFUSUJJTElUWS53VygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSBDT01QQVRJQklMSVRZLndIKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd0RwciA9IGdldFdpbmRvd0RQUigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvblJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKElOU1RBTkNFUygpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdXID0gQ09NUEFUSUJJTElUWS53VygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0ggPSBDT01QQVRJQklMSVRZLndIKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFXID0gbmV3VyAtIHdpbmRvd1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhSCA9IG5ld0ggLSB3aW5kb3dIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhVyA9PT0gMCAmJiBkZWx0YUggPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVdSYXRpbyA9IE1BVEgucm91bmQobmV3VyAvICh3aW5kb3dXaWR0aCAvIDEwMC4wKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFIUmF0aW8gPSBNQVRILnJvdW5kKG5ld0ggLyAod2luZG93SGVpZ2h0IC8gMTAwLjApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnNEZWx0YVcgPSBhYnMoZGVsdGFXKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnNEZWx0YUggPSBhYnMoZGVsdGFIKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnNEZWx0YVdSYXRpbyA9IGFicyhkZWx0YVdSYXRpbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWJzRGVsdGFIUmF0aW8gPSBhYnMoZGVsdGFIUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0RQUiA9IGdldFdpbmRvd0RQUigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YUlzQmlnZ2VyID0gYWJzRGVsdGFXID4gMiAmJiBhYnNEZWx0YUggPiAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAhZGlmZmVyZW5jZUlzQmlnZ2VyVGhhbk9uZShhYnNEZWx0YVdSYXRpbywgYWJzRGVsdGFIUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRwckNoYW5nZWQgPSBuZXdEUFIgIT09IHdpbmRvd0RwciAmJiB3aW5kb3dEcHIgPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzWm9vbSA9IGRlbHRhSXNCaWdnZXIgJiYgZGlmZmVyZW5jZSAmJiBkcHJDaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFNjcm9sbGJhclNpemUgPSBfYmFzZS5uYXRpdmVTY3JvbGxiYXJTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Njcm9sbGJhclNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzWm9vbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlFbGVtZW50LmFwcGVuZChzY3JvbGxiYXJEdW1teUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njcm9sbGJhclNpemUgPSBfYmFzZS5uYXRpdmVTY3JvbGxiYXJTaXplID0gY2FsY05hdGl2ZVNjcm9sbGJhclNpemUoc2Nyb2xsYmFyRHVtbXlFbGVtZW50WzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFNjcm9sbGJhclNpemUueCAhPT0gbmV3U2Nyb2xsYmFyU2l6ZS54IHx8IG9sZFNjcm9sbGJhclNpemUueSAhPT0gbmV3U2Nyb2xsYmFyU2l6ZS55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSy5lYWNoKElOU1RBTkNFUygpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoSU5TVEFOQ0VTKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElOU1RBTkNFUyh0aGlzKS51cGRhdGUoJ3pvb20nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1dpZHRoID0gbmV3VztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0hlaWdodCA9IG5ld0g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dEcHIgPSBuZXdEUFI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkaWZmZXJlbmNlSXNCaWdnZXJUaGFuT25lKHZhbE9uZSwgdmFsVHdvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnNWYWxPbmUgPSBhYnModmFsT25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFic1ZhbFR3byA9IGFicyh2YWxUd28pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIShhYnNWYWxPbmUgPT09IGFic1ZhbFR3byB8fCBhYnNWYWxPbmUgKyAxID09PSBhYnNWYWxUd28gfHwgYWJzVmFsT25lIC0gMSA9PT0gYWJzVmFsVHdvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFdpbmRvd0RQUigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGREUEkgPSB3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNEUEkgPSB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJIHx8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAoZERQSSAvIHNEUEkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLKHdpbmRvdykub24oJ3Jlc2l6ZScsIG9uUmVzaXplKTtcclxuICAgICAgICAgICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FsY05hdGl2ZVNjcm9sbGJhclNpemUobWVhc3VyZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBtZWFzdXJlRWxlbWVudFtMRVhJQ09OLm9IXSAtIG1lYXN1cmVFbGVtZW50W0xFWElDT04uY0hdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBtZWFzdXJlRWxlbWVudFtMRVhJQ09OLm9XXSAtIG1lYXN1cmVFbGVtZW50W0xFWElDT04uY1ddXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBvYmplY3Qgd2hpY2ggbWFuYWdlcyB0aGUgYXV0byB1cGRhdGUgbG9vcCBmb3IgYWxsIE92ZXJsYXlTY3JvbGxiYXJzIG9iamVjdHMuIFRoaXMgb2JqZWN0IGlzIGluaXRpYWxpemVkIG9ubHkgb25jZTogaWYgdGhlIGZpcnN0IE92ZXJsYXlTY3JvbGxiYXJzIG9iamVjdCBnZXRzIGluaXRpYWxpemVkLlxyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE92ZXJsYXlTY3JvbGxiYXJzQXV0b1VwZGF0ZUxvb3AoZ2xvYmFscykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iYXNlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBfaW5BcnJheSA9IEZSQU1FV09SSy5pbkFycmF5O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9nZXROb3cgPSBDT01QQVRJQklMSVRZLm5vdztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyQXV0b1VwZGF0ZSA9ICdhdXRvVXBkYXRlJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyQXV0b1VwZGF0ZUludGVydmFsID0gX3N0ckF1dG9VcGRhdGUgKyAnSW50ZXJ2YWwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJMZW5ndGggPSBMRVhJQ09OLmw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BpbmdJbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9vcGluZ0luc3RhbmNlc0ludGVydmFsQ2FjaGUgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9vcElzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BJbnRlcnZhbERlZmF1bHQgPSAzMztcclxuICAgICAgICAgICAgICAgIHZhciBfbG9vcEludGVydmFsID0gX2xvb3BJbnRlcnZhbERlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BUaW1lT2xkID0gX2dldE5vdygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wSUQ7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGF1dG8gdXBkYXRlIGxvb3Agd2hpY2ggd2lsbCBydW4gZXZlcnkgNTAgbWlsbGlzZWNvbmRzIG9yIGxlc3MgaWYgdGhlIHVwZGF0ZSBpbnRlcnZhbCBvZiBhIGluc3RhbmNlIGlzIGxvd2VyIHRoYW4gNTAgbWlsbGlzZWNvbmRzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2xvb3BpbmdJbnN0YW5jZXNbX3N0ckxlbmd0aF0gPiAwICYmIF9sb29wSXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BJRCA9IENPTVBBVElCSUxJVFkuckFGKCkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVOZXcgPSBfZ2V0Tm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lRGVsdGEgPSB0aW1lTmV3IC0gX2xvb3BUaW1lT2xkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXN0SW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlT3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQXV0b1VwZGF0ZUFsbG93ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUF1dG9VcGRhdGVJbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lRGVsdGEgPiBfbG9vcEludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcFRpbWVPbGQgPSB0aW1lTmV3IC0gKHRpbWVEZWx0YSAlIF9sb29wSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0SW50ZXJ2YWwgPSBfbG9vcEludGVydmFsRGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2xvb3BpbmdJbnN0YW5jZXNbX3N0ckxlbmd0aF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gX2xvb3BpbmdJbnN0YW5jZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VPcHRpb25zID0gaW5zdGFuY2Uub3B0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUF1dG9VcGRhdGVBbGxvd2VkID0gaW5zdGFuY2VPcHRpb25zW19zdHJBdXRvVXBkYXRlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VBdXRvVXBkYXRlSW50ZXJ2YWwgPSBNQVRILm1heCgxLCBpbnN0YW5jZU9wdGlvbnNbX3N0ckF1dG9VcGRhdGVJbnRlcnZhbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBfZ2V0Tm93KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGluc3RhbmNlQXV0b1VwZGF0ZUFsbG93ZWQgPT09IHRydWUgfHwgaW5zdGFuY2VBdXRvVXBkYXRlQWxsb3dlZCA9PT0gbnVsbCkgJiYgKG5vdyAtIF9sb29waW5nSW5zdGFuY2VzSW50ZXJ2YWxDYWNoZVtpXSkgPiBpbnN0YW5jZUF1dG9VcGRhdGVJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCdhdXRvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcGluZ0luc3RhbmNlc0ludGVydmFsQ2FjaGVbaV0gPSBuZXcgRGF0ZShub3cgKz0gaW5zdGFuY2VBdXRvVXBkYXRlSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RJbnRlcnZhbCA9IE1BVEgubWF4KDEsIE1BVEgubWluKGxvd2VzdEludGVydmFsLCBpbnN0YW5jZUF1dG9VcGRhdGVJbnRlcnZhbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wSW50ZXJ2YWwgPSBsb3dlc3RJbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wSW50ZXJ2YWwgPSBfbG9vcEludGVydmFsRGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlIHRvIHRoZSBhdXRvIHVwZGF0ZSBsb29wLiBPbmx5IHN1Y2Nlc3NmdWwgaWYgdGhlIGluc3RhbmNlIGlzbid0IGFscmVhZHkgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHdoaWNoIHNoYWxsIGJlIHVwZGF0ZWQgaW4gYSBsb29wIGF1dG9tYXRpY2FsbHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLmFkZCA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaW5BcnJheShpbnN0YW5jZSwgX2xvb3BpbmdJbnN0YW5jZXMpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcGluZ0luc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BpbmdJbnN0YW5jZXNJbnRlcnZhbENhY2hlLnB1c2goX2dldE5vdygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9sb29waW5nSW5zdGFuY2VzW19zdHJMZW5ndGhdID4gMCAmJiAhX2xvb3BJc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BJc0FjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxzLmF1dG9VcGRhdGVMb29wID0gX2xvb3BJc0FjdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmUgT3ZlcmxheVNjcm9sbGJhcnMgaW5zdGFuY2UgZnJvbSB0aGUgYXV0byB1cGRhdGUgbG9vcC4gT25seSBzdWNjZXNzZnVsIGlmIHRoZSBpbnN0YW5jZSB3YXMgYWRkZWQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGluc3RhbmNlIFRoZSBpbnN0YW5jZSB3aGljaCBzaGFsbCBiZSB1cGRhdGVkIGluIGEgbG9vcCBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfaW5BcnJheShpbnN0YW5jZSwgX2xvb3BpbmdJbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGZyb20gbG9vcGluZ0luc3RhbmNlcyBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29waW5nSW5zdGFuY2VzSW50ZXJ2YWxDYWNoZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcGluZ0luc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0IHVwZGF0ZSBsb29wIGJlaGF2aW9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbG9vcGluZ0luc3RhbmNlc1tfc3RyTGVuZ3RoXSA9PT0gMCAmJiBfbG9vcElzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcElzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxzLmF1dG9VcGRhdGVMb29wID0gX2xvb3BJc0FjdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbG9vcElEICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLmNBRigpKF9sb29wSUQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wSUQgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIG9iamVjdCB3aGljaCBtYW5hZ2VzIHRoZSBzY3JvbGxiYXJzIHZpc2liaWxpdHkgb2YgdGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gcGx1Z2luVGFyZ2V0RWxlbWVudCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRoZSBzY3JvbGxiYXJzIHNoYWxsIGJlIGhpZGRlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGN1c3RvbSBvcHRpb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgY3VzdG9tIGV4dGVuc2lvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBnbG9iYWxzXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBhdXRvVXBkYXRlTG9vcFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBPdmVybGF5U2Nyb2xsYmFyc0luc3RhbmNlKHBsdWdpblRhcmdldEVsZW1lbnQsIG9wdGlvbnMsIGV4dGVuc2lvbnMsIGdsb2JhbHMsIGF1dG9VcGRhdGVMb29wKSB7XHJcbiAgICAgICAgICAgICAgICAvL3Nob3J0Y3V0c1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBDT01QQVRJQklMSVRZLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5BcnJheSA9IEZSQU1FV09SSy5pbkFycmF5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGVhY2ggPSBGUkFNRVdPUksuZWFjaDtcclxuXHJcbiAgICAgICAgICAgICAgICAvL21ha2UgY29ycmVjdCBpbnN0YW5jZW9mXHJcbiAgICAgICAgICAgICAgICB2YXIgX2Jhc2UgPSBuZXcgX3BsdWdpbigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZXdvcmtQcm90byA9IEZSQU1FV09SS1tMRVhJQ09OLnBdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgcGFzc2VkIGVsZW1lbnQgaXMgbm8gSFRNTCBlbGVtZW50OiBza2lwIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgIGlmICghaXNIVE1MRWxlbWVudChwbHVnaW5UYXJnZXRFbGVtZW50KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiBwYXNzZWQgZWxlbWVudCBpcyBhbHJlYWR5IGluaXRpYWxpemVkOiBzZXQgcGFzc2VkIG9wdGlvbnMgaWYgdGhlcmUgYXJlIGFueSBhbmQgcmV0dXJuIGl0cyBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgaWYgKElOU1RBTkNFUyhwbHVnaW5UYXJnZXRFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0ID0gSU5TVEFOQ0VTKHBsdWdpblRhcmdldEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3Qub3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2dsb2JhbHM6XHJcbiAgICAgICAgICAgICAgICB2YXIgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3J0bFNjcm9sbEJlaGF2aW9yO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hdXRvVXBkYXRlUmVjb21tZW5kZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX21zaWVWZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NDYWxjO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9uYXRpdmVTY3JvbGxiYXJTaXplO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdXBwb3J0VHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBfc3VwcG9ydFRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIHZhciBfc3VwcG9ydFBhc3NpdmVFdmVudHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N1cHBvcnRSZXNpemVPYnNlcnZlcjtcclxuICAgICAgICAgICAgICAgIHZhciBfc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc3RyaWN0ZWRNZWFzdXJpbmc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9nZW5lcmFsIHJlYWRvbmx5OlxyXG4gICAgICAgICAgICAgICAgdmFyIF9pbml0aWFsaXplZDtcclxuICAgICAgICAgICAgICAgIHZhciBfZGVzdHJveWVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9pc1RleHRhcmVhO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9pc0JvZHk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RvY3VtZW50TWl4ZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RvbUV4aXN0cztcclxuXHJcbiAgICAgICAgICAgICAgICAvL2dlbmVyYWw6XHJcbiAgICAgICAgICAgICAgICB2YXIgX2lzQm9yZGVyQm94O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zaXplQXV0b09ic2VydmVyQWRkZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3BhZGRpbmdYO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9wYWRkaW5nWTtcclxuICAgICAgICAgICAgICAgIHZhciBfYm9yZGVyWDtcclxuICAgICAgICAgICAgICAgIHZhciBfYm9yZGVyWTtcclxuICAgICAgICAgICAgICAgIHZhciBfbWFyZ2luWDtcclxuICAgICAgICAgICAgICAgIHZhciBfbWFyZ2luWTtcclxuICAgICAgICAgICAgICAgIHZhciBfaXNSVEw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3NsZWVwaW5nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50Qm9yZGVyU2l6ZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxIb3Jpem9udGFsSW5mbyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxWZXJ0aWNhbEluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBfdmlld3BvcnRTaXplID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgX25hdGl2ZVNjcm9sbGJhck1pblNpemUgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL25hbWluZzpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNaW51c0hpZGRlbiA9ICctaGlkZGVuJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTWFyZ2luTWludXMgPSAnbWFyZ2luLSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clBhZGRpbmdNaW51cyA9ICdwYWRkaW5nLSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckJvcmRlck1pbnVzID0gJ2JvcmRlci0nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJUb3AgPSAndG9wJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyUmlnaHQgPSAncmlnaHQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJCb3R0b20gPSAnYm90dG9tJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTGVmdCA9ICdsZWZ0JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTWluTWludXMgPSAnbWluLSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1heE1pbnVzID0gJ21heC0nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJXaWR0aCA9ICd3aWR0aCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckhlaWdodCA9ICdoZWlnaHQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJGbG9hdCA9ICdmbG9hdCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckVtcHR5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckF1dG8gPSAnYXV0byc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clN5bmMgPSAnc3luYyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clNjcm9sbCA9ICdzY3JvbGwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJIdW5kcmVkUGVyY2VudCA9ICcxMDAlJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyWCA9ICd4JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyWSA9ICd5JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyRG90ID0gJy4nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJTcGFjZSA9ICcgJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyU2Nyb2xsYmFyID0gJ3Njcm9sbGJhcic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1pbnVzSG9yaXpvbnRhbCA9ICctaG9yaXpvbnRhbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1pbnVzVmVydGljYWwgPSAnLXZlcnRpY2FsJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyU2Nyb2xsTGVmdCA9IF9zdHJTY3JvbGwgKyAnTGVmdCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clNjcm9sbFRvcCA9IF9zdHJTY3JvbGwgKyAnVG9wJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTW91c2VUb3VjaERvd25FdmVudCA9ICdtb3VzZWRvd24gdG91Y2hzdGFydCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1vdXNlVG91Y2hVcEV2ZW50ID0gJ21vdXNldXAgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNb3VzZVRvdWNoTW92ZUV2ZW50ID0gJ21vdXNlbW92ZSB0b3VjaG1vdmUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNb3VzZUVudGVyID0gJ21vdXNlZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNb3VzZUxlYXZlID0gJ21vdXNlbGVhdmUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJLZXlEb3duRXZlbnQgPSAna2V5ZG93bic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0cktleVVwRXZlbnQgPSAna2V5dXAnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJTZWxlY3RTdGFydEV2ZW50ID0gJ3NlbGVjdHN0YXJ0JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyVHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQgd2Via2l0VHJhbnNpdGlvbkVuZCBvVHJhbnNpdGlvbkVuZCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clJlc2l6ZU9ic2VydmVyUHJvcGVydHkgPSAnX19vdmVybGF5U2Nyb2xsYmFyc1JPX18nO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY2xhc3MgbmFtZXM6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfY2Fzc05hbWVzUHJlZml4ID0gJ29zLSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhUTUxFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdodG1sJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ2hvc3QnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0RWxlbWVudEZvcmVpZ24gPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLWZvcmVpZ24nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0VGV4dGFyZWFFbGVtZW50ID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy10ZXh0YXJlYSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RTY3JvbGxiYXJIb3Jpem9udGFsSGlkZGVuID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy0nICsgX3N0clNjcm9sbGJhciArIF9zdHJNaW51c0hvcml6b250YWwgKyBfc3RyTWludXNIaWRkZW47XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RTY3JvbGxiYXJWZXJ0aWNhbEhpZGRlbiA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctJyArIF9zdHJTY3JvbGxiYXIgKyBfc3RyTWludXNWZXJ0aWNhbCArIF9zdHJNaW51c0hpZGRlbjtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdFRyYW5zaXRpb24gPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLXRyYW5zaXRpb24nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0UlRMID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy1ydGwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0UmVzaXplRGlzYWJsZWQgPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLXJlc2l6ZS1kaXNhYmxlZCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RTY3JvbGxpbmcgPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLXNjcm9sbGluZyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RPdmVyZmxvdyA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctb3ZlcmZsb3cnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3cgPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLW92ZXJmbG93JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdE92ZXJmbG93WCA9IF9jbGFzc05hbWVIb3N0T3ZlcmZsb3cgKyAnLXgnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3dZID0gX2NsYXNzTmFtZUhvc3RPdmVyZmxvdyArICcteSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVRleHRhcmVhRWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAndGV4dGFyZWEnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVUZXh0YXJlYUNvdmVyRWxlbWVudCA9IF9jbGFzc05hbWVUZXh0YXJlYUVsZW1lbnQgKyAnLWNvdmVyJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lUGFkZGluZ0VsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3BhZGRpbmcnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVWaWV3cG9ydEVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3ZpZXdwb3J0JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzSW52aXNpYmxlID0gX2NsYXNzTmFtZVZpZXdwb3J0RWxlbWVudCArICctbmF0aXZlLXNjcm9sbGJhcnMtaW52aXNpYmxlJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQgPSBfY2xhc3NOYW1lVmlld3BvcnRFbGVtZW50ICsgJy1uYXRpdmUtc2Nyb2xsYmFycy1vdmVybGFpZCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUNvbnRlbnRFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdjb250ZW50JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lQ29udGVudEFycmFuZ2VFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdjb250ZW50LWFycmFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVDb250ZW50R2x1ZUVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ2NvbnRlbnQtZ2x1ZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdzaXplLWF1dG8tb2JzZXJ2ZXInO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3Jlc2l6ZS1vYnNlcnZlcic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3Jlc2l6ZS1vYnNlcnZlci1pdGVtJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRmluYWxFbGVtZW50ID0gX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUVsZW1lbnQgKyAnLWZpbmFsJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVGV4dEluaGVyaXQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3RleHQtaW5oZXJpdCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhciA9IF9jYXNzTmFtZXNQcmVmaXggKyBfc3RyU2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJUcmFjayA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyAnLXRyYWNrJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2tPZmYgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2sgKyAnLW9mZic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZSA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyAnLWhhbmRsZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZU9mZiA9IF9jbGFzc05hbWVTY3JvbGxiYXJIYW5kbGUgKyAnLW9mZic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhclVudXNhYmxlID0gX2NsYXNzTmFtZVNjcm9sbGJhciArICctdW51c2FibGUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZGVuID0gX2NsYXNzTmFtZVNjcm9sbGJhciArICctJyArIF9zdHJBdXRvICsgX3N0ck1pbnVzSGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXIgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyICsgJy1jb3JuZXInO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemUgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyICsgJy1yZXNpemUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVCID0gX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZSArICctYm90aCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZUggPSBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplICsgX3N0ck1pbnVzSG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplViA9IF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemUgKyBfc3RyTWludXNWZXJ0aWNhbDtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFySG9yaXpvbnRhbCA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyBfc3RyTWludXNIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJWZXJ0aWNhbCA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyBfc3RyTWludXNWZXJ0aWNhbDtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lRHJhZ2dpbmcgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ2RyYWdnaW5nJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVGhlbWVOb25lID0gX2Nhc3NOYW1lc1ByZWZpeCArICd0aGVtZS1ub25lJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lc0R5bmFtaWNEZXN0cm95ID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVWaWV3cG9ydE5hdGl2ZVNjcm9sbGJhcnNJbnZpc2libGUsXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVZpZXdwb3J0TmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJUcmFja09mZixcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlT2ZmLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJVbnVzYWJsZSxcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGRlbixcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVCLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVILFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVWLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVEcmFnZ2luZ10uam9pbihfc3RyU3BhY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY2FsbGJhY2tzOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NhbGxiYWNrc0luaXRRZXVldWUgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2F0dHJzIHZpZXdwb3J0IHNoYWxsIGluaGVyaXQgZnJvbSB0YXJnZXRcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF92aWV3cG9ydEF0dHJzRnJvbVRhcmdldCA9IFtMRVhJQ09OLnRpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL29wdGlvbnM6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfZGVmYXVsdE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2N1cnJlbnRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jdXJyZW50UHJlcGFyZWRPcHRpb25zO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZXh0ZW5zaW9uczpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9leHRlbnNpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgX2V4dGVuc2lvbnNQcml2YXRlTWV0aG9kcyA9ICdhZGRlZCByZW1vdmVkIG9uIGNvbnRyYWN0JztcclxuXHJcbiAgICAgICAgICAgICAgICAvL3VwZGF0ZVx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xhc3RVcGRhdGVUaW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zd2FsbG93ZWRVcGRhdGVIaW50cyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zd2FsbG93ZWRVcGRhdGVUaW1lb3V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zd2FsbG93VXBkYXRlTGFnID0gNDI7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3VwZGF0ZU9uTG9hZEV2ZW50TmFtZSA9ICdsb2FkJztcclxuICAgICAgICAgICAgICAgIHZhciBfdXBkYXRlT25Mb2FkRWxtcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vRE9NIGVsZW1lbnRzOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3dpbmRvd0VsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RvY3VtZW50RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfaHRtbEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2JvZHlFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF90YXJnZXRFbGVtZW50OyAgICAgICAgICAgICAgICAgICAgIC8vdGhlIHRhcmdldCBlbGVtZW50IG9mIHRoaXMgT3ZlcmxheVNjcm9sbGJhcnMgb2JqZWN0XHRcclxuICAgICAgICAgICAgICAgIHZhciBfaG9zdEVsZW1lbnQ7ICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBob3N0IGVsZW1lbnQgb2YgdGhpcyBPdmVybGF5U2Nyb2xsYmFycyBvYmplY3QgLT4gbWF5IGJlIHRoZSBzYW1lIGFzIHRhcmdldEVsZW1lbnRcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9zaXplQXV0b09ic2VydmVyRWxlbWVudDsgICAgICAgICAgIC8vb2JzZXJ2ZXMgc2l6ZSBhdXRvIGNoYW5nZXNcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9zaXplT2JzZXJ2ZXJFbGVtZW50OyAgICAgICAgICAgICAgIC8vb2JzZXJ2ZXMgc2l6ZSBhbmQgcGFkZGluZyBjaGFuZ2VzXHRcclxuICAgICAgICAgICAgICAgIHZhciBfcGFkZGluZ0VsZW1lbnQ7ICAgICAgICAgICAgICAgICAgICAvL21hbmFnZXMgdGhlIHBhZGRpbmdcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF92aWV3cG9ydEVsZW1lbnQ7ICAgICAgICAgICAgICAgICAgIC8vaXMgdGhlIHZpZXdwb3J0IG9mIG91ciBzY3JvbGxiYXIgbW9kZWxcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50RWxlbWVudDsgICAgICAgICAgICAgICAgICAgIC8vdGhlIGVsZW1lbnQgd2hpY2ggaG9sZHMgdGhlIGNvbnRlbnRcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50QXJyYW5nZUVsZW1lbnQ7ICAgICAgICAgICAgIC8vaXMgbmVlZGVkIGZvciBjb3JyZWN0IHNpemluZyBvZiB0aGUgY29udGVudCBlbGVtZW50IChvbmx5IGlmIG5hdGl2ZSBzY3JvbGxiYXJzIGFyZSBvdmVybGF5cylcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50R2x1ZUVsZW1lbnQ7ICAgICAgICAgICAgICAgIC8vaGFzIGFsd2F5cyB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBlbGVtZW50XHRcclxuICAgICAgICAgICAgICAgIHZhciBfdGV4dGFyZWFDb3ZlckVsZW1lbnQ7ICAgICAgICAgICAgICAvL29ubHkgYXBwbGllZCBpZiB0YXJnZXQgaXMgYSB0ZXh0YXJlYSBlbGVtZW50LiBVc2VkIGZvciBjb3JyZWN0IHNpemUgY2FsY3VsYXRpb24gYW5kIGZvciBwcmV2ZW50aW9uIG9mIHVuY29udHJvbGxlZCBzY3JvbGxpbmdcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFySG9yaXpvbnRhbFRyYWNrRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFySG9yaXpvbnRhbEhhbmRsZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyVmVydGljYWxUcmFja0VsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhclZlcnRpY2FsSGFuZGxlRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfd2luZG93RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfZG9jdW1lbnRFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF90YXJnZXRFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9ob3N0RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3NpemVPYnNlcnZlckVsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3BhZGRpbmdFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF92aWV3cG9ydEVsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRlbnRFbGVtZW50TmF0aXZlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQ2FjaGU6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfaG9zdFNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY29udGVudFNjcm9sbFNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfYXJyYW5nZUNvbnRlbnRTaXplQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2hhc092ZXJmbG93Q2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2hpZGVPdmVyZmxvd0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF93aWR0aEF1dG9DYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfaGVpZ2h0QXV0b0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NCb3hTaXppbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY3NzUGFkZGluZ0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NCb3JkZXJDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY3NzTWFyZ2luQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Nzc0RpcmVjdGlvbkNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NEaXJlY3Rpb25EZXRlY3RlZENhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9wYWRkaW5nQWJzb2x1dGVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xpcEFsd2F5c0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50R2x1ZVNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9vdmVyZmxvd0Ftb3VudENhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9pZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2F1dG9VcGRhdGVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2l6ZUF1dG9DYXBhYmxlQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZUNoYW5nZURldGVjdGVkQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2hvc3RFbGVtZW50U2l6ZUNoYW5nZURldGVjdGVkQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNWaXNpYmlsaXR5Q2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNBdXRvSGlkZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfcmVzaXplQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX25vcm1hbGl6ZVJUTENhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfb2xkQ2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0YXJlYUF1dG9XcmFwcGluZ0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0YXJlYUluZm9DYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfdGV4dGFyZWFTaXplQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RleHRhcmVhRHluSGVpZ2h0Q2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RleHRhcmVhRHluV2lkdGhDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfYm9keU1pblNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfdXBkYXRlQXV0b0NhY2hlID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgLy9NdXRhdGlvbk9ic2VydmVyOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX211dGF0aW9uT2JzZXJ2ZXJIb3N0O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tdXRhdGlvbk9ic2VydmVyQ29udGVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfbXV0YXRpb25PYnNlcnZlckhvc3RDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIHZhciBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnRDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIHZhciBfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX211dGF0aW9uT2JzZXJ2ZXJBdHRyc1RleHRhcmVhID0gWyd3cmFwJywgJ2NvbHMnLCAncm93cyddO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tdXRhdGlvbk9ic2VydmVyQXR0cnNIb3N0ID0gW0xFWElDT04uaSwgTEVYSUNPTi5jLCBMRVhJQ09OLnMsICdvcGVuJ10uY29uY2F0KF92aWV3cG9ydEF0dHJzRnJvbVRhcmdldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ldmVudHM6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfZGVzdHJveUV2ZW50cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdGV4dGFyZWE6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfdGV4dGFyZWFIYXNGb2N1cztcclxuXHJcbiAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnM6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlVGltZW91dElkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlVGltZW91dElkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQXV0b0hpZGVEZWxheTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlTmV2ZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNIYW5kbGVIb3ZlcmVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcztcclxuXHJcbiAgICAgICAgICAgICAgICAvL3Jlc2l6ZVx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc2l6ZU5vbmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc2l6ZUJvdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc2l6ZUhvcml6b250YWw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc2l6ZVZlcnRpY2FsO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gRXZlbnQgTGlzdGVuZXIgPT09PS8vXHRcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcdFxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBvciByZW1vdmVzIGEgZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC4gXHRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBldmVudCBsaXN0ZW5lciBzaGFsbCBiZSBhcHBsaWVkIG9yIHJlbW92ZWQuXHRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBldmVudE5hbWVzIFRoZSBuYW1lKHMpIG9mIHRoZSBldmVudHMuXHRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbWV0aG9kIHdoaWNoIHNoYWxsIGJlIGNhbGxlZC5cdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHJlbW92ZSBUcnVlIGlmIHRoZSBoYW5kbGVyIHNoYWxsIGJlIHJlbW92ZWQsIGZhbHNlIG9yIHVuZGVmaW5lZCBpZiB0aGUgaGFuZGxlciBzaGFsbCBiZSBhZGRlZC5cdFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZXMsIGxpc3RlbmVyLCByZW1vdmUsIHBhc3NpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGVkID0gQ09NUEFUSUJJTElUWS5pc0EoZXZlbnROYW1lcykgJiYgQ09NUEFUSUJJTElUWS5pc0EobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSByZW1vdmUgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnYWRkRXZlbnRMaXN0ZW5lcic7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uT2ZmID0gcmVtb3ZlID8gJ29mZicgOiAnb24nO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSBjb2xsZWN0ZWQgPyBmYWxzZSA6IGV2ZW50TmFtZXMuc3BsaXQoX3N0clNwYWNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGV2ZW50TmFtZXNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWVzW2ldLCBsaXN0ZW5lcltpXSwgcmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZXZlbnRzW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0UGFzc2l2ZUV2ZW50cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50WzBdW21ldGhvZF0oZXZlbnRzW2ldLCBsaXN0ZW5lciwgeyBwYXNzaXZlOiBwYXNzaXZlIHx8IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbb25PZmZdKGV2ZW50c1tpXSwgbGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWVzLCBsaXN0ZW5lciwgcGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lcywgbGlzdGVuZXIsIGZhbHNlLCBwYXNzaXZlKTtcclxuICAgICAgICAgICAgICAgICAgICBfZGVzdHJveUV2ZW50cy5wdXNoKENPTVBBVElCSUxJVFkuYmluZChzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyLCAwLCBlbGVtZW50LCBldmVudE5hbWVzLCBsaXN0ZW5lciwgdHJ1ZSwgcGFzc2l2ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBSZXNpemUgT2JzZXJ2ZXIgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIG9yIHJlbW92ZXMgYSByZXNpemUgb2JzZXJ2ZXIgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB0YXJnZXRFbGVtZW50IFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSByZXNpemUgb2JzZXJ2ZXIgc2hhbGwgYmUgYWRkZWQgb3IgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvbkVsZW1lbnRSZXNpemVkQ2FsbGJhY2sgVGhlIGNhbGxiYWNrIHdoaWNoIGlzIGZpcmVkIGV2ZXJ5IHRpbWUgdGhlIHJlc2l6ZSBvYnNlcnZlciByZWdpc3RlcnMgYSBzaXplIGNoYW5nZSBvciBmYWxzZSAvIHVuZGVmaW5lZCBpZiB0aGUgcmVzaXplT2JzZXJ2ZXIgc2hhbGwgYmUgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBSZXNpemVPYnNlcnZlcih0YXJnZXRFbGVtZW50LCBvbkVsZW1lbnRSZXNpemVkQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzaXplT2JzZXJ2ZXIgPSBDT01QQVRJQklMSVRZLnJPKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJBbmltYXRpb25TdGFydEV2ZW50ID0gJ2FuaW1hdGlvbnN0YXJ0IG1vekFuaW1hdGlvblN0YXJ0IHdlYmtpdEFuaW1hdGlvblN0YXJ0IE1TQW5pbWF0aW9uU3RhcnQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQ2hpbGROb2RlcyA9ICdjaGlsZE5vZGVzJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnN0U2Nyb2xsID0gMzMzMzMzMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudFtfc3RyU2Nyb2xsVG9wXShjb25zdFNjcm9sbClbX3N0clNjcm9sbExlZnRdKF9pc1JUTCA/IF9ydGxTY3JvbGxCZWhhdmlvci5uID8gLWNvbnN0U2Nyb2xsIDogX3J0bFNjcm9sbEJlaGF2aW9yLmkgPyAwIDogY29uc3RTY3JvbGwgOiBjb25zdFNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVsZW1lbnRSZXNpemVkQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGQgcmVzaXplIG9ic2VydmVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25FbGVtZW50UmVzaXplZENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRSZXNpemVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5hZGRDbGFzcygnb2JzZXJ2ZWQnKS5hcHBlbmQoZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCkpLmNvbnRlbnRzKClbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gZWxlbWVudFtfc3RyUmVzaXplT2JzZXJ2ZXJQcm9wZXJ0eV0gPSBuZXcgcmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX21zaWVWZXJzaW9uID4gOSB8fCAhX2F1dG9VcGRhdGVSZWNvbW1lbmRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LnByZXBlbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZURpdihfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRGl2KHsgYzogX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUVsZW1lbnQsIGRpcjogJ2x0cicgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZURpdihfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRmluYWxFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZURpdih7IGM6IF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckl0ZW1GaW5hbEVsZW1lbnQsIHN0eWxlOiAnd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJScgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlckVsZW1lbnQgPSB0YXJnZXRFbGVtZW50WzBdW3N0ckNoaWxkTm9kZXNdWzBdW3N0ckNoaWxkTm9kZXNdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hyaW5rRWxlbWVudCA9IEZSQU1FV09SSyhvYnNlcnZlckVsZW1lbnRbc3RyQ2hpbGROb2Rlc11bMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kRWxlbWVudCA9IEZSQU1FV09SSyhvYnNlcnZlckVsZW1lbnRbc3RyQ2hpbGROb2Rlc11bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kRWxlbWVudENoaWxkID0gRlJBTUVXT1JLKGV4cGFuZEVsZW1lbnRbMF1bc3RyQ2hpbGROb2Rlc11bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGhDYWNoZSA9IG9ic2VydmVyRWxlbWVudFtMRVhJQ09OLm9XXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodENhY2hlID0gb2JzZXJ2ZXJFbGVtZW50W0xFWElDT04ub0hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNEaXJ0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJBRklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVTY3JvbGxiYXJTaXplID0gZ2xvYmFscy5uYXRpdmVTY3JvbGxiYXJTaXplOyAvL2NhcmUgZG9uJ3QgbWFrZSBjaGFuZ2VzIHRvIHRoaXMgb2JqZWN0ISEhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVSZXNldFdpZHRoID0gb2JzZXJ2ZXJFbGVtZW50W0xFWElDT04ub1ddICsgbmF0aXZlU2Nyb2xsYmFyU2l6ZS54ICogZmFjdG9yICsgbmF0aXZlU2Nyb2xsYmFyU2l6ZS55ICogZmFjdG9yICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueCArIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVSZXNldEhlaWdodCA9IG9ic2VydmVyRWxlbWVudFtMRVhJQ09OLm9IXSArIG5hdGl2ZVNjcm9sbGJhclNpemUueCAqIGZhY3RvciArIG5hdGl2ZVNjcm9sbGJhclNpemUueSAqIGZhY3RvciArIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplLnggKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRDaGlsZENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkQ1NTW19zdHJXaWR0aF0gPSBzaXplUmVzZXRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRDaGlsZENTU1tfc3RySGVpZ2h0XSA9IHNpemVSZXNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRFbGVtZW50Q2hpbGQuY3NzKGV4cGFuZENoaWxkQ1NTKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKHNpemVSZXNldFdpZHRoKVtfc3RyU2Nyb2xsVG9wXShzaXplUmVzZXRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNocmlua0VsZW1lbnRbX3N0clNjcm9sbExlZnRdKHNpemVSZXNldFdpZHRoKVtfc3RyU2Nyb2xsVG9wXShzaXplUmVzZXRIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShjb25zdFNjcm9sbClbX3N0clNjcm9sbFRvcF0oY29uc3RTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rRWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oY29uc3RTY3JvbGwpW19zdHJTY3JvbGxUb3BdKGNvbnN0U2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uUmVzaXplZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJBRklkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNEaXJ0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhDYWNoZSA9IGN1cnJXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodENhY2hlID0gY3VyckhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvblNjcm9sbCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycldpZHRoID0gb2JzZXJ2ZXJFbGVtZW50W0xFWElDT04ub1ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckhlaWdodCA9IG9ic2VydmVyRWxlbWVudFtMRVhJQ09OLm9IXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGlydHkgPSBjdXJyV2lkdGggIT0gd2lkdGhDYWNoZSB8fCBjdXJySGVpZ2h0ICE9IGhlaWdodENhY2hlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudCAmJiBpc0RpcnR5ICYmICFyQUZJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuY0FGKCkockFGSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJBRklkID0gQ09NUEFUSUJJTElUWS5yQUYoKShvblJlc2l6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWV2ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVzaXplZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRDaGlsZENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZXJFbGVtZW50Q1NTID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQob2JzZXJ2ZXJFbGVtZW50Q1NTLCBfc3RyRW1wdHksIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0oKG5hdGl2ZVNjcm9sbGJhclNpemUueSArIDEpICogZmFjdG9yKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZVNjcm9sbGJhclNpemUueCAqIC1mYWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVTY3JvbGxiYXJTaXplLnkgKiAtZmFjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSgobmF0aXZlU2Nyb2xsYmFyU2l6ZS54ICsgMSkgKiBmYWN0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLKG9ic2VydmVyRWxlbWVudCkuY3NzKG9ic2VydmVyRWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZEVsZW1lbnQub24oX3N0clNjcm9sbCwgb25TY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHJpbmtFbGVtZW50Lm9uKF9zdHJTY3JvbGwsIG9uU2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5vbihzdHJBbmltYXRpb25TdGFydEV2ZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblNjcm9sbChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xldHMgYXNzdW1lIHRoYXQgdGhlIGRpdnMgd2lsbCBuZXZlciBiZSB0aGF0IGxhcmdlIGFuZCBhIGNvbnN0YW50IHZhbHVlIGlzIGVub3VnaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRDaGlsZENTU1tfc3RyV2lkdGhdID0gY29uc3RTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkQ1NTW19zdHJIZWlnaHRdID0gY29uc3RTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZEVsZW1lbnRDaGlsZC5jc3MoZXhwYW5kQ2hpbGRDU1MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2hFdmVudCA9IF9kb2N1bWVudEVsZW1lbnROYXRpdmUuYXR0YWNoRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0lFID0gX21zaWVWZXJzaW9uICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5wcmVwZW5kKGdlbmVyYXRlRGl2KF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRGaXJzdCh0YXJnZXRFbGVtZW50LCBfc3RyRG90ICsgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudClbMF0uYXR0YWNoRXZlbnQoJ29ucmVzaXplJywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IF9kb2N1bWVudEVsZW1lbnROYXRpdmUuY3JlYXRlRWxlbWVudChUWVBFUy5vKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoTEVYSUNPTi50aSwgJy0xJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouc2V0QXR0cmlidXRlKExFWElDT04uYywgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3bmQgPSB0aGlzLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bmQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHduZC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoudHlwZSA9ICd0ZXh0L2h0bWwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSUUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5wcmVwZW5kKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZGF0YSA9ICdhYm91dDpibGFuayc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSUUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5wcmVwZW5kKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Lm9uKHN0ckFuaW1hdGlvblN0YXJ0RXZlbnQsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudFswXSA9PT0gX3NpemVPYnNlcnZlckVsZW1lbnROYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpciA9IF9ob3N0RWxlbWVudC5jc3MoJ2RpcmVjdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0VmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXIgIT09IF9jc3NEaXJlY3Rpb25EZXRlY3RlZENhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyID09PSAnbHRyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyTGVmdF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyUmlnaHRdID0gX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdFZhbHVlID0gY29uc3RTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ckxlZnRdID0gX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJSaWdodF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnRWYWx1ZSA9IF9ydGxTY3JvbGxCZWhhdmlvci5uID8gLWNvbnN0U2Nyb2xsIDogX3J0bFNjcm9sbEJlaGF2aW9yLmkgPyAwIDogY29uc3RTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2V4ZWN1dGlvbiBvcmRlciBpcyBpbXBvcnRhbnQgZm9yIElFISEhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZU9ic2VydmVyRWxlbWVudC5jaGlsZHJlbigpLmVxKDApLmNzcyhjc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVPYnNlcnZlckVsZW1lbnRbX3N0clNjcm9sbExlZnRdKHNjcm9sbExlZnRWYWx1ZSlbX3N0clNjcm9sbFRvcF0oY29uc3RTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Nzc0RpcmVjdGlvbkRldGVjdGVkQ2FjaGUgPSBkaXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25DaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgX3N0clNjcm9sbCwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25DaGFuZ2VkKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5wcnZEKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHJlc2l6ZSBvYnNlcnZlcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRSZXNpemVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5jb250ZW50cygpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVPYnNlcnZlck9iaiA9IGVsZW1lbnRbX3N0clJlc2l6ZU9ic2VydmVyUHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNpemVPYnNlcnZlck9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlck9iai5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50W19zdHJSZXNpemVPYnNlcnZlclByb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUodGFyZ2V0RWxlbWVudC5jaGlsZHJlbihfc3RyRG90ICsgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCkuZXEoMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRnJlZXplcyBvciB1bmZyZWV6ZXMgdGhlIGdpdmVuIHJlc2l6ZSBvYnNlcnZlci5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB0YXJnZXRFbGVtZW50IFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSB0YXJnZXQgcmVzaXplIG9ic2VydmVyIGlzIGFwcGxpZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZnJlZXplIFRydWUgaWYgdGhlIHJlc2l6ZSBvYnNlcnZlciBzaGFsbCBiZSBmcm96ZW4sIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZyZWV6ZVJlc2l6ZU9ic2VydmVyKHRhcmdldEVsZW1lbnQsIGZyZWV6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZnJlZXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRSZXNpemVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5jb250ZW50cygpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbX3N0clJlc2l6ZU9ic2VydmVyUHJvcGVydHldLnVub2JzZXJ2ZShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50LmNoaWxkcmVuKF9zdHJEb3QgKyBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50KS5lcSgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IHRhcmdldEVsZW1lbnQuY3NzKF9zdHJXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSB0YXJnZXRFbGVtZW50LmNzcyhfc3RySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJXaWR0aF0gPSB3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RySGVpZ2h0XSA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5jc3MoY3NzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFJlc2l6ZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0YXJnZXRFbGVtZW50LmNvbnRlbnRzKClbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFtfc3RyUmVzaXplT2JzZXJ2ZXJQcm9wZXJ0eV0ub2JzZXJ2ZShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc3MgPSB7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJIZWlnaHRdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyV2lkdGhdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuY2hpbGRyZW4oX3N0ckRvdCArIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQpLmVxKDApLmNzcyhjc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IE11dGF0aW9uIE9ic2VydmVycyA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENyZWF0ZXMgTXV0YXRpb25PYnNlcnZlcnMgZm9yIHRoZSBob3N0IGFuZCBjb250ZW50IEVsZW1lbnQgaWYgdGhleSBhcmUgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVNdXRhdGlvbk9ic2VydmVycygpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRNdXRhdGlvbk9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbk9ic2VydmVyQ29udGVudExhZyA9IDExO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25PYnNlcnZlciA9IENPTVBBVElCSUxJVFkubU8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRMYXN0VXBkYXRlID0gQ09NUEFUSUJJTElUWS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uVGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25BdHRyTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uSXNDbGFzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZE11dGF0aW9uVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q2xhc3NWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob3N0Q2xhc3NOYW1lUmVnZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VGltZW91dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJIb3N0Q2FsbGJhY2sgPSBmdW5jdGlvbiAobXV0YXRpb25zKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9VcGRhdGVGb3JjZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRBdHRycyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgIV9zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2gobXV0YXRpb25zLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25UYXJnZXQgPSBtdXRhdGlvbi50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uQXR0ck5hbWUgPSBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbklzQ2xhc3MgPSBtdXRhdGlvbkF0dHJOYW1lID09PSBMRVhJQ09OLmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZE11dGF0aW9uVmFsID0gbXV0YXRpb24ub2xkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NsYXNzVmFsID0gbXV0YXRpb25UYXJnZXQuY2xhc3NOYW1lO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kb21FeGlzdHMgJiYgbXV0YXRpb25Jc0NsYXNzICYmICFkb1VwZGF0ZUZvcmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBvbGQgY2xhc3MgdmFsdWUgY29udGFpbnMgX2NsYXNzTmFtZUhvc3RFbGVtZW50Rm9yZWlnbiBhbmQgbmV3IGNsYXNzIHZhbHVlIGRvZXNuJ3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRNdXRhdGlvblZhbC5pbmRleE9mKF9jbGFzc05hbWVIb3N0RWxlbWVudEZvcmVpZ24pID4gLTEgJiYgbmV3Q2xhc3NWYWwuaW5kZXhPZihfY2xhc3NOYW1lSG9zdEVsZW1lbnRGb3JlaWduKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0Q2xhc3NOYW1lUmVnZXggPSBjcmVhdGVIb3N0Q2xhc3NOYW1lUmVnRXhwKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudE5hdGl2ZS5jbGFzc05hbWUgPSBuZXdDbGFzc1ZhbC5zcGxpdChfc3RyU3BhY2UpLmNvbmNhdChvbGRNdXRhdGlvblZhbC5zcGxpdChfc3RyU3BhY2UpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5tYXRjaChob3N0Q2xhc3NOYW1lUmVnZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5qb2luKF9zdHJTcGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9VcGRhdGUgPSBkb1VwZGF0ZUZvcmNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9VcGRhdGUgPSBtdXRhdGlvbklzQ2xhc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGhvc3RDbGFzc05hbWVzQ2hhbmdlZChvbGRNdXRhdGlvblZhbCwgbmV3Q2xhc3NWYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtdXRhdGlvbkF0dHJOYW1lID09PSBMRVhJQ09OLnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvbGRNdXRhdGlvblZhbCAhPT0gbXV0YXRpb25UYXJnZXRbTEVYSUNPTi5zXS5jc3NUZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEF0dHJzLnB1c2gobXV0YXRpb25BdHRyTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0KG11dGF0ZWRBdHRycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1VwZGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKGRvVXBkYXRlRm9yY2UgfHwgX3N0ckF1dG8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaW5pdGlhbGl6ZWQgJiYgIV9zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2gobXV0YXRpb25zLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9VcGRhdGUgPSBpc1Vua25vd25NdXRhdGlvbihtdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZG9VcGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1VwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBDT01QQVRJQklMSVRZLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQXV0byA9IChfaGVpZ2h0QXV0b0NhY2hlIHx8IF93aWR0aEF1dG9DYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRMYXN0VXBkYXRlID0gbm93O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGNvbHMsIHJvd3Mgb3Igd3JhcCBhdHRyIHdhcyBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYVVwZGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZUF1dG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKF9zdHJBdXRvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbnRlbnRUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJDb250ZW50TGFnIDw9IDAgfHwgbm93IC0gY29udGVudExhc3RVcGRhdGUgPiBtdXRhdGlvbk9ic2VydmVyQ29udGVudExhZyB8fCAhc2l6ZUF1dG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFRpbWVvdXQgPSBzZXRUaW1lb3V0KGFjdGlvbiwgbXV0YXRpb25PYnNlcnZlckNvbnRlbnRMYWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb1VwZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJIb3N0ID0gbmV3IG11dGF0aW9uT2JzZXJ2ZXIoX211dGF0aW9uT2JzZXJ2ZXJIb3N0Q2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnQgPSBuZXcgbXV0YXRpb25PYnNlcnZlcihfbXV0YXRpb25PYnNlcnZlckNvbnRlbnRDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ29ubmVjdHMgdGhlIE11dGF0aW9uT2JzZXJ2ZXJzIGlmIHRoZXkgYXJlIHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXIgJiYgIV9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckhvc3Qub2JzZXJ2ZShfaG9zdEVsZW1lbnROYXRpdmUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogX211dGF0aW9uT2JzZXJ2ZXJBdHRyc0hvc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnQub2JzZXJ2ZShfaXNUZXh0YXJlYSA/IF90YXJnZXRFbGVtZW50TmF0aXZlIDogX2NvbnRlbnRFbGVtZW50TmF0aXZlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmVlOiAhX2lzVGV4dGFyZWEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3Q6ICFfaXNUZXh0YXJlYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6ICFfaXNUZXh0YXJlYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogX2lzVGV4dGFyZWEgPyBfbXV0YXRpb25PYnNlcnZlckF0dHJzVGV4dGFyZWEgOiBfbXV0YXRpb25PYnNlcnZlckF0dHJzSG9zdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGlzY29ubmVjdHMgdGhlIE11dGF0aW9uT2JzZXJ2ZXJzIGlmIHRoZXkgYXJlIHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXIgJiYgX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVySG9zdC5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVyQ29udGVudC5kaXNjb25uZWN0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBFdmVudHMgb2YgZWxlbWVudHMgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBob3N0IGVsZW1lbnQgZ2V0cyByZXNpemVkLiBJTVBPUlRBTlQ6IFBhZGRpbmcgY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgdG9vISFcclxuICAgICAgICAgICAgICAgICAqIEl0IHJlZnJlc2hlcyB0aGUgaG9zdFJlc2l6ZWRFdmVudEFyZ3MgYW5kIHRoZSBob3N0U2l6ZVJlc2l6ZUNhY2hlLlxyXG4gICAgICAgICAgICAgICAgICogSWYgdGhlcmUgYXJlIGFueSBzaXplIGNoYW5nZXMsIHRoZSB1cGRhdGUgbWV0aG9kIGdldHMgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBob3N0T25SZXNpemVkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBfc2l6ZU9ic2VydmVyRWxlbWVudE5hdGl2ZVtMRVhJQ09OLnNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IF9zaXplT2JzZXJ2ZXJFbGVtZW50TmF0aXZlW0xFWElDT04uc0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gY2hlY2tDYWNoZShob3N0U2l6ZSwgX2hvc3RFbGVtZW50U2l6ZUNoYW5nZURldGVjdGVkQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnRTaXplQ2hhbmdlRGV0ZWN0ZWRDYWNoZSA9IGhvc3RTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSh7IF9ob3N0U2l6ZUNoYW5nZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIG1vdXNlIGVudGVyIGV2ZW50IG9mIHRoZSBob3N0IGVsZW1lbnQuIFRoaXMgZXZlbnQgaXMgb25seSBuZWVkZWQgZm9yIHRoZSBhdXRvSGlkZSBmZWF0dXJlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBob3N0T25Nb3VzZUVudGVyKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgbW91c2UgbGVhdmUgZXZlbnQgb2YgdGhlIGhvc3QgZWxlbWVudC4gVGhpcyBldmVudCBpcyBvbmx5IG5lZWRlZCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhvc3RPbk1vdXNlTGVhdmUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZSAmJiAhX2JvZHlFbGVtZW50Lmhhc0NsYXNzKF9jbGFzc05hbWVEcmFnZ2luZykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIG1vdXNlIG1vdmUgZXZlbnQgb2YgdGhlIGhvc3QgZWxlbWVudC4gVGhpcyBldmVudCBpcyBvbmx5IG5lZWRlZCBmb3IgdGhlIGF1dG9IaWRlIFwibW92ZVwiIGZlYXR1cmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhvc3RPbk1vdXNlTW92ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlVGltZW91dElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSAmJiAhX2Rlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBQcmV2ZW50cyB0ZXh0IGZyb20gZGVzZWxlY3Rpb24gaWYgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50IGVsZW1lbnQgb24gdGhlIG1vdXNlZG93biBldmVudCBvZiBhIERPTSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV2ZW50IFRoZSBzZWxlY3Qgc3RhcnQgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50T25TZWxlY3RTdGFydChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkucHJ2RChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlx0XHJcbiAgICAgICAgICAgICAgICAgKiBBIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGEgZWxlbWVudCBoYXMgbG9hZGVkLlx0XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU9uTG9hZENhbGxiYWNrKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsbSA9IEZSQU1FV09SSyhldmVudC50YXJnZXQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlYWNoVXBkYXRlT25Mb2FkKGZ1bmN0aW9uIChpLCB1cGRhdGVPbkxvYWRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxtLmlzKHVwZGF0ZU9uTG9hZFNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHsgX2NvbnRlbnRTaXplQ2hhbmdlZDogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgKiBBZGRzIG9yIHJlbW92ZXMgbW91c2UgJiB0b3VjaCBldmVudHMgb2YgdGhlIGhvc3QgZWxlbWVudC4gKGZvciBoYW5kbGluZyBhdXRvLWhpZGluZyBvZiB0aGUgc2Nyb2xsYmFycylcclxuICAgICAgICAgICAgICAgICogQHBhcmFtIGRlc3Ryb3kgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50cyBzaGFsbCBiZSBhZGRlZCBvciByZW1vdmVkLlxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwSG9zdE1vdXNlVG91Y2hFdmVudHMoZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzdHJveSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBIb3N0TW91c2VUb3VjaEV2ZW50cyh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfaG9zdEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNb3VzZVRvdWNoTW92ZUV2ZW50LnNwbGl0KF9zdHJTcGFjZSlbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RPbk1vdXNlTW92ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSB8fCBkZXN0cm95KSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfaG9zdEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyTW91c2VFbnRlciwgX3N0ck1vdXNlTGVhdmVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbaG9zdE9uTW91c2VFbnRlciwgaG9zdE9uTW91c2VMZWF2ZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlIHx8IGRlc3Ryb3kpLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgcGx1Z2luIGlzIGluaXRpYWxpemVkIGFuZCB0aGUgbW91c2UgaXMgb3ZlciB0aGUgaG9zdCBlbGVtZW50LCBtYWtlIHRoZSBzY3JvbGxiYXJzIHZpc2libGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pbml0aWFsaXplZCAmJiAhZGVzdHJveSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50Lm9uZSgnbW91c2VvdmVyJywgaG9zdE9uTW91c2VFbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBVcGRhdGUgRGV0ZWN0aW9uID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogTWVhc3VyZXMgdGhlIG1pbiB3aWR0aCBhbmQgbWluIGhlaWdodCBvZiB0aGUgYm9keSBlbGVtZW50IGFuZCByZWZyZXNoZXMgdGhlIHJlbGF0ZWQgY2FjaGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWluIHdpZHRoIG9yIG1pbiBoZWlnaHQgaGFzIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYm9keU1pblNpemVDaGFuZ2VkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5TWluU2l6ZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNCb2R5ICYmIF9jb250ZW50QXJyYW5nZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keU1pblNpemUudyA9IHBhcnNlVG9aZXJvT3JOdW1iZXIoX2NvbnRlbnRBcnJhbmdlRWxlbWVudC5jc3MoX3N0ck1pbk1pbnVzICsgX3N0cldpZHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlNaW5TaXplLmggPSBwYXJzZVRvWmVyb09yTnVtYmVyKF9jb250ZW50QXJyYW5nZUVsZW1lbnQuY3NzKF9zdHJNaW5NaW51cyArIF9zdHJIZWlnaHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keU1pblNpemUuYyA9IGNoZWNrQ2FjaGUoYm9keU1pblNpemUsIF9ib2R5TWluU2l6ZUNhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keU1pblNpemUuZiA9IHRydWU7IC8vZmxhZyBmb3IgXCJtZWFzdXJlZCBhdCBsZWFzdCBvbmNlXCJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2JvZHlNaW5TaXplQ2FjaGUgPSBib2R5TWluU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFib2R5TWluU2l6ZS5jO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjbGFzcyBuYW1lcyByZWFsbHkgY2hhbmdlZCAobmV3IGNsYXNzIHdpdGhvdXQgcGx1Z2luIGhvc3QgcHJlZml4KVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9sZENsYXNzTmFtZXMgVGhlIG9sZCBDbGFzc05hbWUgc3RyaW5nIG9yIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG5ld0NsYXNzTmFtZXMgVGhlIG5ldyBDbGFzc05hbWUgc3RyaW5nIG9yIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNsYXNzIG5hbWVzIGhhcyByZWFsbHkgY2hhbmdlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBob3N0Q2xhc3NOYW1lc0NoYW5nZWQob2xkQ2xhc3NOYW1lcywgbmV3Q2xhc3NOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyQ2xhc3NlcyA9IHR5cGVvZiBuZXdDbGFzc05hbWVzID09IFRZUEVTLnMgPyBuZXdDbGFzc05hbWVzLnNwbGl0KF9zdHJTcGFjZSkgOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ2xhc3NlcyA9IHR5cGVvZiBvbGRDbGFzc05hbWVzID09IFRZUEVTLnMgPyBvbGRDbGFzc05hbWVzLnNwbGl0KF9zdHJTcGFjZSkgOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGdldEFycmF5RGlmZmVyZW5jZXMob2xkQ2xhc3NlcywgY3VyckNsYXNzZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgbm9uZSB0aGVtZSBmcm9tIGRpZmYgbGlzdCB0byBwcmV2ZW50IHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBpbkFycmF5KF9jbGFzc05hbWVUaGVtZU5vbmUsIGRpZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdleDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmLnNwbGljZShpZHgsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZltMRVhJQ09OLmxdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleCA9IGNyZWF0ZUhvc3RDbGFzc05hbWVSZWdFeHAodHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpZmZbaV0ubWF0Y2gocmVnZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtdXRhdGlvbiBpcyBub3QgZnJvbSBhIGZyb20gdGhlIHBsdWdpbiBnZW5lcmF0ZWQgZWxlbWVudC4gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgdGV4dGFyZWEgdGhlIG11dGF0aW9uIGlzIGFsd2F5cyB1bmtub3duLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG11dGF0aW9uIFRoZSBtdXRhdGlvbiB3aGljaCBzaGFsbCBiZSBjaGVja2VkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIG11dGF0aW9uIGlzIGZyb20gYSB1bmtub3duIGVsZW1lbnQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNVbmtub3duTXV0YXRpb24obXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IG11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uVGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvblR5cGUgPSBtdXRhdGlvbi50eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJDbG9zZXN0ID0gJ2Nsb3Nlc3QnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25UYXJnZXQgPT09IF9jb250ZW50RWxlbWVudE5hdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgPT09IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uVHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIChhdHRyaWJ1dGVOYW1lID09PSBMRVhJQ09OLmMgfHwgYXR0cmlidXRlTmFtZSA9PT0gTEVYSUNPTi5zKSAmJiAhX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZ25vcmUgY2xhc3NOYW1lIGNoYW5nZXMgYnkgdGhlIHBsdWdpblx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBMRVhJQ09OLmMgJiYgRlJBTUVXT1JLKG11dGF0aW9uVGFyZ2V0KS5oYXNDbGFzcyhfY2xhc3NOYW1lSG9zdEVsZW1lbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvc3RDbGFzc05hbWVzQ2hhbmdlZChtdXRhdGlvbi5vbGRWYWx1ZSwgbXV0YXRpb25UYXJnZXQuY2xhc3NOYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb25seSBkbyBpdCBvZiBicm93c2VyIHN1cHBvcnQgaXQgbmF0aXZlbHlcdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG11dGF0aW9uVGFyZ2V0W3N0ckNsb3Nlc3RdICE9IFRZUEVTLmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uVGFyZ2V0W3N0ckNsb3Nlc3RdKF9zdHJEb3QgKyBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50KSAhPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25UYXJnZXRbc3RyQ2xvc2VzdF0oX3N0ckRvdCArIF9jbGFzc05hbWVTY3JvbGxiYXIpICE9PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblRhcmdldFtzdHJDbG9zZXN0XShfc3RyRG90ICsgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lcikgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250ZW50IHNpemUgd2FzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbnRlbnQgc2l6ZSB3YXMgY2hhbmdlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVBdXRvQ29udGVudFNpemVDaGFuZ2VkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc2xlZXBpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRNZWFzdXJlRWxlbWVudCA9IGdldENvbnRlbnRNZWFzdXJlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVZhbHVlTGVuZ3RoID0gX2lzVGV4dGFyZWEgJiYgX3dpZHRoQXV0b0NhY2hlICYmICFfdGV4dGFyZWFBdXRvV3JhcHBpbmdDYWNoZSA/IF90YXJnZXRFbGVtZW50LnZhbCgpLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldENTUyA9ICFfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQgJiYgX3dpZHRoQXV0b0NhY2hlICYmICFfaXNUZXh0YXJlYTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5TWluU2l6ZUM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldENTUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCA9IF9jb250ZW50RWxlbWVudC5jc3MoX3N0ckZsb2F0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJGbG9hdF0gPSBfaXNSVEwgPyBfc3RyUmlnaHQgOiBfc3RyTGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJXaWR0aF0gPSBfc3RyQXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhjc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudFNjcm9sbFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHc6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNXXSArIHRleHRhcmVhVmFsdWVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGg6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNIXSArIHRleHRhcmVhVmFsdWVMZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXRDU1MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJGbG9hdF0gPSBmbG9hdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJXaWR0aF0gPSBfc3RySHVuZHJlZFBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoY3NzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlNaW5TaXplQyA9IGJvZHlNaW5TaXplQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSBjaGVja0NhY2hlKGNvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZSwgX2NvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZUNoYW5nZURldGVjdGVkQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnRTY3JvbGxTaXplQ2hhbmdlRGV0ZWN0ZWRDYWNoZSA9IGNvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWQgfHwgYm9keU1pblNpemVDO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0cnVlIHdoZW4gYSBhdHRyaWJ1dGUgd2hpY2ggdGhlIE11dGF0aW9uT2JzZXJ2ZXIgd291bGQgb2JzZXJ2ZSBoYXMgY2hhbmdlZC4gIFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb25lIG9mIHRoZSBhdHRyaWJ1dGVzIHdoaWNoIGEgTXV0YXRpb25PYnNlcnZlciB3b3VsZCBvYnNlcnZlIGhhcyBjaGFuZ2VkLCBmYWxzZSBvciB1bmRlZmluZWQgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBtZWFuaW5nZnVsQXR0cnNDaGFuZ2VkKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc2xlZXBpbmcgfHwgX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZEF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2VsZW06IF9ob3N0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hdHRyczogX211dGF0aW9uT2JzZXJ2ZXJBdHRyc0hvc3QuY29uY2F0KCc6dmlzaWJsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lbGVtOiBfaXNUZXh0YXJlYSA/IF90YXJnZXRFbGVtZW50IDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2F0dHJzOiBfbXV0YXRpb25PYnNlcnZlckF0dHJzVGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVhY2goY2hlY2tzLCBmdW5jdGlvbiAoaW5kZXgsIGNoZWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBjaGVjay5fZWxlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goY2hlY2suX2F0dHJzLCBmdW5jdGlvbiAoaW5kZXgsIGF0dHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gYXR0ci5jaGFyQXQoMCkgPT09ICc6JyA/IGVsZW0uaXMoYXR0cikgOiBlbGVtLmF0dHIoYXR0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSBfdXBkYXRlQXV0b0NhY2hlW2F0dHJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tDYWNoZShjdXJyLCBjYWNoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEF0dHJzLnB1c2goYXR0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlQXV0b0NhY2hlW2F0dHJdID0gY3VycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0KGNoYW5nZWRBdHRycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkQXR0cnNbTEVYSUNPTi5sXSA+IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDaGVja3MgaXMgYSBDU1MgUHJvcGVydHkgb2YgYSBjaGlsZCBlbGVtZW50IGlzIGFmZmVjdGluZyB0aGUgc2Nyb2xsIHNpemUgb2YgdGhlIGNvbnRlbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIFRoZSBDU1MgcHJvcGVydHkgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm9wZXJ0eSBpcyBhZmZlY3RpbmcgdGhlIGNvbnRlbnQgc2Nyb2xsIHNpemUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNTaXplQWZmZWN0aW5nQ1NTUHJvcGVydHkocHJvcGVydHlOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaW5pdGlhbGl6ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbGV4R3JvdyA9ICdmbGV4LWdyb3cnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbGV4U2hyaW5rID0gJ2ZsZXgtc2hyaW5rJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxleEJhc2lzID0gJ2ZsZXgtYmFzaXMnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RpbmdQcm9wc1ggPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1pbk1pbnVzICsgX3N0cldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWF4TWludXMgKyBfc3RyV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNYXJnaW5NaW51cyArIF9zdHJMZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWFyZ2luTWludXMgKyBfc3RyUmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJMZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyUmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb250LXdlaWdodCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd3b3JkLXNwYWNpbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4R3JvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleFNocmluayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleEJhc2lzXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0aW5nUHJvcHNYQ29udGVudEJveCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0clBhZGRpbmdNaW51cyArIF9zdHJMZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyUGFkZGluZ01pbnVzICsgX3N0clJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyQm9yZGVyTWludXMgKyBfc3RyTGVmdCArIF9zdHJXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ckJvcmRlck1pbnVzICsgX3N0clJpZ2h0ICsgX3N0cldpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0aW5nUHJvcHNZID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWluTWludXMgKyBfc3RySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWF4TWludXMgKyBfc3RySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWFyZ2luTWludXMgKyBfc3RyVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWFyZ2luTWludXMgKyBfc3RyQm90dG9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyQm90dG9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGluZS1oZWlnaHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4R3JvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleFNocmluayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleEJhc2lzXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0aW5nUHJvcHNZQ29udGVudEJveCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0clBhZGRpbmdNaW51cyArIF9zdHJUb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJQYWRkaW5nTWludXMgKyBfc3RyQm90dG9tLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyQm9yZGVyTWludXMgKyBfc3RyVG9wICsgX3N0cldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyQm9yZGVyTWludXMgKyBfc3RyQm90dG9tICsgX3N0cldpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0clMgPSAncyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdHJWUyA9ICd2LXMnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGVja1ggPSBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlLnggPT09IF9zdHJTIHx8IF9vdmVyZmxvd0JlaGF2aW9yQ2FjaGUueCA9PT0gX3N0clZTO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGVja1kgPSBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlLnkgPT09IF9zdHJTIHx8IF9vdmVyZmxvd0JlaGF2aW9yQ2FjaGUueSA9PT0gX3N0clZTO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplSXNBZmZlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGVja1Byb3BlcnR5TmFtZSA9IGZ1bmN0aW9uIChhcnIsIG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldID09PSBuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVJc0FmZmVjdGVkID0gY2hlY2tQcm9wZXJ0eU5hbWUoYWZmZWN0aW5nUHJvcHNZLCBwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpemVJc0FmZmVjdGVkICYmICFfaXNCb3JkZXJCb3gpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplSXNBZmZlY3RlZCA9IGNoZWNrUHJvcGVydHlOYW1lKGFmZmVjdGluZ1Byb3BzWUNvbnRlbnRCb3gsIHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja1ggJiYgIXNpemVJc0FmZmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVJc0FmZmVjdGVkID0gY2hlY2tQcm9wZXJ0eU5hbWUoYWZmZWN0aW5nUHJvcHNYLCBwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpemVJc0FmZmVjdGVkICYmICFfaXNCb3JkZXJCb3gpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplSXNBZmZlY3RlZCA9IGNoZWNrUHJvcGVydHlOYW1lKGFmZmVjdGluZ1Byb3BzWENvbnRlbnRCb3gsIHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplSXNBZmZlY3RlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFVwZGF0ZSA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMgb2YgdGhlIHZpZXdwb3J0IGVsZW1lbnQgdG8gdGhlIHZhbHVlcyBmcm9tIHRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIFRoZSB2YWx1ZSBvZiBhIGF0dHJpYnV0ZSBpcyBvbmx5IHNldCBpZiB0aGUgYXR0cmlidXRlIGlzIHdoaXRlbGlzdGVkLlxyXG4gICAgICAgICAgICAgICAgICogQGF0dHJzIGF0dHJzIFRoZSBhcnJheSBvZiBhdHRyaWJ1dGVzIHdoaWNoIHNoYWxsIGJlIHNldCBvciB1bmRlZmluZWQgaWYgYWxsIHdoaXRlbGlzdGVkIHNoYWxsIGJlIHNldC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmlld3BvcnRBdHRyc0Zyb21UYXJnZXQoYXR0cnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRycyA9IGF0dHJzIHx8IF92aWV3cG9ydEF0dHJzRnJvbVRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBlYWNoKGF0dHJzLCBmdW5jdGlvbiAoaW5kZXgsIGF0dHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaW5BKGF0dHIsIF92aWV3cG9ydEF0dHJzRnJvbVRhcmdldCkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldEF0dHIgPSBfdGFyZ2V0RWxlbWVudC5hdHRyKGF0dHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUodGFyZ2V0QXR0cikgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuYXR0cihhdHRyLCB0YXJnZXRBdHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQucmVtb3ZlQXR0cihhdHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVXBkYXRlcyB0aGUgdmFyaWFibGVzIGFuZCBzaXplIG9mIHRoZSB0ZXh0YXJlYSBlbGVtZW50LCBhbmQgbWFuYWdlcyB0aGUgc2Nyb2xsIG9uIG5ldyBsaW5lIG9yIG5ldyBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhVXBkYXRlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cmFwQXR0ck9mZiA9ICFfdGV4dGFyZWFBdXRvV3JhcHBpbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbldpZHRoID0gX3ZpZXdwb3J0U2l6ZS53O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluSGVpZ2h0ID0gX3ZpZXdwb3J0U2l6ZS5oO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb01lYXN1cmUgPSBfd2lkdGhBdXRvQ2FjaGUgfHwgd3JhcEF0dHJPZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc2V0IG1pbiBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyTWluTWludXMgKyBfc3RyV2lkdGhdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ck1pbk1pbnVzICsgX3N0ckhlaWdodF0gPSBfc3RyRW1wdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NldCB3aWR0aCBhdXRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyV2lkdGhdID0gX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LmNzcyhjc3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tZWFzdXJlIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdXaWR0aCA9IF90YXJnZXRFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGRvTWVhc3VyZSA/IE1BVEgubWF4KG9yaWdXaWR0aCwgX3RhcmdldEVsZW1lbnROYXRpdmVbTEVYSUNPTi5zV10gLSAxKSA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qd2lkdGggKz0gKF93aWR0aEF1dG9DYWNoZSA/IF9tYXJnaW5YICsgKCFfaXNCb3JkZXJCb3ggPyB3cmFwQXR0ck9mZiA/IDAgOiBfcGFkZGluZ1ggKyBfYm9yZGVyWCA6IDApIDogMCk7Ki9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IG1lYXN1cmVkIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyV2lkdGhdID0gX3dpZHRoQXV0b0NhY2hlID8gX3N0ckF1dG8gLyp3aWR0aCovIDogX3N0ckh1bmRyZWRQZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ck1pbk1pbnVzICsgX3N0cldpZHRoXSA9IF9zdHJIdW5kcmVkUGVyY2VudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IGhlaWdodCBhdXRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RySGVpZ2h0XSA9IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudC5jc3MoY3NzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyZSBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ0hlaWdodCA9IF90YXJnZXRFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBNQVRILm1heChvcmlnSGVpZ2h0LCBfdGFyZ2V0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLnNIXSAtIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBlbmQgY29ycmVjdCBzaXplIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0cldpZHRoXSA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ckhlaWdodF0gPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUNvdmVyRWxlbWVudC5jc3MoY3NzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgbWluIHdpZHRoIC8gbWluIGhlaWdodCB0byBwcmV2ZW50IHRleHRhcmVhIGNvbGxhcHNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJNaW5NaW51cyArIF9zdHJXaWR0aF0gPSBtaW5XaWR0aCAvKisgKCFfaXNCb3JkZXJCb3ggJiYgX3dpZHRoQXV0b0NhY2hlID8gX3BhZGRpbmdYICsgX2JvcmRlclggOiAwKSovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ck1pbk1pbnVzICsgX3N0ckhlaWdodF0gPSBtaW5IZWlnaHQgLyorICghX2lzQm9yZGVyQm94ICYmIF9oZWlnaHRBdXRvQ2FjaGUgPyBfcGFkZGluZ1kgKyBfYm9yZGVyWSA6IDApKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LmNzcyhjc3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vcmlnaW5hbFdpZHRoOiBvcmlnV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3JpZ2luYWxIZWlnaHQ6IG9yaWdIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZHluYW1pY1dpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9keW5hbWljSGVpZ2h0OiBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVcGRhdGVzIHRoZSBwbHVnaW4gYW5kIERPTSB0byB0aGUgY3VycmVudCBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIGEgdXBkYXRlIGlzIDEwMCUgcmVxdWlyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdXBkYXRlSGludHMgQSBvYmplY3RzIHdoaWNoIGNvbnRhaW5zIGhpbnRzIGZvciB0aGlzIHVwZGF0ZTpcclxuICAgICAgICAgICAgICAgICAqIHtcclxuICAgICAgICAgICAgICAgICAqICAgX2hvc3RTaXplQ2hhbmdlZCA6IGJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICAgKiAgIF9jb250ZW50U2l6ZUNoYW5nZWQgOiBib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgICogICBfZm9yY2UgOiBib29sZWFuLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPT0gcHJldmVudFN3YWxsb3dpbmdcclxuICAgICAgICAgICAgICAgICAqICAgX2NoYW5nZWRPcHRpb25zIDogeyB9LCAgICAgICAgICAgICAgICAgICAgICAgID09IHByZXZlbnRTd2FsbG93aW5nICYmIHByZXZlbnRTbGVlcFxyXG4gICAgICAgICAgICAgICAgKiAgfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGUodXBkYXRlSGludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3N3YWxsb3dlZFVwZGF0ZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUhpbnRzID0gdXBkYXRlSGludHMgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgX3N3YWxsb3dlZFVwZGF0ZUhpbnRzLl9ob3N0U2l6ZUNoYW5nZWQgfD0gdXBkYXRlSGludHMuX2hvc3RTaXplQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICBfc3dhbGxvd2VkVXBkYXRlSGludHMuX2NvbnRlbnRTaXplQ2hhbmdlZCB8PSB1cGRhdGVIaW50cy5fY29udGVudFNpemVDaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zd2FsbG93ZWRVcGRhdGVIaW50cy5fZm9yY2UgfD0gdXBkYXRlSGludHMuX2ZvcmNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gQ09NUEFUSUJJTElUWS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdFNpemVDaGFuZ2VkID0gISFfc3dhbGxvd2VkVXBkYXRlSGludHMuX2hvc3RTaXplQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFNpemVDaGFuZ2VkID0gISFfc3dhbGxvd2VkVXBkYXRlSGludHMuX2NvbnRlbnRTaXplQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yY2UgPSAhIV9zd2FsbG93ZWRVcGRhdGVIaW50cy5fZm9yY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRPcHRpb25zID0gdXBkYXRlSGludHMuX2NoYW5nZWRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzd2FsbG93ID0gX3N3YWxsb3dVcGRhdGVMYWcgPiAwICYmIF9pbml0aWFsaXplZCAmJiAhX2Rlc3Ryb3llZCAmJiAhZm9yY2UgJiYgIWNoYW5nZWRPcHRpb25zICYmIChub3cgLSBfbGFzdFVwZGF0ZVRpbWUpIDwgX3N3YWxsb3dVcGRhdGVMYWcgJiYgKCFfaGVpZ2h0QXV0b0NhY2hlICYmICFfd2lkdGhBdXRvQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5SXNIaWRkZW47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzd2FsbG93KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3dhbGxvd2VkVXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQodXBkYXRlLCBfc3dhbGxvd1VwZGF0ZUxhZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYWJvcnQgdXBkYXRlIGR1ZSB0bzpcclxuICAgICAgICAgICAgICAgICAgICAvL2Rlc3Ryb3llZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vc3dhbGxvd2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc2xlZXBpbmdcclxuICAgICAgICAgICAgICAgICAgICAvL2hvc3QgaXMgaGlkZGVuIG9yIGhhcyBmYWxzZSBkaXNwbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kZXN0cm95ZWQgfHwgc3dhbGxvdyB8fCAoX3NsZWVwaW5nICYmICFjaGFuZ2VkT3B0aW9ucykgfHwgKF9pbml0aWFsaXplZCAmJiAhZm9yY2UgJiYgKGRpc3BsYXlJc0hpZGRlbiA9IF9ob3N0RWxlbWVudC5pcygnOmhpZGRlbicpKSkgfHwgX2hvc3RFbGVtZW50LmNzcygnZGlzcGxheScpID09PSAnaW5saW5lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfbGFzdFVwZGF0ZVRpbWUgPSBub3c7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N3YWxsb3dlZFVwZGF0ZUhpbnRzID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgc2Nyb2xsYmFyIHN0eWxpbmcgaXMgcG9zc2libGUgYW5kIG5hdGl2ZSBzY3JvbGxiYXJzIGFyZW4ndCBvdmVybGFpZCB0aGUgc2Nyb2xsYmFyIHN0eWxpbmcgd2lsbCBiZSBhcHBsaWVkIHdoaWNoIGhpZGVzIHRoZSBuYXRpdmUgc2Nyb2xsYmFycyBjb21wbGV0ZWx5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZyAmJiAhKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uYXRpdmUgc2Nyb2xsYmFycyBhcmUgaGlkZGVuLCBzbyBjaGFuZ2UgdGhlIHZhbHVlcyB0byB6ZXJvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJTaXplLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbmF0aXZlU2Nyb2xsYmFyU2l6ZS55ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVmcmVzaCBuYXRpdmUgc2Nyb2xsYmFyIHNpemUgKGluIGNhc2Ugb2Ygem9vbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhclNpemUgPSBleHRlbmREZWVwKHt9LCBnbG9iYWxzLm5hdGl2ZVNjcm9sbGJhclNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2Nyb2xsYmFyIHBhZGRpbmcgaXMgbmVlZGVkIGZvciBmaXJlZm94LCBiZWNhdXNlIGZpcmVmb3ggaGlkZXMgc2Nyb2xsYmFyIGF1dG9tYXRpY2FsbHkgaWYgdGhlIHNpemUgb2YgdGhlIGRpdiBpcyB0b28gc21hbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNhbGN1bGF0aW9uOiBbc2Nyb2xsYmFyIHNpemUgKzMgKjNdXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKCszIGJlY2F1c2Ugb2YgcG9zc2libGUgZGVjb3JhdGlvbiBlLmcuIGJvcmRlcnMsIG1hcmdpbnMgZXRjLiwgYnV0IG9ubHkgaWYgbmF0aXZlIHNjcm9sbGJhciBpcyBOT1QgYSBvdmVybGFpZCBzY3JvbGxiYXIpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKCozIGJlY2F1c2UgKDEpaW5jcmVhc2UgLyAoMilkZWNyZWFzZSAtYnV0dG9uIGFuZCAoMylyZXNpemUgaGFuZGxlKVxyXG4gICAgICAgICAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJNaW5TaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAoX25hdGl2ZVNjcm9sbGJhclNpemUueCArIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ID8gMCA6IDMpKSAqIDMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IChfbmF0aXZlU2Nyb2xsYmFyU2l6ZS55ICsgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkgPyAwIDogMykpICogM1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRPcHRpb25zID0gY2hhbmdlZE9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mcmVlemVSZXNpemVPYnNlcnZlcihfc2l6ZU9ic2VydmVyRWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mcmVlemVSZXNpemVPYnNlcnZlcihfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tDYWNoZUF1dG9Gb3JjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrQ2FjaGUuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmNvbmNhdChbZm9yY2VdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zYXZlIGN1cnJlbnQgc2Nyb2xsIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyU2Nyb2xsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxUb3BdKClcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFByZXBhcmVkT3B0aW9uc1Njcm9sbGJhcnMgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5zY3JvbGxiYXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UHJlcGFyZWRPcHRpb25zVGV4dGFyZWEgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy50ZXh0YXJlYTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzIHZpc2liaWxpdHk6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNWaXNpYmlsaXR5ID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1Njcm9sbGJhcnMudmlzaWJpbGl0eTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc1Zpc2liaWxpdHlDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShzY3JvbGxiYXJzVmlzaWJpbGl0eSwgX3Njcm9sbGJhcnNWaXNpYmlsaXR5Q2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnMgYXV0b0hpZGU6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNBdXRvSGlkZSA9IGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNTY3JvbGxiYXJzLmF1dG9IaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzQXV0b0hpZGVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShzY3JvbGxiYXJzQXV0b0hpZGUsIF9zY3JvbGxiYXJzQXV0b0hpZGVDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsYmFycyBjbGljayBzY3JvbGxpbmdcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1Njcm9sbGJhcnMuY2xpY2tTY3JvbGxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZywgX3Njcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzIGRyYWcgc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNEcmFnU2Nyb2xsaW5nID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1Njcm9sbGJhcnMuZHJhZ1Njcm9sbGluZztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmdDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZywgX3Njcm9sbGJhcnNEcmFnU2Nyb2xsaW5nQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NsYXNzTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5jbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGNsYXNzTmFtZSwgX2NsYXNzTmFtZUNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXNpemVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzaXplID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMucmVzaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShyZXNpemUsIF9yZXNpemVDYWNoZSkgJiYgIV9pc0JvZHk7IC8vYm9keSBjYW4ndCBiZSByZXNpemVkIHNpbmNlIHRoZSB3aW5kb3cgaXRzZWxmIGFjdHMgYXMgcmVzaXplIHBvc3NpYmlsaXR5LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3BhZGRpbmdBYnNvbHV0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nQWJzb2x1dGUgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5wYWRkaW5nQWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHBhZGRpbmdBYnNvbHV0ZSwgX3BhZGRpbmdBYnNvbHV0ZUNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jbGlwQWx3YXlzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBBbHdheXMgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5jbGlwQWx3YXlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGlwQWx3YXlzQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoY2xpcEFsd2F5cywgX2NsaXBBbHdheXNDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2l6ZUF1dG9DYXBhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVBdXRvQ2FwYWJsZSA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLnNpemVBdXRvQ2FwYWJsZSAmJiAhX2lzQm9keTsgLy9ib2R5IGNhbiBuZXZlciBiZSBzaXplIGF1dG8sIGJlY2F1c2UgaXQgc2hhbGwgYmUgYWx3YXlzIGFzIGJpZyBhcyB0aGUgdmlld3BvcnQuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVBdXRvQ2FwYWJsZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHNpemVBdXRvQ2FwYWJsZSwgX3NpemVBdXRvQ2FwYWJsZUNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zaG93TmF0aXZlU2Nyb2xsYmFyc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMubmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkLnNob3dOYXRpdmVTY3JvbGxiYXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZywgX2lnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYXV0b1VwZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdXRvVXBkYXRlID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuYXV0b1VwZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXV0b1VwZGF0ZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGF1dG9VcGRhdGUsIF9hdXRvVXBkYXRlQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL292ZXJmbG93QmVoYXZpb3JcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3dCZWhhdmlvciA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLm92ZXJmbG93QmVoYXZpb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93QmVoYXZpb3JDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShvdmVyZmxvd0JlaGF2aW9yLCBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlLCBmb3JjZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZHluV2lkdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhRHluV2lkdGggPSBjdXJyZW50UHJlcGFyZWRPcHRpb25zVGV4dGFyZWEuZHluV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhRHluV2lkdGhDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShfdGV4dGFyZWFEeW5XaWR0aENhY2hlLCB0ZXh0YXJlYUR5bldpZHRoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9keW5IZWlnaHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhRHluSGVpZ2h0ID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1RleHRhcmVhLmR5bkhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFEeW5IZWlnaHRDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShfdGV4dGFyZWFEeW5IZWlnaHRDYWNoZSwgdGV4dGFyZWFEeW5IZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnMgdmlzaWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVOZXZlciA9IHNjcm9sbGJhcnNBdXRvSGlkZSA9PT0gJ24nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgPSBzY3JvbGxiYXJzQXV0b0hpZGUgPT09ICdzJztcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSA9IHNjcm9sbGJhcnNBdXRvSGlkZSA9PT0gJ20nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZSA9IHNjcm9sbGJhcnNBdXRvSGlkZSA9PT0gJ2wnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnMgYXV0b0hpZGVEZWxheVxyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVEZWxheSA9IGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNTY3JvbGxiYXJzLmF1dG9IaWRlRGVsYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vb2xkIGNsYXNzTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIF9vbGRDbGFzc05hbWUgPSBfY2xhc3NOYW1lQ2FjaGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc2l6ZU5vbmUgPSByZXNpemUgPT09ICduJztcclxuICAgICAgICAgICAgICAgICAgICBfcmVzaXplQm90aCA9IHJlc2l6ZSA9PT0gJ2InO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZXNpemVIb3Jpem9udGFsID0gcmVzaXplID09PSAnaCc7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc2l6ZVZlcnRpY2FsID0gcmVzaXplID09PSAndic7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vbm9ybWFsaXplUlRMXHJcbiAgICAgICAgICAgICAgICAgICAgX25vcm1hbGl6ZVJUTENhY2hlID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMubm9ybWFsaXplUlRMO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lnbm9yZSBvdmVybGF5IHNjcm9sbGJhciBoaWRpbmdcclxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nID0gaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZyAmJiAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCAmJiBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZWZyZXNoIG9wdGlvbnMgY2FjaGVcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc1Zpc2liaWxpdHlDYWNoZSA9IHNjcm9sbGJhcnNWaXNpYmlsaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVDYWNoZSA9IHNjcm9sbGJhcnNBdXRvSGlkZTtcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nQ2FjaGUgPSBzY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNEcmFnU2Nyb2xsaW5nQ2FjaGUgPSBzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZztcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lQ2FjaGUgPSBjbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc2l6ZUNhY2hlID0gcmVzaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nQWJzb2x1dGVDYWNoZSA9IHBhZGRpbmdBYnNvbHV0ZTtcclxuICAgICAgICAgICAgICAgICAgICBfY2xpcEFsd2F5c0NhY2hlID0gY2xpcEFsd2F5cztcclxuICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9DYXBhYmxlQ2FjaGUgPSBzaXplQXV0b0NhcGFibGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX2lnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDYWNoZSA9IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2F1dG9VcGRhdGVDYWNoZSA9IGF1dG9VcGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX292ZXJmbG93QmVoYXZpb3JDYWNoZSA9IGV4dGVuZERlZXAoe30sIG92ZXJmbG93QmVoYXZpb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUR5bldpZHRoQ2FjaGUgPSB0ZXh0YXJlYUR5bldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUR5bkhlaWdodENhY2hlID0gdGV4dGFyZWFEeW5IZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX2hhc092ZXJmbG93Q2FjaGUgPSBfaGFzT3ZlcmZsb3dDYWNoZSB8fCB7IHg6IGZhbHNlLCB5OiBmYWxzZSB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NldCBjb3JyZWN0IGNsYXNzIG5hbWUgdG8gdGhlIGhvc3QgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgX29sZENsYXNzTmFtZSArIF9zdHJTcGFjZSArIF9jbGFzc05hbWVUaGVtZU5vbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaG9zdEVsZW1lbnQsIGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkICYmIGNsYXNzTmFtZSAhPT0gbnVsbCAmJiBjbGFzc05hbWUubGVuZ3RoID4gMCA/IGNsYXNzTmFtZSA6IF9jbGFzc05hbWVUaGVtZU5vbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgY29ycmVjdCBhdXRvIFVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdXRvVXBkYXRlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV0b1VwZGF0ZSA9PT0gdHJ1ZSB8fCAoYXV0b1VwZGF0ZSA9PT0gbnVsbCAmJiBfYXV0b1VwZGF0ZVJlY29tbWVuZGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlTG9vcC5hZGQoX2Jhc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1VwZGF0ZUxvb3AucmVtb3ZlKF9iYXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RNdXRhdGlvbk9ic2VydmVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2FjdGl2YXRlIG9yIGRlYWN0aXZhdGUgc2l6ZSBhdXRvIGNhcGFiaWxpdHlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZUF1dG9DYXBhYmxlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZUF1dG9DYXBhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbnRlbnRHbHVlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudCA9IEZSQU1FV09SSyhnZW5lcmF0ZURpdihfY2xhc3NOYW1lQ29udGVudEdsdWVFbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50LmJlZm9yZShfY29udGVudEdsdWVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2l6ZUF1dG9PYnNlcnZlckFkZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b09ic2VydmVyRWxlbWVudCA9IEZSQU1FV09SSyhnZW5lcmF0ZURpdihfY2xhc3NOYW1lU2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnROYXRpdmUgPSBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnRbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuYmVmb3JlKF9zaXplQXV0b09ic2VydmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFNpemUgPSB7IHc6IC0xLCBoOiAtMSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzaXplT2JzZXJ2ZXIoX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0NhY2hlKG5ld1NpemUsIG9sZFNpemUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2luaXRpYWxpemVkICYmIChfaGVpZ2h0QXV0b0NhY2hlICYmIG5ld1NpemUuaCA+IDApIHx8IChfd2lkdGhBdXRvQ2FjaGUgJiYgbmV3U2l6ZS53ID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pbml0aWFsaXplZCAmJiAoIV9oZWlnaHRBdXRvQ2FjaGUgJiYgbmV3U2l6ZS5oID09PSAwKSB8fCAoIV93aWR0aEF1dG9DYWNoZSAmJiBuZXdTaXplLncgPT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkU2l6ZSA9IG5ld1NpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9maXggaGVpZ2h0QXV0byBkZXRlY3RvciBidWcgaWYgaGVpZ2h0IGlzIGZpeGVkIGJ1dCBjb250ZW50SGVpZ2h0IGlzIDAuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgcHJvYmFiaWxpdHkgdGhpcyBidWcgd2lsbCBldmVyIGhhcHBlbiBpcyB2ZXJ5IHZlcnkgbG93LCB0aGF0cyB3aHkgaXRzIG9rIGlmIHdlIHVzZSBjYWxjIHdoaWNoIGlzbid0IHN1cHBvcnRlZCBpbiBJRTguXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jc3NDYWxjICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQuY3NzKF9zdHJIZWlnaHQsIF9jc3NDYWxjICsgJygxMDAlICsgMXB4KScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zaXplQXV0b09ic2VydmVyQWRkZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY29udGVudEdsdWVFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIGZvcmNlLCB1cGRhdGUgYWxsIHJlc2l6ZU9ic2VydmVycyB0b29cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVPYnNlcnZlckVsZW1lbnQuZmluZCgnKicpLnRyaWdnZXIoX3N0clNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2l6ZUF1dG9PYnNlcnZlckFkZGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LmZpbmQoJyonKS50cmlnZ2VyKF9zdHJTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kaXNwbGF5IGhpZGRlbjpcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5SXNIaWRkZW4gPSBkaXNwbGF5SXNIaWRkZW4gPT09IHVuZGVmaW5lZCA/IF9ob3N0RWxlbWVudC5pcygnOmhpZGRlbicpIDogZGlzcGxheUlzSGlkZGVuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3RleHRhcmVhIEF1dG9XcmFwcGluZzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFBdXRvV3JhcHBpbmcgPSBfaXNUZXh0YXJlYSA/IF90YXJnZXRFbGVtZW50LmF0dHIoJ3dyYXAnKSAhPT0gJ29mZicgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFBdXRvV3JhcHBpbmdDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZSh0ZXh0YXJlYUF1dG9XcmFwcGluZywgX3RleHRhcmVhQXV0b1dyYXBwaW5nQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2RldGVjdCBkaXJlY3Rpb246XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzc0RpcmVjdGlvbiA9IF9ob3N0RWxlbWVudC5jc3MoJ2RpcmVjdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjc3NEaXJlY3Rpb25DaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShjc3NEaXJlY3Rpb24sIF9jc3NEaXJlY3Rpb25DYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGJveC1zaXppbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJveFNpemluZyA9IF9ob3N0RWxlbWVudC5jc3MoJ2JveC1zaXppbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm94U2l6aW5nQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoYm94U2l6aW5nLCBfY3NzQm94U2l6aW5nQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2RldGVjdCBwYWRkaW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nID0gZ2V0VG9wUmlnaHRCb3R0b21MZWZ0SG9zdChfc3RyUGFkZGluZ01pbnVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy93aWR0aCArIGhlaWdodCBhdXRvIGRldGVjdGluZyB2YXI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50QkNSZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZXhjZXB0aW9uIG9jY3VycyBpbiBJRTggc29tZXRpbWVzICh1bmtub3duIGV4Y2VwdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplQXV0b09ic2VydmVyRWxlbWVudEJDUmVjdCA9IF9zaXplQXV0b09ic2VydmVyQWRkZWQgPyBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnROYXRpdmVbTEVYSUNPTi5iQ1JdKCkgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9pc1JUTCA9IGNzc0RpcmVjdGlvbiA9PT0gJ3J0bCc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2lzQm9yZGVyQm94ID0gKGJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSVExMZWZ0ID0gX2lzUlRMID8gX3N0ckxlZnQgOiBfc3RyUmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUlRMUmlnaHQgPSBfaXNSVEwgPyBfc3RyUmlnaHQgOiBfc3RyTGVmdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kZXRlY3Qgd2lkdGggYXV0bzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGhBdXRvUmVzaXplRGV0ZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoQXV0b09ic2VydmVyRGV0ZWN0aW9uID0gKF9zaXplQXV0b09ic2VydmVyQWRkZWQgJiYgKF9ob3N0RWxlbWVudC5jc3MoX3N0ckZsb2F0KSAhPT0gJ25vbmUnIC8qfHwgX2lzVGV4dGFyZWEgKi8pKSA/IChNQVRILnJvdW5kKHNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50QkNSZWN0LnJpZ2h0IC0gc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnRCQ1JlY3QubGVmdCkgPT09IDApICYmICghcGFkZGluZ0Fic29sdXRlID8gKF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLmNXXSAtIF9wYWRkaW5nWCkgPiAwIDogdHJ1ZSkgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZUF1dG9DYXBhYmxlICYmICF3aWR0aEF1dG9PYnNlcnZlckRldGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wQ3Vyckhvc3RXaWR0aCA9IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9XXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcEN1cnJDb250ZW50R2x1ZVdpZHRoID0gX2NvbnRlbnRHbHVlRWxlbWVudC5jc3MoX3N0cldpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5jc3MoX3N0cldpZHRoLCBfc3RyQXV0byk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wTmV3SG9zdFdpZHRoID0gX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LmNzcyhfc3RyV2lkdGgsIHRtcEN1cnJDb250ZW50R2x1ZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhBdXRvUmVzaXplRGV0ZWN0aW9uID0gdG1wQ3Vyckhvc3RXaWR0aCAhPT0gdG1wTmV3SG9zdFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdpZHRoQXV0b1Jlc2l6ZURldGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5jc3MoX3N0cldpZHRoLCB0bXBDdXJySG9zdFdpZHRoICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBOZXdIb3N0V2lkdGggPSBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5vV107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LmNzcyhfc3RyV2lkdGgsIHRtcEN1cnJDb250ZW50R2x1ZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoQXV0b1Jlc2l6ZURldGVjdGlvbiA9IHRtcEN1cnJIb3N0V2lkdGggIT09IHRtcE5ld0hvc3RXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGhBdXRvID0gKHdpZHRoQXV0b09ic2VydmVyRGV0ZWN0aW9uIHx8IHdpZHRoQXV0b1Jlc2l6ZURldGVjdGlvbikgJiYgc2l6ZUF1dG9DYXBhYmxlICYmICFkaXNwbGF5SXNIaWRkZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoQXV0b0NoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKHdpZHRoQXV0bywgX3dpZHRoQXV0b0NhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2FzV2lkdGhBdXRvID0gIXdpZHRoQXV0byAmJiBfd2lkdGhBdXRvQ2FjaGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGhlaWdodCBhdXRvOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHRBdXRvID0gX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZCAmJiBzaXplQXV0b0NhcGFibGUgJiYgIWRpc3BsYXlJc0hpZGRlbiA/IChNQVRILnJvdW5kKHNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50QkNSZWN0LmJvdHRvbSAtIHNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50QkNSZWN0LnRvcCkgPT09IDApIC8qICYmICghcGFkZGluZ0Fic29sdXRlICYmIChfbXNpZVZlcnNpb24gPiA5IHx8ICFfbXNpZVZlcnNpb24pID8gdHJ1ZSA6IHRydWUpICovIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodEF1dG9DaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShoZWlnaHRBdXRvLCBfaGVpZ2h0QXV0b0NhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2FzSGVpZ2h0QXV0byA9ICFoZWlnaHRBdXRvICYmIF9oZWlnaHRBdXRvQ2FjaGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGJvcmRlcjpcclxuICAgICAgICAgICAgICAgICAgICAvL3dlIG5lZWQgdGhlIGJvcmRlciBvbmx5IGlmIGJvcmRlciBib3ggYW5kIGF1dG8gc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVCb3JkZXJYID0gKHdpZHRoQXV0byAmJiBfaXNCb3JkZXJCb3gpIHx8ICFfaXNCb3JkZXJCb3g7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUJvcmRlclkgPSAoaGVpZ2h0QXV0byAmJiBfaXNCb3JkZXJCb3gpIHx8ICFfaXNCb3JkZXJCb3g7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlciA9IGdldFRvcFJpZ2h0Qm90dG9tTGVmdEhvc3QoX3N0ckJvcmRlck1pbnVzLCAnLScgKyBfc3RyV2lkdGgsICF1cGRhdGVCb3JkZXJYLCAhdXBkYXRlQm9yZGVyWSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kZXRlY3QgbWFyZ2luOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXJnaW4gPSBnZXRUb3BSaWdodEJvdHRvbUxlZnRIb3N0KF9zdHJNYXJnaW5NaW51cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdmFycyB0byBhcHBseSBjb3JyZWN0IGNzc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50RWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50R2x1ZUVsZW1lbnRDU1MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9mdW5jc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRIb3N0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9oYXMgdG8gYmUgY2xpZW50U2l6ZSBiZWNhdXNlIG9mZnNldFNpemUgcmVzcGVjdCBib3JkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRWaWV3cG9ydFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmlld3BvcnQgc2l6ZSBpcyBwYWRkaW5nIGNvbnRhaW5lciBiZWNhdXNlIGl0IG5ldmVyIGhhcyBwYWRkaW5nLCBtYXJnaW4gYW5kIGEgYm9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZGV0ZXJtaW5lIHpvb20gcm91bmRpbmcgZXJyb3IgLT4gc29tZXRpbWVzIHNjcm9sbFdpZHRoL0hlaWdodCBpcyBzbWFsbGVyIHRoYW4gY2xpZW50V2lkdGgvSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBoYXBwZW5zIGFkZCB0aGUgZGlmZmVyZW5jZSB0byB0aGUgdmlld3BvcnRTaXplIHRvIGNvbXBlbnNhdGUgdGhlIHJvdW5kaW5nIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBfcGFkZGluZ0VsZW1lbnROYXRpdmVbTEVYSUNPTi5vV10gKyBNQVRILm1heCgwLCBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jV10gLSBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5zV10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogX3BhZGRpbmdFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdICsgTUFUSC5tYXgoMCwgX2NvbnRlbnRFbGVtZW50TmF0aXZlW0xFWElDT04uY0hdIC0gX2NvbnRlbnRFbGVtZW50TmF0aXZlW0xFWElDT04uc0hdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IGluZm8gZm9yIHBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0Fic29sdXRlWCA9IF9wYWRkaW5nWCA9IHBhZGRpbmcubCArIHBhZGRpbmcucjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0Fic29sdXRlWSA9IF9wYWRkaW5nWSA9IHBhZGRpbmcudCArIHBhZGRpbmcuYjtcclxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQWJzb2x1dGVYICo9IHBhZGRpbmdBYnNvbHV0ZSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdBYnNvbHV0ZVkgKj0gcGFkZGluZ0Fic29sdXRlID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZy5jID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShwYWRkaW5nLCBfY3NzUGFkZGluZ0NhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgaW5mbyBmb3IgYm9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgX2JvcmRlclggPSBib3JkZXIubCArIGJvcmRlci5yO1xyXG4gICAgICAgICAgICAgICAgICAgIF9ib3JkZXJZID0gYm9yZGVyLnQgKyBib3JkZXIuYjtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXIuYyA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoYm9yZGVyLCBfY3NzQm9yZGVyQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NldCBpbmZvIGZvciBtYXJnaW5cclxuICAgICAgICAgICAgICAgICAgICBfbWFyZ2luWCA9IG1hcmdpbi5sICsgbWFyZ2luLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgX21hcmdpblkgPSBtYXJnaW4udCArIG1hcmdpbi5iO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi5jID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShtYXJnaW4sIF9jc3NNYXJnaW5DYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVmcmVzaCBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUF1dG9XcmFwcGluZ0NhY2hlID0gdGV4dGFyZWFBdXRvV3JhcHBpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2Nzc0RpcmVjdGlvbkNhY2hlID0gY3NzRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jc3NCb3hTaXppbmdDYWNoZSA9IGJveFNpemluZztcclxuICAgICAgICAgICAgICAgICAgICBfd2lkdGhBdXRvQ2FjaGUgPSB3aWR0aEF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgX2hlaWdodEF1dG9DYWNoZSA9IGhlaWdodEF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgX2Nzc1BhZGRpbmdDYWNoZSA9IHBhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2Nzc0JvcmRlckNhY2hlID0gYm9yZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jc3NNYXJnaW5DYWNoZSA9IG1hcmdpbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9JRUZpeCBkaXJlY3Rpb24gY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3NEaXJlY3Rpb25DaGFuZ2VkICYmIF9zaXplQXV0b09ic2VydmVyQWRkZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b09ic2VydmVyRWxlbWVudC5jc3MoX3N0ckZsb2F0LCBpc1JUTFJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hcHBseSBwYWRkaW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nLmMgfHwgY3NzRGlyZWN0aW9uQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkIHx8IHdpZHRoQXV0b0NoYW5nZWQgfHwgaGVpZ2h0QXV0b0NoYW5nZWQgfHwgYm94U2l6aW5nQ2hhbmdlZCB8fCBzaXplQXV0b0NhcGFibGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nRWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdWYWx1ZXMgPSBbcGFkZGluZy50LCBwYWRkaW5nLnIsIHBhZGRpbmcuYiwgcGFkZGluZy5sXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRvcFJpZ2h0Qm90dG9tTGVmdChjb250ZW50R2x1ZUVsZW1lbnRDU1MsIF9zdHJNYXJnaW5NaW51cywgWy1wYWRkaW5nLnQsIC1wYWRkaW5nLnIsIC1wYWRkaW5nLmIsIC1wYWRkaW5nLmxdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdBYnNvbHV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VG9wUmlnaHRCb3R0b21MZWZ0KHBhZGRpbmdFbGVtZW50Q1NTLCBfc3RyRW1wdHksIHBhZGRpbmdWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VG9wUmlnaHRCb3R0b21MZWZ0KF9pc1RleHRhcmVhID8gdGV4dGFyZWFDU1MgOiBjb250ZW50RWxlbWVudENTUywgX3N0clBhZGRpbmdNaW51cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQocGFkZGluZ0VsZW1lbnRDU1MsIF9zdHJFbXB0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQoX2lzVGV4dGFyZWEgPyB0ZXh0YXJlYUNTUyA6IGNvbnRlbnRFbGVtZW50Q1NTLCBfc3RyUGFkZGluZ01pbnVzLCBwYWRkaW5nVmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50LmNzcyhwYWRkaW5nRWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LmNzcyh0ZXh0YXJlYUNTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3ZpZXdwb3J0IHNpemUgaXMgcGFkZGluZyBjb250YWluZXIgYmVjYXVzZSBpdCBuZXZlciBoYXMgcGFkZGluZywgbWFyZ2luIGFuZCBhIGJvcmRlci5cclxuICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRTaXplID0gZ2V0Vmlld3BvcnRTaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIFRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhU2l6ZSA9IF9pc1RleHRhcmVhID8gdGV4dGFyZWFVcGRhdGUoKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVNpemVDaGFuZ2VkID0gX2lzVGV4dGFyZWEgJiYgY2hlY2tDYWNoZUF1dG9Gb3JjZSh0ZXh0YXJlYVNpemUsIF90ZXh0YXJlYVNpemVDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhRHluT3JpZ1NpemUgPSBfaXNUZXh0YXJlYSAmJiB0ZXh0YXJlYVNpemUgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHc6IHRleHRhcmVhRHluV2lkdGggPyB0ZXh0YXJlYVNpemUuX2R5bmFtaWNXaWR0aCA6IHRleHRhcmVhU2l6ZS5fb3JpZ2luYWxXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaDogdGV4dGFyZWFEeW5IZWlnaHQgPyB0ZXh0YXJlYVNpemUuX2R5bmFtaWNIZWlnaHQgOiB0ZXh0YXJlYVNpemUuX29yaWdpbmFsSGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgfSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYVNpemVDYWNoZSA9IHRleHRhcmVhU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9maXggaGVpZ2h0IGF1dG8gLyB3aWR0aCBhdXRvIGluIGNvb3BlcmF0aW9uIHdpdGggY3VycmVudCBwYWRkaW5nICYgYm94U2l6aW5nIGJlaGF2aW9yOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWlnaHRBdXRvICYmIChoZWlnaHRBdXRvQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgcGFkZGluZy5jIHx8IGJvcmRlci5jKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RySGVpZ2h0XSA9IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoZWlnaHRBdXRvQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gX3N0ckh1bmRyZWRQZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhBdXRvICYmICh3aWR0aEF1dG9DaGFuZ2VkIHx8IHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWQgfHwgYm94U2l6aW5nQ2hhbmdlZCB8fCBwYWRkaW5nLmMgfHwgYm9yZGVyLmMgfHwgY3NzRGlyZWN0aW9uQ2hhbmdlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1NbX3N0ck1heE1pbnVzICsgX3N0cldpZHRoXSA9IF9zdHJIdW5kcmVkUGVyY2VudDsgLy9JRSBGaXhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod2lkdGhBdXRvQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBfc3RySHVuZHJlZFBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJGbG9hdF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RyTWF4TWludXMgKyBfc3RyV2lkdGhdID0gX3N0ckVtcHR5OyAvL0lFIEZpeFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGV4dGFyZWFEeW5PcmlnU2l6ZS53IHx8IF9zdHJBdXRvIDo6IGRvZXNudCB3b3JrcyBiZWNhdXNlIGFwcGxpZWQgbWFyZ2luIHdpbGwgc2hpZnQgd2lkdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBfc3RyQXV0bztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBWRU5ET1JTLl9jc3NQcm9wZXJ0eVZhbHVlKF9zdHJXaWR0aCwgJ21heC1jb250ZW50IGludHJpbnNpYycpIHx8IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyRmxvYXRdID0gaXNSVExSaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RyV2lkdGhdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0QXV0bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RleHRhcmVhRHluT3JpZ1NpemUuaCB8fCBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jSF0gOjogdXNlIGZvciBhbnRpIHNjcm9sbCBqdW1waW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RySGVpZ2h0XSA9IHRleHRhcmVhRHluT3JpZ1NpemUuaCB8fCBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jSF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1NbX3N0ckhlaWdodF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaXplQXV0b0NhcGFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuY3NzKGNvbnRlbnRHbHVlRWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhjb250ZW50RWxlbWVudENTUyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vQ0hFQ0tQT0lOVCBIRVJFIH5cclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTUyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIFtjb250ZW50KGhvc3QpIGNsaWVudCAvIHNjcm9sbCBzaXplLCBvciB0YXJnZXQgZWxlbWVudCBkaXJlY3Rpb24sIG9yIGNvbnRlbnQoaG9zdCkgbWF4LXNpemVzXSBjaGFuZ2VkLCBvciBmb3JjZSBpcyB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RTaXplQ2hhbmdlZCB8fCBjb250ZW50U2l6ZUNoYW5nZWQgfHwgdGV4dGFyZWFTaXplQ2hhbmdlZCB8fCBjc3NEaXJlY3Rpb25DaGFuZ2VkIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgcGFkZGluZ0Fic29sdXRlQ2hhbmdlZCB8fCB3aWR0aEF1dG9DaGFuZ2VkIHx8IHdpZHRoQXV0byB8fCBoZWlnaHRBdXRvQ2hhbmdlZCB8fCBoZWlnaHRBdXRvIHx8IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkIHx8IG92ZXJmbG93QmVoYXZpb3JDaGFuZ2VkIHx8IGNsaXBBbHdheXNDaGFuZ2VkIHx8IHJlc2l6ZUNoYW5nZWQgfHwgc2Nyb2xsYmFyc1Zpc2liaWxpdHlDaGFuZ2VkIHx8IHNjcm9sbGJhcnNBdXRvSGlkZUNoYW5nZWQgfHwgc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmdDaGFuZ2VkIHx8IHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NoYW5nZWQgfHwgdGV4dGFyZWFEeW5XaWR0aENoYW5nZWQgfHwgdGV4dGFyZWFEeW5IZWlnaHRDaGFuZ2VkIHx8IHRleHRhcmVhQXV0b1dyYXBwaW5nQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyT3ZlcmZsb3cgPSAnb3ZlcmZsb3cnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyT3ZlcmZsb3dYID0gc3RyT3ZlcmZsb3cgKyAnLXgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyT3ZlcmZsb3dZID0gc3RyT3ZlcmZsb3cgKyAnLXknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RySGlkZGVuID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJWaXNpYmxlID0gJ3Zpc2libGUnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9SZXNldCB0aGUgdmlld3BvcnQgKHZlcnkgaW1wb3J0YW50IGZvciBuYXRpdmVseSBvdmVybGFpZCBzY3JvbGxiYXJzIGFuZCB6b29tIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Rvbid0IGNoYW5nZSB0aGUgb3ZlcmZsb3cgcHJvcCBhcyBpdCBpcyB2ZXJ5IGV4cGVuc2l2ZSBhbmQgYWZmZWN0cyBwZXJmb3JtYW5jZSAhQSBMT1QhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydEVsZW1lbnRSZXNldENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2V0WFRtcCA9IF9oYXNPdmVyZmxvd0NhY2hlLnkgJiYgX2hpZGVPdmVyZmxvd0NhY2hlLnlzICYmICFpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nID8gKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkgPyBfdmlld3BvcnRFbGVtZW50LmNzcyhpc1JUTExlZnQpIDogLV9uYXRpdmVTY3JvbGxiYXJTaXplLnkpIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNldEJvdHRvbVRtcCA9IF9oYXNPdmVyZmxvd0NhY2hlLnggJiYgX2hpZGVPdmVyZmxvd0NhY2hlLnhzICYmICFpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nID8gKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggPyBfdmlld3BvcnRFbGVtZW50LmNzcyhfc3RyQm90dG9tKSA6IC1fbmF0aXZlU2Nyb2xsYmFyU2l6ZS54KSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQodmlld3BvcnRFbGVtZW50UmVzZXRDU1MsIF9zdHJFbXB0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LmNzcyh2aWV3cG9ydEVsZW1lbnRSZXNldENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyZSBzZXZlcmFsIHNpemVzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudE1lYXN1cmVFbGVtZW50ID0gZ2V0Q29udGVudE1lYXN1cmVFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaW4gRmlyZWZveCBjb250ZW50IGVsZW1lbnQgaGFzIHRvIGhhdmUgb3ZlcmZsb3cgaGlkZGVuLCBlbHNlIGVsZW1lbnQgbWFyZ2lucyBhcmVuJ3QgY2FsY3VsYXRlZCBwcm9wZXJseSwgdGhpcyBlbGVtZW50IHByZXZlbnRzIHRoaXMgYnVnLCBidXQgb25seSBpZiBzY3JvbGxiYXJzIGFyZW4ndCBvdmVybGFpZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VzZSBjbGllbnRTaXplIGJlY2F1c2UgbmF0aXZlbHkgb3ZlcmxhaWRTY3JvbGxiYXJzIGFkZCBib3JkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiB0ZXh0YXJlYUR5bk9yaWdTaXplLncgfHwgY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uY1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogdGV4dGFyZWFEeW5PcmlnU2l6ZS5oIHx8IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLmNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsU2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBseSB0aGUgY29ycmVjdCB2aWV3cG9ydCBzdHlsZSBhbmQgbWVhc3VyZSB2aWV3cG9ydCBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFJlc2V0Q1NTW19zdHJCb3R0b21dID0gd2FzSGVpZ2h0QXV0byA/IF9zdHJFbXB0eSA6IHJlc2V0Qm90dG9tVG1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50UmVzZXRDU1NbaXNSVExMZWZ0XSA9IHdhc1dpZHRoQXV0byA/IF9zdHJFbXB0eSA6IHJlc2V0WFRtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuY3NzKHZpZXdwb3J0RWxlbWVudFJlc2V0Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRTaXplID0gZ2V0Vmlld3BvcnRTaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmUgYW5kIGNvcnJlY3Qgc2V2ZXJhbCBzaXplc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdFNpemUgPSBnZXRIb3N0U2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEFic29sdXRlUmVjdFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBob3N0U2l6ZS53IC0gX21hcmdpblggLSBfYm9yZGVyWCAtIChfaXNCb3JkZXJCb3ggPyAwIDogX3BhZGRpbmdYKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IGhvc3RTaXplLmggLSBfbWFyZ2luWSAtIF9ib3JkZXJZIC0gKF9pc0JvcmRlckJveCA/IDAgOiBfcGFkZGluZ1kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50R2x1ZVNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NsaWVudC9zY3JvbGxTaXplICsgQWJzb2x1dGVQYWRkaW5nIC0+IGJlY2F1c2UgcGFkZGluZyBpcyBvbmx5IGFwcGxpZWQgdG8gdGhlIHBhZGRpbmdFbGVtZW50IGlmIGl0cyBhYnNvbHV0ZSwgc28geW91IGhhdmUgdG8gYWRkIGl0IG1hbnVhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2hvc3RTaXplIGlzIGNsaWVudFNpemUgLT4gc28gcGFkZGluZyBzaG91bGQgYmUgYWRkZWQgbWFudWFsbHksIHJpZ2h0PyBGQUxTRSEgQmVjYXVzZSBjb250ZW50IGdsdWUgaXMgaW5zaWRlIGhvc3RFbGVtZW50LCBzbyB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IHBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IE1BVEgubWF4KCh3aWR0aEF1dG8gPyBjb250ZW50U2l6ZS53IDogc2Nyb2xsU2l6ZS53KSArIHBhZGRpbmdBYnNvbHV0ZVgsIGhvc3RBYnNvbHV0ZVJlY3RTaXplLncpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogTUFUSC5tYXgoKGhlaWdodEF1dG8gPyBjb250ZW50U2l6ZS5oIDogc2Nyb2xsU2l6ZS5oKSArIHBhZGRpbmdBYnNvbHV0ZVksIGhvc3RBYnNvbHV0ZVJlY3RTaXplLmgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlU2l6ZS5jID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShjb250ZW50R2x1ZVNpemUsIF9jb250ZW50R2x1ZVNpemVDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZVNpemVDYWNoZSA9IGNvbnRlbnRHbHVlU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgY29ycmVjdCBjb250ZW50R2x1ZSBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplQXV0b0NhcGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2l6ZSBjb250ZW50R2x1ZSBjb3JyZWN0bHkgdG8gbWFrZSBzdXJlIHRoZSBlbGVtZW50IGhhcyBjb3JyZWN0IHNpemUgaWYgdGhlIHNpemluZyBzd2l0Y2hlcyB0byBhdXRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudEdsdWVTaXplLmMgfHwgKGhlaWdodEF1dG8gfHwgd2lkdGhBdXRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RyV2lkdGhdID0gY29udGVudEdsdWVTaXplLnc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gY29udGVudEdsdWVTaXplLmg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGV4dGFyZWEtc2l6ZXMgYXJlIGFscmVhZHkgY2FsY3VsYXRlZCBjb3JyZWN0bHkgYXQgdGhpcyBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VzZSBjbGllbnRTaXplIGJlY2F1c2UgbmF0aXZlbHkgb3ZlcmxhaWRTY3JvbGxiYXJzIGFkZCBib3JkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5jV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5jSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFDb3ZlckNTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldENvbnRlbnRHbHVlRWxlbWVudENTU2Z1bmN0aW9uID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdoID0gc2Nyb2xsYmFyVmFycy5fd19oO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJXSCA9IHNjcm9sbGJhclZhcnMuX3dpZHRoX2hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXV0b1NpemUgPSBob3Jpem9udGFsID8gd2lkdGhBdXRvIDogaGVpZ2h0QXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyU2l6ZSA9IGhvcml6b250YWwgPyBfYm9yZGVyWCA6IF9ib3JkZXJZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nU2l6ZSA9IGhvcml6b250YWwgPyBfcGFkZGluZ1ggOiBfcGFkZGluZ1k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpblNpemUgPSBob3Jpem9udGFsID8gX21hcmdpblggOiBfbWFyZ2luWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRTaXplID0gX3ZpZXdwb3J0U2l6ZVt3aF0gLSBib3JkZXJTaXplIC0gbWFyZ2luU2l6ZSAtIChfaXNCb3JkZXJCb3ggPyAwIDogcGFkZGluZ1NpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21ha2UgY29udGVudEdsdWUgc2l6ZSAtMSBpZiBlbGVtZW50IGlzIG5vdCBhdXRvIHNpemVkLCB0byBtYWtlIHN1cmUgdGhhdCBhIHJlc2l6ZSBldmVudCBoYXBwZW5zIHdoZW4gdGhlIGVsZW1lbnQgc2hyaW5rc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXV0b1NpemUgfHwgKCFhdXRvU2l6ZSAmJiBib3JkZXIuYykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tzdHJXSF0gPSBob3N0QWJzb2x1dGVSZWN0U2l6ZVt3aF0gLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHNpemUgaXMgYXV0byBhbmQgaG9zdCBpcyBzbWFsbGVyIHRoYW4gc2l6ZSBhcyBtaW4gc2l6ZSwgbWFrZSBjb250ZW50IGdsdWUgc2l6ZSAtMSB0byBtYWtlIHN1cmUgc2l6ZSBjaGFuZ2VzIHdpbGwgYmUgZGV0ZWN0ZWQgKHRoaXMgaXMgb25seSBuZWVkZWQgaWYgcGFkZGluZyBpcyAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRvU2l6ZSAmJiAoY29udGVudFNpemVbd2hdIDwgdmlld3BvcnRTaXplKSAmJiAoaG9yaXpvbnRhbCAmJiBfaXNUZXh0YXJlYSA/ICF0ZXh0YXJlYUF1dG9XcmFwcGluZyA6IHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhQ292ZXJDU1Nbc3RyV0hdID0gcGFyc2VUb1plcm9Pck51bWJlcihfdGV4dGFyZWFDb3ZlckVsZW1lbnQuY3NzKHN0cldIKSkgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1Nbc3RyV0hdIC09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSBjb250ZW50IGdsdWUgc2l6ZSBpcyBhdCBsZWFzdCAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRTaXplW3doXSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tzdHJXSF0gPSBNQVRILm1heCgxLCBjb250ZW50R2x1ZUVsZW1lbnRDU1Nbc3RyV0hdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50R2x1ZUVsZW1lbnRDU1NmdW5jdGlvbih0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRHbHVlRWxlbWVudENTU2Z1bmN0aW9uKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhQ292ZXJFbGVtZW50LmNzcyh0ZXh0YXJlYUNvdmVyQ1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuY3NzKGNvbnRlbnRHbHVlRWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoQXV0bylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBfc3RySHVuZHJlZFBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aEF1dG8gJiYgIV9pc0JvcmRlckJveCAmJiAhX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckZsb2F0XSA9ICdub25lJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgYW5kIHJlc2V0IGNvbnRlbnQgc3R5bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhjb250ZW50RWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmUgYWdhaW4sIGJ1dCB0aGlzIHRpbWUgYWxsIGNvcnJlY3Qgc2l6ZXM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50U2Nyb2xsU2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLnNIXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFNjcm9sbFNpemUuYyA9IGNvbnRlbnRTaXplQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoY29udGVudFNjcm9sbFNpemUsIF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGUgPSBjb250ZW50U2Nyb2xsU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVmcmVzaCB2aWV3cG9ydCBzaXplIGFmdGVyIGNvcnJlY3QgbWVhc3VyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydFNpemUgPSBnZXRWaWV3cG9ydFNpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RTaXplID0gZ2V0SG9zdFNpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFNpemVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShob3N0U2l6ZSwgX2hvc3RTaXplQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaG9zdFNpemVDYWNoZSA9IGhvc3RTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhpZGVPdmVyZmxvd0ZvcmNlVGV4dGFyZWEgPSBfaXNUZXh0YXJlYSAmJiAoX3ZpZXdwb3J0U2l6ZS53ID09PSAwIHx8IF92aWV3cG9ydFNpemUuaCA9PT0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c092ZXJmbG93QW1vdW50ID0gX292ZXJmbG93QW1vdW50Q2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvd0JlaGF2aW9ySXNWUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3dCZWhhdmlvcklzVkggPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93QmVoYXZpb3JJc1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93QW1vdW50ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNPdmVyZmxvdyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGlkZU92ZXJmbG93ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5TY3JvbGwgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0UmVjdCA9IF9wYWRkaW5nRWxlbWVudE5hdGl2ZVtMRVhJQ09OLmJDUl0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldE92ZXJmbG93VmFyaWFibGVzID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQgPSBnZXRTY3JvbGxiYXJWYXJzKCFob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4eUkgPSBzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQuX3hfeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4eSA9IHNjcm9sbGJhclZhcnMuX3hfeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aCA9IHNjcm9sbGJhclZhcnMuX3dfaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aEhlaWdodCA9IHNjcm9sbGJhclZhcnMuX3dpZHRoX2hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxNYXggPSBfc3RyU2Nyb2xsICsgc2Nyb2xsYmFyVmFycy5fTGVmdF9Ub3AgKyAnTWF4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFjdGlvbmFsT3ZlcmZsb3dBbW91bnQgPSB2aWV3cG9ydFJlY3Rbd2lkdGhIZWlnaHRdID8gTUFUSC5hYnModmlld3BvcnRSZWN0W3dpZHRoSGVpZ2h0XSAtIF92aWV3cG9ydFNpemVbd2hdKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tGcmFjdGlvbmFsT3ZlcmZsb3dBbW91bnQgPSBwcmV2aW91c092ZXJmbG93QW1vdW50ICYmIHByZXZpb3VzT3ZlcmZsb3dBbW91bnRbeHldID4gMCAmJiBfdmlld3BvcnRFbGVtZW50TmF0aXZlW3Njcm9sbE1heF0gPT09IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0JlaGF2aW9ySXNWU1t4eV0gPSBvdmVyZmxvd0JlaGF2aW9yW3h5XSA9PT0gJ3Ytcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0JlaGF2aW9ySXNWSFt4eV0gPSBvdmVyZmxvd0JlaGF2aW9yW3h5XSA9PT0gJ3YtaCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0JlaGF2aW9ySXNTW3h5XSA9IG92ZXJmbG93QmVoYXZpb3JbeHldID09PSAncyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0Ftb3VudFt4eV0gPSBNQVRILm1heCgwLCBNQVRILnJvdW5kKChjb250ZW50U2Nyb2xsU2l6ZVt3aF0gLSBfdmlld3BvcnRTaXplW3doXSkgKiAxMDApIC8gMTAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93QW1vdW50W3h5XSAqPSAoaGlkZU92ZXJmbG93Rm9yY2VUZXh0YXJlYSB8fCAoY2hlY2tGcmFjdGlvbmFsT3ZlcmZsb3dBbW91bnQgJiYgZnJhY3Rpb25hbE92ZXJmbG93QW1vdW50ID4gMCAmJiBmcmFjdGlvbmFsT3ZlcmZsb3dBbW91bnQgPCAxKSkgPyAwIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc092ZXJmbG93W3h5XSA9IG92ZXJmbG93QW1vdW50W3h5XSA+IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9oaWRlT3ZlcmZsb3c6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ggfHwgeSA6IHRydWUgPT09IG92ZXJmbG93IGlzIGhpZGRlbiBieSBcIm92ZXJmbG93OiBzY3JvbGxcIiBPUiBcIm92ZXJmbG93OiBoaWRkZW5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy94cyB8fCB5cyA6IHRydWUgPT09IG92ZXJmbG93IGlzIGhpZGRlbiBieSBcIm92ZXJmbG93OiBzY3JvbGxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZU92ZXJmbG93W3h5XSA9IG92ZXJmbG93QmVoYXZpb3JJc1ZTW3h5XSB8fCBvdmVyZmxvd0JlaGF2aW9ySXNWSFt4eV0gPyAoaGFzT3ZlcmZsb3dbeHlJXSAmJiAhb3ZlcmZsb3dCZWhhdmlvcklzVlNbeHlJXSAmJiAhb3ZlcmZsb3dCZWhhdmlvcklzVkhbeHlJXSkgOiBoYXNPdmVyZmxvd1t4eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlT3ZlcmZsb3dbeHkgKyAncyddID0gaGlkZU92ZXJmbG93W3h5XSA/IChvdmVyZmxvd0JlaGF2aW9ySXNTW3h5XSB8fCBvdmVyZmxvd0JlaGF2aW9ySXNWU1t4eV0pIDogZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuU2Nyb2xsW3h5XSA9IGhhc092ZXJmbG93W3h5XSAmJiBoaWRlT3ZlcmZsb3dbeHkgKyAncyddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPdmVyZmxvd1ZhcmlhYmxlcyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3ZlcmZsb3dWYXJpYWJsZXMoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dBbW91bnQuYyA9IGNoZWNrQ2FjaGVBdXRvRm9yY2Uob3ZlcmZsb3dBbW91bnQsIF9vdmVyZmxvd0Ftb3VudENhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX292ZXJmbG93QW1vdW50Q2FjaGUgPSBvdmVyZmxvd0Ftb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3ZlcmZsb3cuYyA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoaGFzT3ZlcmZsb3csIF9oYXNPdmVyZmxvd0NhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hhc092ZXJmbG93Q2FjaGUgPSBoYXNPdmVyZmxvdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZU92ZXJmbG93LmMgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGhpZGVPdmVyZmxvdywgX2hpZGVPdmVyZmxvd0NhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hpZGVPdmVyZmxvd0NhY2hlID0gaGlkZU92ZXJmbG93O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBuYXRpdmUgc2Nyb2xsYmFyIGlzIG92ZXJsYXkgYXQgeCBPUiB5IGF4aXMsIHByZXBhcmUgRE9NXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54IHx8IF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3JkZXJEZXNpZ24gPSAncHggc29saWQgdHJhbnNwYXJlbnQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRBcnJhbmdlRWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmFuZ2VDb250ZW50ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYW5nZUNoYW5nZWQgPSBmb3JjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXRDb250ZW50RWxlbWVudENTUztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcmZsb3cueCB8fCBoYXNPdmVyZmxvdy55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYW5nZUNvbnRlbnQudyA9IF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkgJiYgaGFzT3ZlcmZsb3cueSA/IGNvbnRlbnRTY3JvbGxTaXplLncgKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS55IDogX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmFuZ2VDb250ZW50LmggPSBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIGhhc092ZXJmbG93LnggPyBjb250ZW50U2Nyb2xsU2l6ZS5oICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueCA6IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJhbmdlQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoYXJyYW5nZUNvbnRlbnQsIF9hcnJhbmdlQ29udGVudFNpemVDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FycmFuZ2VDb250ZW50U2l6ZUNhY2hlID0gYXJyYW5nZUNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc092ZXJmbG93LmMgfHwgaGlkZU92ZXJmbG93LmMgfHwgY29udGVudFNjcm9sbFNpemUuYyB8fCBjc3NEaXJlY3Rpb25DaGFuZ2VkIHx8IHdpZHRoQXV0b0NoYW5nZWQgfHwgaGVpZ2h0QXV0b0NoYW5nZWQgfHwgd2lkdGhBdXRvIHx8IGhlaWdodEF1dG8gfHwgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyTWFyZ2luTWludXMgKyBpc1JUTFJpZ2h0XSA9IGNvbnRlbnRFbGVtZW50Q1NTW19zdHJCb3JkZXJNaW51cyArIGlzUlRMUmlnaHRdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRFbGVtZW50Q1NTID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnMgPSBnZXRTY3JvbGxiYXJWYXJzKGhvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFyc0ludmVydGVkID0gZ2V0U2Nyb2xsYmFyVmFycyghaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4eSA9IHNjcm9sbGJhclZhcnMuX3hfeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckRpcmVjdGlvbiA9IGhvcml6b250YWwgPyBfc3RyQm90dG9tIDogaXNSVExMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW52ZXJ0ZWRBdXRvU2l6ZSA9IGhvcml6b250YWwgPyBoZWlnaHRBdXRvIDogd2lkdGhBdXRvO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkW3h5XSAmJiBoYXNPdmVyZmxvd1t4eV0gJiYgaGlkZU92ZXJmbG93W3h5ICsgJ3MnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgc3RyRGlyZWN0aW9uXSA9IGludmVydGVkQXV0b1NpemUgPyAoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZyA/IF9zdHJFbXB0eSA6IF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplW3h5XSkgOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyQm9yZGVyTWludXMgKyBzdHJEaXJlY3Rpb25dID0gKChob3Jpem9udGFsID8gIWludmVydGVkQXV0b1NpemUgOiB0cnVlKSAmJiAhaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZykgPyAoX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemVbeHldICsgYm9yZGVyRGVzaWduKSA6IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmFuZ2VDb250ZW50W3Njcm9sbGJhclZhcnNJbnZlcnRlZC5fd19oXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgc3RyRGlyZWN0aW9uXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckJvcmRlck1pbnVzICsgc3RyRGlyZWN0aW9uXSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmFuZ2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfdmlld3BvcnRFbGVtZW50LCBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzSW52aXNpYmxlLCAhaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbnRlbnRFbGVtZW50Q1NTKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50RWxlbWVudENTUyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJhbmdlQ29udGVudC53ID0gYXJyYW5nZUNvbnRlbnQuaCA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJhbmdlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYW5nZUNoYW5nZWQgJiYgIV9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEFycmFuZ2VFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBoaWRlT3ZlcmZsb3cueSA/IGFycmFuZ2VDb250ZW50LncgOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEFycmFuZ2VFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gaGlkZU92ZXJmbG93LnggPyBhcnJhbmdlQ29udGVudC5oIDogX3N0ckVtcHR5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9jb250ZW50QXJyYW5nZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRBcnJhbmdlRWxlbWVudCA9IEZSQU1FV09SSyhnZW5lcmF0ZURpdihfY2xhc3NOYW1lQ29udGVudEFycmFuZ2VFbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQucHJlcGVuZChfY29udGVudEFycmFuZ2VFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRBcnJhbmdlRWxlbWVudC5jc3MoY29udGVudEFycmFuZ2VFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoY29udGVudEVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRFbGVtZW50Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nRWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0Vmlld3BvcnRDU1M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3N0U2l6ZUNoYW5nZWQgfHwgaGFzT3ZlcmZsb3cuYyB8fCBoaWRlT3ZlcmZsb3cuYyB8fCBjb250ZW50U2Nyb2xsU2l6ZS5jIHx8IG92ZXJmbG93QmVoYXZpb3JDaGFuZ2VkIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQgfHwgY3NzRGlyZWN0aW9uQ2hhbmdlZCB8fCBjbGlwQWx3YXlzQ2hhbmdlZCB8fCBoZWlnaHRBdXRvQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW2lzUlRMUmlnaHRdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Vmlld3BvcnRDU1MgPSBmdW5jdGlvbiAoaG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFyc0ludmVydGVkID0gZ2V0U2Nyb2xsYmFyVmFycyghaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHh5ID0gc2Nyb2xsYmFyVmFycy5feF95O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBYWSA9IHNjcm9sbGJhclZhcnMuX1hfWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyRGlyZWN0aW9uID0gaG9yaXpvbnRhbCA/IF9zdHJCb3R0b20gOiBpc1JUTExlZnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW3N0ckRpcmVjdGlvbl0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50Qm9yZGVyU2l6ZVtzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQuX3dfaF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc092ZXJmbG93W3h5XSAmJiBoaWRlT3ZlcmZsb3dbeHkgKyAncyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tzdHJPdmVyZmxvdyArIFhZXSA9IF9zdHJTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nIHx8IF9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW3N0ckRpcmVjdGlvbl0gPSAtKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkW3h5XSA/IF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplW3h5XSA6IF9uYXRpdmVTY3JvbGxiYXJTaXplW3h5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEJvcmRlclNpemVbc2Nyb2xsYmFyVmFyc0ludmVydGVkLl93X2hdID0gX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWRbeHldID8gX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemVbc2Nyb2xsYmFyVmFyc0ludmVydGVkLl94X3ldIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tzdHJPdmVyZmxvdyArIFhZXSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Vmlld3BvcnRDU1ModHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWaWV3cG9ydENTUyhmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNjcm9sbCBjb250YWluZXIgaXMgdG9vIHNtYWxsIGFuZCBpZiB0aGVyZSBpcyBhbnkgb3ZlcmZsb3cgd2l0aCBubyBvdmVybGF5IHNjcm9sbGJhciAoYW5kIHNjcm9sbGJhciBzdHlsaW5nIGlzbid0IHBvc3NpYmxlKSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHZpZXdwb3J0IGVsZW1lbnQgZ3JlYXRlciBpbiBzaXplIChGaXJlZm94IGhpZGUgU2Nyb2xsYmFycyBmaXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGZpcmVmb3ggc3RhcnRzIGhpZGluZyBzY3JvbGxiYXJzIG9uIHRvbyBzbWFsbCBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGlzIGJlaGF2aW9yIHRoZSBvdmVyZmxvdyBjYWxjdWxhdGlvbiBtYXkgYmUgaW5jb3JyZWN0IG9yIHRoZSBzY3JvbGxiYXJzIHdvdWxkIGFwcGVhciBzdWRkZW5seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkyMjg0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKF92aWV3cG9ydFNpemUuaCA8IF9uYXRpdmVTY3JvbGxiYXJNaW5TaXplLnggfHwgX3ZpZXdwb3J0U2l6ZS53IDwgX25hdGl2ZVNjcm9sbGJhck1pblNpemUueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoKGhhc092ZXJmbG93LnggJiYgaGlkZU92ZXJmbG93LnggJiYgIV9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLngpIHx8IChoYXNPdmVyZmxvdy55ICYmIGhpZGVPdmVyZmxvdy55ICYmICFfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0clBhZGRpbmdNaW51cyArIF9zdHJUb3BdID0gX25hdGl2ZVNjcm9sbGJhck1pblNpemUueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgX3N0clRvcF0gPSAtX25hdGl2ZVNjcm9sbGJhck1pblNpemUueDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJQYWRkaW5nTWludXMgKyBpc1JUTFJpZ2h0XSA9IF9uYXRpdmVTY3JvbGxiYXJNaW5TaXplLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIGlzUlRMUmlnaHRdID0gLV9uYXRpdmVTY3JvbGxiYXJNaW5TaXplLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0clBhZGRpbmdNaW51cyArIF9zdHJUb3BdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIF9zdHJUb3BdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJQYWRkaW5nTWludXMgKyBpc1JUTFJpZ2h0XSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyTWFyZ2luTWludXMgKyBpc1JUTFJpZ2h0XSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyUGFkZGluZ01pbnVzICsgaXNSVExMZWZ0XSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIGlzUlRMTGVmdF0gPSBfc3RyRW1wdHk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVyZSBpcyBhbnkgb3ZlcmZsb3cgKHggT1IgeSBheGlzKSBhbmQgdGhpcyBvdmVyZmxvdyBzaGFsbCBiZSBoaWRkZW4sIG1ha2Ugb3ZlcmZsb3cgaGlkZGVuLCBlbHNlIG92ZXJmbG93IHZpc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaGFzT3ZlcmZsb3cueCAmJiBoaWRlT3ZlcmZsb3cueCkgfHwgKGhhc092ZXJmbG93LnkgJiYgaGlkZU92ZXJmbG93LnkpIHx8IGhpZGVPdmVyZmxvd0ZvcmNlVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29ubHkgaGlkZSBpZiBpcyBUZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSAmJiBoaWRlT3ZlcmZsb3dGb3JjZVRleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdFbGVtZW50Q1NTW3N0ck92ZXJmbG93WF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0VsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dZXSA9IHN0ckhpZGRlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsaXBBbHdheXMgfHwgKG92ZXJmbG93QmVoYXZpb3JJc1ZILnggfHwgb3ZlcmZsb3dCZWhhdmlvcklzVlMueCB8fCBvdmVyZmxvd0JlaGF2aW9ySXNWSC55IHx8IG92ZXJmbG93QmVoYXZpb3JJc1ZTLnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb25seSB1bi1oaWRlIGlmIFRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0VsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dYXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0VsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dZXSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dYXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1Nbc3RyT3ZlcmZsb3dZXSA9IHN0clZpc2libGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudC5jc3MocGFkZGluZ0VsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5jc3Modmlld3BvcnRFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTUyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yY2Ugc29mdCByZWRyYXcgaW4gd2Via2l0IGJlY2F1c2Ugd2l0aG91dCB0aGUgc2Nyb2xsYmFycyB3aWxsIG1heSBhcHBlYXIgYmVjYXVzZSBET00gd29udCBiZSByZWRyYXduIHVuZGVyIHNwZWNpYWwgY29uZGl0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChoYXNPdmVyZmxvdy5jIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgd2lkdGhBdXRvQ2hhbmdlZCB8fCBoZWlnaHRBdXRvQ2hhbmdlZCkgJiYgIShfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRTdHlsZSA9IF9jb250ZW50RWxlbWVudE5hdGl2ZVtMRVhJQ09OLnNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdW1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS5kaXNwbGF5ID0gJ3J1bi1pbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtcCA9IF9jb250ZW50RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9IXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U3R5bGUuZGlzcGxheSA9IF9zdHJFbXB0eTsgLy98fCBkdW1wOyAvL3VzZSBkdW1wIHRvIHByZXZlbnQgaXQgZnJvbSBkZWxldGlvbiBpZiBtaW5pZnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U3R5bGUud2Via2l0VHJhbnNmb3JtID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yY2UgaGFyZCByZWRyYXcgaW4gd2Via2l0IGlmIG5hdGl2ZSBvdmVybGFpZCBzY3JvbGxiYXJzIHNoYWxsIGFwcGVhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkICYmIGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnQuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdW1wID0gX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudC5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoYW5nZSB0byBkaXJlY3Rpb24gUlRMIGFuZCB3aWR0aCBhdXRvIEJ1Z2ZpeCBpbiBXZWJraXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy93aXRob3V0IHRoaXMgZml4LCB0aGUgRE9NIHN0aWxsIHRoaW5rcyB0aGUgc2Nyb2xsYmFyIGlzIExUUiBhbmQgdGh1cyB0aGUgY29udGVudCBpcyBzaGlmdGVkIHRvIHRoZSBsZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NEaXJlY3Rpb25DaGFuZ2VkIHx8IHdpZHRoQXV0b0NoYW5nZWQgfHwgaGVpZ2h0QXV0b0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNSVEwgJiYgd2lkdGhBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZsb2F0VG1wID0gX2NvbnRlbnRFbGVtZW50LmNzcyhfc3RyRmxvYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NMZWZ0V2l0aG91dEZsb2F0ID0gTUFUSC5yb3VuZChfY29udGVudEVsZW1lbnQuY3NzKF9zdHJGbG9hdCwgX3N0ckVtcHR5KS5jc3MoX3N0ckxlZnQsIF9zdHJFbXB0eSkucG9zaXRpb24oKS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKF9zdHJGbG9hdCwgZmxvYXRUbXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NMZWZ0V2l0aEZsb2F0ID0gTUFUSC5yb3VuZChfY29udGVudEVsZW1lbnQucG9zaXRpb24oKS5sZWZ0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc0xlZnRXaXRob3V0RmxvYXQgIT09IHBvc0xlZnRXaXRoRmxvYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJMZWZ0XSA9IHBvc0xlZnRXaXRob3V0RmxvYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyTGVmdF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhjb250ZW50RWxlbWVudENTUyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2hhbmRsZSBzY3JvbGwgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhICYmIGNvbnRlbnRTaXplQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhSW5mbyA9IGdldFRleHRhcmVhSW5mbygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRhcmVhSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVJvd3NDaGFuZ2VkID0gX3RleHRhcmVhSW5mb0NhY2hlID09PSB1bmRlZmluZWQgPyB0cnVlIDogdGV4dGFyZWFJbmZvLl9yb3dzICE9PSBfdGV4dGFyZWFJbmZvQ2FjaGUuX3Jvd3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvclJvdyA9IHRleHRhcmVhSW5mby5fY3Vyc29yUm93O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JDb2wgPSB0ZXh0YXJlYUluZm8uX2N1cnNvckNvbHVtbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkZXN0Um93ID0gdGV4dGFyZWFJbmZvLl93aWRlc3RSb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RSb3cgPSB0ZXh0YXJlYUluZm8uX3Jvd3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RDb2wgPSB0ZXh0YXJlYUluZm8uX2NvbHVtbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvclBvcyA9IHRleHRhcmVhSW5mby5fY3Vyc29yUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvck1heCA9IHRleHRhcmVhSW5mby5fY3Vyc29yTWF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JJc0xhc3RQb3NpdGlvbiA9IChjdXJzb3JQb3MgPj0gY3Vyc29yTWF4ICYmIF90ZXh0YXJlYUhhc0ZvY3VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFTY3JvbGxBbW91bnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6ICghdGV4dGFyZWFBdXRvV3JhcHBpbmcgJiYgKGN1cnNvckNvbCA9PT0gbGFzdENvbCAmJiBjdXJzb3JSb3cgPT09IHdpZGVzdFJvdykpID8gX292ZXJmbG93QW1vdW50Q2FjaGUueCA6IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAodGV4dGFyZWFBdXRvV3JhcHBpbmcgPyBjdXJzb3JJc0xhc3RQb3NpdGlvbiB8fCB0ZXh0YXJlYVJvd3NDaGFuZ2VkICYmIChwcmV2aW91c092ZXJmbG93QW1vdW50ID8gKGN1cnJTY3JvbGwueSA9PT0gcHJldmlvdXNPdmVyZmxvd0Ftb3VudC55KSA6IGZhbHNlKSA6IChjdXJzb3JJc0xhc3RQb3NpdGlvbiB8fCB0ZXh0YXJlYVJvd3NDaGFuZ2VkKSAmJiBjdXJzb3JSb3cgPT09IGxhc3RSb3cpID8gX292ZXJmbG93QW1vdW50Q2FjaGUueSA6IC0xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyU2Nyb2xsLnggPSB0ZXh0YXJlYVNjcm9sbEFtb3VudC54ID4gLTEgPyAoX2lzUlRMICYmIF9ub3JtYWxpemVSVExDYWNoZSAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IuaSA/IDAgOiB0ZXh0YXJlYVNjcm9sbEFtb3VudC54KSA6IGN1cnJTY3JvbGwueDsgLy9pZiBpbnZlcnRlZCwgc2Nyb2xsIHRvIDAgLT4gbm9ybWFsaXplZCB0aGlzIG1lYW5zIHRvIG1heCBzY3JvbGwgb2Zmc2V0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJTY3JvbGwueSA9IHRleHRhcmVhU2Nyb2xsQW1vdW50LnkgPiAtMSA/IHRleHRhcmVhU2Nyb2xsQW1vdW50LnkgOiBjdXJyU2Nyb2xsLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFJbmZvQ2FjaGUgPSB0ZXh0YXJlYUluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1JUTCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IuaSAmJiBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55ICYmIGhhc092ZXJmbG93LnggJiYgX25vcm1hbGl6ZVJUTENhY2hlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclNjcm9sbC54ICs9IF9jb250ZW50Qm9yZGVyU2l6ZS53IHx8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aEF1dG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0QXV0bylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudFtfc3RyU2Nyb2xsVG9wXSgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oY3VyclNjcm9sbC54KVtfc3RyU2Nyb2xsVG9wXShjdXJyU2Nyb2xsLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzIG1hbmFnZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzVmlzaWJpbGl0eVZpc2libGUgPSBzY3JvbGxiYXJzVmlzaWJpbGl0eSA9PT0gJ3YnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc1Zpc2liaWxpdHlIaWRkZW4gPSBzY3JvbGxiYXJzVmlzaWJpbGl0eSA9PT0gJ2gnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc1Zpc2liaWxpdHlBdXRvID0gc2Nyb2xsYmFyc1Zpc2liaWxpdHkgPT09ICdhJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZnJlc2hTY3JvbGxiYXJzVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIChzaG93WCwgc2hvd1kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dZID0gc2hvd1kgPT09IHVuZGVmaW5lZCA/IHNob3dYIDogc2hvd1k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyQXBwZWFyYW5jZSh0cnVlLCBzaG93WCwgY2FuU2Nyb2xsLngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyQXBwZWFyYW5jZShmYWxzZSwgc2hvd1ksIGNhblNjcm9sbC55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYW5hZ2UgY2xhc3MgbmFtZSB3aGljaCBpbmRpY2F0ZXMgc2Nyb2xsYWJsZSBvdmVyZmxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3csIGhpZGVPdmVyZmxvdy54IHx8IGhpZGVPdmVyZmxvdy55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdE92ZXJmbG93WCwgaGlkZU92ZXJmbG93LngpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3dZLCBoaWRlT3ZlcmZsb3cueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCBvciByZW1vdmUgcnRsIGNsYXNzIG5hbWUgZm9yIHN0eWxpbmcgcHVycG9zZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0RpcmVjdGlvbkNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RSVEwsIF9pc1JUTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFuYWdlIHRoZSByZXNpemUgZmVhdHVyZSAoQ1NTMyByZXNpemUgXCJwb2x5ZmlsbFwiIGZvciB0aGlzIHBsdWdpbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0JvZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0UmVzaXplRGlzYWJsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzaXplQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdFJlc2l6ZURpc2FibGVkLCBfcmVzaXplTm9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZSwgIV9yZXNpemVOb25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplQiwgX3Jlc2l6ZUJvdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQsIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVILCBfcmVzaXplSG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZVYsIF9yZXNpemVWZXJ0aWNhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFuYWdlIHRoZSBzY3JvbGxiYXJzIGdlbmVyYWwgdmlzaWJpbGl0eSArIHRoZSBzY3JvbGxiYXIgaW50ZXJhY3Rpdml0eSAodW51c2FibGUgY2xhc3MgbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhcnNWaXNpYmlsaXR5Q2hhbmdlZCB8fCBvdmVyZmxvd0JlaGF2aW9yQ2hhbmdlZCB8fCBoaWRlT3ZlcmZsb3cuYyB8fCBoYXNPdmVyZmxvdy5jIHx8IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0U2Nyb2xsaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzVmlzaWJpbGl0eShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxiYXJzVmlzaWJpbGl0eUF1dG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc1Zpc2liaWxpdHkoY2FuU2Nyb2xsLngsIGNhblNjcm9sbC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbGJhcnNWaXNpYmlsaXR5VmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzVmlzaWJpbGl0eSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbGJhcnNWaXNpYmlsaXR5SGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNWaXNpYmlsaXR5KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYW5hZ2UgdGhlIHNjcm9sbGJhcnMgYXV0byBoaWRlIGZlYXR1cmUgKGF1dG8gaGlkZSB0aGVtIGFmdGVyIHNwZWNpZmljIGFjdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxiYXJzQXV0b0hpZGVDaGFuZ2VkIHx8IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cEhvc3RNb3VzZVRvdWNoRXZlbnRzKCFfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmUgJiYgIV9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoX3Njcm9sbGJhcnNBdXRvSGlkZU5ldmVyLCAhX3Njcm9sbGJhcnNBdXRvSGlkZU5ldmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYW5hZ2Ugc2Nyb2xsYmFycyBoYW5kbGUgbGVuZ3RoICYgb2Zmc2V0IC0gZG9uJ3QgcmVtb3ZlIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdFNpemVDaGFuZ2VkIHx8IG92ZXJmbG93QW1vdW50LmMgfHwgaGVpZ2h0QXV0b0NoYW5nZWQgfHwgd2lkdGhBdXRvQ2hhbmdlZCB8fCByZXNpemVDaGFuZ2VkIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgcGFkZGluZ0Fic29sdXRlQ2hhbmdlZCB8fCBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCB8fCBjc3NEaXJlY3Rpb25DaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlTGVuZ3RoKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVMZW5ndGgoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFuYWdlIGludGVyYWN0aXZpdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0ludGVyYWN0aXZlKHRydWUsIHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZ0NoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0ludGVyYWN0aXZlKGZhbHNlLCBzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGxiYWNrczpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25EaXJlY3Rpb25DaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSVEw6IF9pc1JUTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcjogY3NzRGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNzc0RpcmVjdGlvbkNoYW5nZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbkhvc3RTaXplQ2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfaG9zdFNpemVDYWNoZS53LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfaG9zdFNpemVDYWNoZS5oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGhvc3RTaXplQ2hhbmdlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uQ29udGVudFNpemVDaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlLncsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlLmhcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29udGVudFNpemVDaGFuZ2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25PdmVyZmxvd0NoYW5nZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBoYXNPdmVyZmxvdy54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaGFzT3ZlcmZsb3cueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhTY3JvbGxhYmxlOiBoaWRlT3ZlcmZsb3cueHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5U2Nyb2xsYWJsZTogaGlkZU92ZXJmbG93LnlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZDogaGlkZU92ZXJmbG93LnggfHwgaGlkZU92ZXJmbG93LnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgaGFzT3ZlcmZsb3cuYyB8fCBoaWRlT3ZlcmZsb3cuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uT3ZlcmZsb3dBbW91bnRDaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogb3ZlcmZsb3dBbW91bnQueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IG92ZXJmbG93QW1vdW50LnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3ZlcmZsb3dBbW91bnQuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZpeCBib2R5IG1pbiBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0JvZHkgJiYgX2JvZHlNaW5TaXplQ2FjaGUgJiYgKF9oYXNPdmVyZmxvd0NhY2hlLmMgfHwgX2JvZHlNaW5TaXplQ2FjaGUuYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pdHMgcG9zc2libGUgdGhhdCBubyBtaW4gc2l6ZSB3YXMgbWVhc3VyZWQgdW50aWwgbm93LCBiZWNhdXNlIHRoZSBjb250ZW50IGFycmFuZ2UgZWxlbWVudCB3YXMganVzdCBhZGRlZCBub3csIGluIHRoaXMgY2FzZSwgbWVhc3VyZSBub3cgdGhlIG1pbiBzaXplLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9ib2R5TWluU2l6ZUNhY2hlLmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5TWluU2l6ZUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkgJiYgX2hhc092ZXJmbG93Q2FjaGUueClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoX3N0ck1pbk1pbnVzICsgX3N0cldpZHRoLCBfYm9keU1pblNpemVDYWNoZS53ICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9oYXNPdmVyZmxvd0NhY2hlLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKF9zdHJNaW5NaW51cyArIF9zdHJIZWlnaHQsIF9ib2R5TWluU2l6ZUNhY2hlLmggKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS54KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2JvZHlNaW5TaXplQ2FjaGUuYyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pbml0aWFsaXplZCAmJiBjaGFuZ2VkT3B0aW9ucy51cGRhdGVPbkxvYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudHNPbkxvYWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZnJlZXplUmVzaXplT2JzZXJ2ZXIoX3NpemVPYnNlcnZlckVsZW1lbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZyZWV6ZVJlc2l6ZU9ic2VydmVyKF9zaXplQXV0b09ic2VydmVyRWxlbWVudCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvblVwZGF0ZWQnLCB7IGZvcmNlZDogZm9yY2UgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVcGRhdGVzIHRoZSBmb3VuZCBlbGVtZW50cyBvZiB3aGljaCB0aGUgbG9hZCBldmVudCBzaGFsbCBiZSBoYW5kbGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50c09uTG9hZCgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pc1RleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2hVcGRhdGVPbkxvYWQoZnVuY3Rpb24gKGksIHVwZGF0ZU9uTG9hZFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuZmluZCh1cGRhdGVPbkxvYWRTZWxlY3RvcikuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIHVwZGF0ZU9uTG9hZENhbGxiYWNrIGFwcGxpZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pbkEoZWwsIF91cGRhdGVPbkxvYWRFbG1zKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZU9uTG9hZEVsbXMucHVzaChlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSyhlbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vZmYoX3VwZGF0ZU9uTG9hZEV2ZW50TmFtZSwgdXBkYXRlT25Mb2FkQ2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oX3VwZGF0ZU9uTG9hZEV2ZW50TmFtZSwgdXBkYXRlT25Mb2FkQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IE9wdGlvbnMgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIG5ldyBvcHRpb25zIGJ1dCBkb2Vzbid0IGNhbGwgdGhlIHVwZGF0ZSBtZXRob2QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbmV3T3B0aW9ucyBUaGUgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBuZXcgb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBBIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgY2hhbmdlZCBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRPcHRpb25zKG5ld09wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGVkT3B0cyA9IF9wbHVnaW5zT3B0aW9ucy5fdmFsaWRhdGUobmV3T3B0aW9ucywgX3BsdWdpbnNPcHRpb25zLl90ZW1wbGF0ZSwgdHJ1ZSwgX2N1cnJlbnRPcHRpb25zKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfY3VycmVudE9wdGlvbnMgPSBleHRlbmREZWVwKHt9LCBfY3VycmVudE9wdGlvbnMsIHZhbGlkYXRlZE9wdHMuX2RlZmF1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jdXJyZW50UHJlcGFyZWRPcHRpb25zID0gZXh0ZW5kRGVlcCh7fSwgX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMsIHZhbGlkYXRlZE9wdHMuX3ByZXBhcmVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlZE9wdHMuX3ByZXBhcmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gU3RydWN0dXJlID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQnVpbGRzIG9yIGRlc3Ryb3lzIHRoZSB3cmFwcGVyIGFuZCBoZWxwZXIgRE9NIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGRlc3Ryb3kgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIERPTSBzaGFsbCBiZSBidWlsZCBvciBkZXN0cm95ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQnVpbGRzIG9yIGRlc3Ryb3lzIHRoZSB3cmFwcGVyIGFuZCBoZWxwZXIgRE9NIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGRlc3Ryb3kgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIERPTSBzaGFsbCBiZSBidWlsZCBvciBkZXN0cm95ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwU3RydWN0dXJlRE9NKGRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyUGFyZW50ID0gJ3BhcmVudCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZVJlc2l6ZU9ic2VydmVySG9zdCA9ICdvcy1yZXNpemUtb2JzZXJ2ZXItaG9zdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZVRleHRhcmVhRWxlbWVudEZ1bGwgPSBfY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50ICsgX3N0clNwYWNlICsgX2NsYXNzTmFtZVRleHRJbmhlcml0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUNsYXNzID0gX2lzVGV4dGFyZWEgPyBfc3RyU3BhY2UgKyBfY2xhc3NOYW1lVGV4dEluaGVyaXQgOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkb3B0QXR0cnMgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy50ZXh0YXJlYS5pbmhlcml0ZWRBdHRycztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRvcHRBdHRyc01hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcHBseUFkb3B0ZWRBdHRycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwcGx5QWRvcHRlZEF0dHJzRWxtID0gZGVzdHJveSA/IF90YXJnZXRFbGVtZW50IDogX2hvc3RFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKGFkb3B0QXR0cnNNYXAsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSh2YWx1ZSkgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gTEVYSUNPTi5jKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseUFkb3B0ZWRBdHRyc0VsbS5hZGRDbGFzcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseUFkb3B0ZWRBdHRyc0VsbS5hdHRyKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBob3N0RWxlbWVudENsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RFbGVtZW50Rm9yZWlnbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RUZXh0YXJlYUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0UmVzaXplRGlzYWJsZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0UlRMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdFNjcm9sbGJhckhvcml6b250YWxIaWRkZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0U2Nyb2xsYmFyVmVydGljYWxIaWRkZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0VHJhbnNpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RTY3JvbGxpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3dYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdE92ZXJmbG93WSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVRoZW1lTm9uZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVRleHRhcmVhRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVRleHRJbmhlcml0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lQ2FjaGVdLmpvaW4oX3N0clNwYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEVsZW1lbnRDU1MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgaG9zdCBlbGVtZW50IGFzIGZpcnN0IGVsZW1lbnQsIGJlY2F1c2UgdGhhdCdzIHRoZSBtb3N0IHVwcGVyIGVsZW1lbnQgYW5kIHJlcXVpcmVkIGZvciB0aGUgb3RoZXIgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnQgPSBfaG9zdEVsZW1lbnQgfHwgKF9pc1RleHRhcmVhID8gKF9kb21FeGlzdHMgPyBfdGFyZ2V0RWxlbWVudFtzdHJQYXJlbnRdKClbc3RyUGFyZW50XSgpW3N0clBhcmVudF0oKVtzdHJQYXJlbnRdKCkgOiBGUkFNRVdPUksoZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZUhvc3RUZXh0YXJlYUVsZW1lbnQpKSkgOiBfdGFyZ2V0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50ID0gX2NvbnRlbnRFbGVtZW50IHx8IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKF9jbGFzc05hbWVDb250ZW50RWxlbWVudCArIHRleHRhcmVhQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQgPSBfdmlld3BvcnRFbGVtZW50IHx8IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKF9jbGFzc05hbWVWaWV3cG9ydEVsZW1lbnQgKyB0ZXh0YXJlYUNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICBfcGFkZGluZ0VsZW1lbnQgPSBfcGFkZGluZ0VsZW1lbnQgfHwgc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZVBhZGRpbmdFbGVtZW50ICsgdGV4dGFyZWFDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NpemVPYnNlcnZlckVsZW1lbnQgPSBfc2l6ZU9ic2VydmVyRWxlbWVudCB8fCBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhjbGFzc05hbWVSZXNpemVPYnNlcnZlckhvc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUNvdmVyRWxlbWVudCA9IF90ZXh0YXJlYUNvdmVyRWxlbWVudCB8fCAoX2lzVGV4dGFyZWEgPyBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lVGV4dGFyZWFDb3ZlckVsZW1lbnQpIDogdW5kZWZpbmVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhpcyBjbGFzcyB0byB3b3JrYXJvdW5kIGNsYXNzIGNoYW5naW5nIGlzc3VlcyB3aXRoIFVJIGZyYW1ld29ya3MgZXNwZWNpYWxseSBWdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2RvbUV4aXN0cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdEVsZW1lbnRGb3JlaWduKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9vbiBkZXN0cm95LCByZW1vdmUgYWxsIGdlbmVyYXRlZCBjbGFzcyBuYW1lcyBmcm9tIHRoZSBob3N0IGVsZW1lbnQgYmVmb3JlIGNvbGxlY3RpbmcgdGhlIGFkb3B0ZWQgYXR0cmlidXRlcyBcclxuICAgICAgICAgICAgICAgICAgICAvL3RvIHByZXZlbnQgYWRvcHRpbmcgZ2VuZXJhdGVkIGNsYXNzIG5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgaG9zdEVsZW1lbnRDbGFzc05hbWVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb2xsZWN0IGFsbCBhZG9wdGVkIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICBhZG9wdEF0dHJzID0gdHlwZShhZG9wdEF0dHJzKSA9PSBUWVBFUy5zID8gYWRvcHRBdHRycy5zcGxpdChfc3RyU3BhY2UpIDogYWRvcHRBdHRycztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pc0EoYWRvcHRBdHRycykgJiYgX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChhZG9wdEF0dHJzLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUodikgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkb3B0QXR0cnNNYXBbdl0gPSBkZXN0cm95ID8gX2hvc3RFbGVtZW50LmF0dHIodikgOiBfdGFyZ2V0RWxlbWVudC5hdHRyKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuc2l6ZUF1dG9DYXBhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdEVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IF90YXJnZXRFbGVtZW50LmNzcyhfc3RyV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gX3RhcmdldEVsZW1lbnQuY3NzKF9zdHJIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2RvbUV4aXN0cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudC5hZGRDbGFzcyhfY2xhc3NOYW1lVGV4dEluaGVyaXQpLndyYXAoX2hvc3RFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2pRdWVyeSBjbG9uZXMgZWxlbWVudHMgaW4gd3JhcCBmdW5jdGlvbnMsIHNvIHdlIGhhdmUgdG8gc2VsZWN0IHRoZW0gYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudCA9IF90YXJnZXRFbGVtZW50W3N0clBhcmVudF0oKS5jc3MoaG9zdEVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kb21FeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIHRoZSBjb3JyZWN0IGNsYXNzIHRvIHRoZSB0YXJnZXQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX3RhcmdldEVsZW1lbnQsIF9pc1RleHRhcmVhID8gY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50RnVsbCA6IF9jbGFzc05hbWVIb3N0RWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93cmFwIHRoZSBjb250ZW50IGludG8gdGhlIGdlbmVyYXRlZCBlbGVtZW50cyB0byBjcmVhdGUgdGhlIHJlcXVpcmVkIERPTVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50LndyYXBJbm5lcihfY29udGVudEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLndyYXBJbm5lcihfdmlld3BvcnRFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53cmFwSW5uZXIoX3BhZGRpbmdFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcmVwZW5kKF9zaXplT2JzZXJ2ZXJFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2pRdWVyeSBjbG9uZXMgZWxlbWVudHMgaW4gd3JhcCBmdW5jdGlvbnMsIHNvIHdlIGhhdmUgdG8gc2VsZWN0IHRoZW0gYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudCA9IGZpbmRGaXJzdChfaG9zdEVsZW1lbnQsIF9zdHJEb3QgKyBfY2xhc3NOYW1lQ29udGVudEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudCA9IGZpbmRGaXJzdChfaG9zdEVsZW1lbnQsIF9zdHJEb3QgKyBfY2xhc3NOYW1lVmlld3BvcnRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudCA9IGZpbmRGaXJzdChfaG9zdEVsZW1lbnQsIF9zdHJEb3QgKyBfY2xhc3NOYW1lUGFkZGluZ0VsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5wcmVwZW5kKF90ZXh0YXJlYUNvdmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlBZG9wdGVkQXR0cnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX3ZpZXdwb3J0RWxlbWVudCwgX2NsYXNzTmFtZVZpZXdwb3J0TmF0aXZlU2Nyb2xsYmFyc0ludmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfdmlld3BvcnRFbGVtZW50LCBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQm9keSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9odG1sRWxlbWVudCwgX2NsYXNzTmFtZUhUTUxFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplT2JzZXJ2ZXJFbGVtZW50TmF0aXZlID0gX3NpemVPYnNlcnZlckVsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudE5hdGl2ZSA9IF9ob3N0RWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50TmF0aXZlID0gX3BhZGRpbmdFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50TmF0aXZlID0gX3ZpZXdwb3J0RWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50TmF0aXZlID0gX2NvbnRlbnRFbGVtZW50WzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlld3BvcnRBdHRyc0Zyb21UYXJnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZG9tRXhpc3RzICYmIF9pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jbGVhciBzaXplIG9ic2VydmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZU9ic2VydmVyRWxlbWVudC5jaGlsZHJlbigpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBzdHlsZSBwcm9wZXJ0eSBhbmQgY2xhc3NlcyBmcm9tIGFscmVhZHkgZ2VuZXJhdGVkIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoKFtfcGFkZGluZ0VsZW1lbnQsIF92aWV3cG9ydEVsZW1lbnQsIF9jb250ZW50RWxlbWVudCwgX3RleHRhcmVhQ292ZXJFbGVtZW50XSwgZnVuY3Rpb24gKGksIGVsbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxtLnJlbW92ZUF0dHIoTEVYSUNPTi5zKSwgX2NsYXNzTmFtZXNEeW5hbWljRGVzdHJveSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGQgY2xhc3NlcyB0byB0aGUgaG9zdCBlbGVtZW50IHdoaWNoIHdhcyByZW1vdmVkIHByZXZpb3VzbHkgdG8gbWF0Y2ggdGhlIGV4cGVjdGVkIERPTVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2hvc3RFbGVtZW50LCBfaXNUZXh0YXJlYSA/IF9jbGFzc05hbWVIb3N0VGV4dGFyZWFFbGVtZW50IDogX2NsYXNzTmFtZUhvc3RFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHNpemUgb2JzZXJ2ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfc2l6ZU9ic2VydmVyRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91bndyYXAgdGhlIGNvbnRlbnQgdG8gcmVzdG9yZSBET01cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jb250ZW50cygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVud3JhcCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVud3JhcCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVud3JhcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LnVud3JhcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfaG9zdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfdGV4dGFyZWFDb3ZlckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5QWRvcHRlZEF0dHJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LnJlbW92ZUF0dHIoTEVYSUNPTi5zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNCb2R5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2h0bWxFbGVtZW50LCBfY2xhc3NOYW1lSFRNTEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgb3IgcmVtb3ZlcyBhbGwgd3JhcHBlciBlbGVtZW50cyBpbnRlcmFjdGl2aXR5IGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZXN0cm95IEluZGljYXRlcyB3aGV0aGVyIHRoZSBFdmVudHMgc2hhbGwgYmUgYWRkZWQgb3IgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBTdHJ1Y3R1cmVFdmVudHMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhS2V5RG93blJlc3RyaWN0ZWRLZXlDb2RlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTEyLCAxMTMsIDExNCwgMTE1LCAxMTYsIDExNywgMTE4LCAxMTksIDEyMCwgMTIxLCAxMjMsICAgIC8vRjEgdG8gRjEyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDMzLCAzNCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BhZ2UgdXAsIHBhZ2UgZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICAzNywgMzgsIDM5LCA0MCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sZWZ0LCB1cCwgcmlnaHQsIGRvd24gYXJyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDE2LCAxNywgMTgsIDE5LCAyMCwgMTQ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NoaWZ0LCBDdHJsLCBBbHQsIFBhdXNlLCBDYXBzTG9jaywgTnVtTG9ja1xyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVVwZGF0ZUludGVydmFsSUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFN0b3BUaW1lb3V0SWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFN0b3BEZWxheSA9IDE3NTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyRm9jdXMgPSAnZm9jdXMnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVUZXh0YXJlYShkb0NsZWFySW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFVcGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKF9zdHJBdXRvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvQ2xlYXJJbnRlcnZhbCAmJiBfYXV0b1VwZGF0ZVJlY29tbWVuZGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0ZXh0YXJlYVVwZGF0ZUludGVydmFsSUQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXh0YXJlYU9uU2Nyb2xsKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShfcnRsU2Nyb2xsQmVoYXZpb3IuaSAmJiBfbm9ybWFsaXplUlRMQ2FjaGUgPyA5OTk5OTk5IDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50W19zdHJTY3JvbGxUb3BdKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnN0cFAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhT25Ecm9wKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZGVzdHJveWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRhcmVhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdGV4dGFyZWFPbkZvY3VzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFIYXNGb2N1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ob3N0RWxlbWVudCwgc3RyRm9jdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXh0YXJlYU9uRm9jdXNvdXQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUhhc0ZvY3VzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIHN0ckZvY3VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dGFyZWEodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhT25LZXlEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KGtleUNvZGUsIHRleHRhcmVhS2V5RG93blJlc3RyaWN0ZWRLZXlDb2RlcykgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdFtMRVhJQ09OLmxdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dGFyZWEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYVVwZGF0ZUludGVydmFsSUQgPSBzZXRJbnRlcnZhbCh1cGRhdGVUZXh0YXJlYSwgMTAwMCAvIDYwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KGtleUNvZGUsIHRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdCkgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdC5wdXNoKGtleUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhT25LZXlVcChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkoa2V5Q29kZSwgdGV4dGFyZWFLZXlEb3duS2V5Q29kZXNMaXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KGtleUNvZGUsIHRleHRhcmVhS2V5RG93blJlc3RyaWN0ZWRLZXlDb2RlcykgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYUtleURvd25LZXlDb2Rlc0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGV4dGFyZWFLZXlEb3duS2V5Q29kZXNMaXN0W0xFWElDT04ubF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dGFyZWEodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY29udGVudE9uVHJhbnNpdGlvbkVuZChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2F1dG9VcGRhdGVDYWNoZSA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTaXplQWZmZWN0aW5nQ1NTUHJvcGVydHkoZXZlbnQucHJvcGVydHlOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZShfc3RyQXV0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHZpZXdwb3J0T25TY3JvbGwoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfc2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxTdG9wVGltZW91dElkICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFN0b3BUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlT3ZlcmxheVNjcm9sbGJhcnNBcmVBY3RpdmUoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdFNjcm9sbGluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uU2Nyb2xsU3RhcnQnLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBhIHNjcm9sbGJhcnMgaGFuZGxlIGdldHMgZHJhZ2dlZCwgdGhlIG1vdXNlbW92ZSBldmVudCBpcyByZXNwb25zaWJsZSBmb3IgcmVmcmVzaGluZyB0aGUgaGFuZGxlIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iZWNhdXNlIGlmIENTUyBzY3JvbGwtc25hcCBpcyB1c2VkLCB0aGUgaGFuZGxlIG9mZnNldCBnZXRzIG9ubHkgcmVmcmVzaGVkIG9uIGV2ZXJ5IHNuYXAgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBsb29rcyBsYWdneSAmIGNsdW5reSwgaXQgbG9va3MgbXVjaCBiZXR0ZXIgaWYgdGhlIG9mZnNldCByZWZyZXNoZXMgd2l0aCB0aGUgbW91c2Vtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvblNjcm9sbCcsIGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxTdG9wVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vT25TY3JvbGxTdG9wOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsU3RvcFRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFN0b3BUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbCB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVPdmVybGF5U2Nyb2xsYmFyc0FyZUFjdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdFNjcm9sbGluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvblNjcm9sbFN0b3AnLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2Nyb2xsU3RvcERlbGF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX21zaWVWZXJzaW9uID4gOSB8fCAhX2F1dG9VcGRhdGVSZWNvbW1lbmRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoX3RhcmdldEVsZW1lbnQsICdpbnB1dCcsIHVwZGF0ZVRleHRhcmVhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKF90YXJnZXRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyS2V5RG93bkV2ZW50LCBfc3RyS2V5VXBFdmVudF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RleHRhcmVhT25LZXlEb3duLCB0ZXh0YXJlYU9uS2V5VXBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoX3RhcmdldEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3N0clNjcm9sbCwgJ2Ryb3AnLCBzdHJGb2N1cywgc3RyRm9jdXMgKyAnb3V0J10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGV4dGFyZWFPblNjcm9sbCwgdGV4dGFyZWFPbkRyb3AsIHRleHRhcmVhT25Gb2N1cywgdGV4dGFyZWFPbkZvY3Vzb3V0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihfY29udGVudEVsZW1lbnQsIF9zdHJUcmFuc2l0aW9uRW5kRXZlbnQsIGNvbnRlbnRPblRyYW5zaXRpb25FbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihfdmlld3BvcnRFbGVtZW50LCBfc3RyU2Nyb2xsLCB2aWV3cG9ydE9uU2Nyb2xsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFNjcm9sbGJhcnMgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBCdWlsZHMgb3IgZGVzdHJveXMgYWxsIHNjcm9sbGJhciBET00gZWxlbWVudHMgKHNjcm9sbGJhciwgdHJhY2ssIGhhbmRsZSlcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZXN0cm95IEluZGljYXRlcyB3aGV0aGVyIHRoZSBET00gc2hhbGwgYmUgYnVpbGQgb3IgZGVzdHJveWVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFNjcm9sbGJhcnNET00oZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RPckdlbmVyYXRlU2Nyb2xsYmFyRE9NID0gZnVuY3Rpb24gKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyQ2xhc3NOYW1lID0gaXNIb3Jpem9udGFsID8gX2NsYXNzTmFtZVNjcm9sbGJhckhvcml6b250YWwgOiBfY2xhc3NOYW1lU2Nyb2xsYmFyVmVydGljYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXIgPSBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lU2Nyb2xsYmFyICsgX3N0clNwYWNlICsgc2Nyb2xsYmFyQ2xhc3NOYW1lLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZVNjcm9sbGJhclRyYWNrLCBzY3JvbGxiYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZSwgc2Nyb2xsYmFyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2RvbUV4aXN0cyAmJiAhZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyLmFwcGVuZCh0cmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5hcHBlbmQoaGFuZGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXI6IHNjcm9sbGJhcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90cmFjazogdHJhY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaGFuZGxlOiBoYW5kbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc2V0U2Nyb2xsYmFyRE9NKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaXNIb3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhciA9IHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gc2Nyb2xsYmFyVmFycy5fdHJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzY3JvbGxiYXJWYXJzLl9oYW5kbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RvbUV4aXN0cyAmJiBfaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goW3Njcm9sbGJhciwgdHJhY2ssIGhhbmRsZV0sIGZ1bmN0aW9uIChpLCBlbG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbG0ucmVtb3ZlQXR0cihMRVhJQ09OLnMpLCBfY2xhc3NOYW1lc0R5bmFtaWNEZXN0cm95KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHNjcm9sbGJhciB8fCBzZWxlY3RPckdlbmVyYXRlU2Nyb2xsYmFyRE9NKGlzSG9yaXpvbnRhbCkuX3Njcm9sbGJhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvcml6b250YWxFbGVtZW50cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGljYWxFbGVtZW50cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvcml6b250YWxFbGVtZW50cyA9IHNlbGVjdE9yR2VuZXJhdGVTY3JvbGxiYXJET00odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsRWxlbWVudHMgPSBzZWxlY3RPckdlbmVyYXRlU2Nyb2xsYmFyRE9NKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFySG9yaXpvbnRhbEVsZW1lbnQgPSBob3Jpem9udGFsRWxlbWVudHMuX3Njcm9sbGJhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhckhvcml6b250YWxUcmFja0VsZW1lbnQgPSBob3Jpem9udGFsRWxlbWVudHMuX3RyYWNrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFySG9yaXpvbnRhbEhhbmRsZUVsZW1lbnQgPSBob3Jpem9udGFsRWxlbWVudHMuX2hhbmRsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudCA9IHZlcnRpY2FsRWxlbWVudHMuX3Njcm9sbGJhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhclZlcnRpY2FsVHJhY2tFbGVtZW50ID0gdmVydGljYWxFbGVtZW50cy5fdHJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJWZXJ0aWNhbEhhbmRsZUVsZW1lbnQgPSB2ZXJ0aWNhbEVsZW1lbnRzLl9oYW5kbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kb21FeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudC5hZnRlcihfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudC5hZnRlcihfc2Nyb2xsYmFySG9yaXpvbnRhbEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFNjcm9sbGJhckRPTSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRTY3JvbGxiYXJET00oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhbGwgc2Nyb2xsYmFyIGludGVyYWN0aXZpdHkgZXZlbnRzLiAodHJhY2sgYW5kIGhhbmRsZSBkcmFnZ2luZywgY2xpY2tpbmcsIHNjcm9sbGluZylcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpc0hvcml6b250YWwgVHJ1ZSBpZiB0aGUgdGFyZ2V0IHNjcm9sbGJhciBpcyB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIsIGZhbHNlIGlmIHRoZSB0YXJnZXQgc2Nyb2xsYmFyIGlzIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwU2Nyb2xsYmFyRXZlbnRzKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhpc0hvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzSW5mbyA9IHNjcm9sbGJhclZhcnMuX2luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc2lkZUlGcmFtZSA9IF93aW5kb3dFbGVtZW50TmF0aXZlLnRvcCAhPT0gX3dpbmRvd0VsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHh5ID0gc2Nyb2xsYmFyVmFycy5feF95O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBYWSA9IHNjcm9sbGJhclZhcnMuX1hfWTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsID0gX3N0clNjcm9sbCArIHNjcm9sbGJhclZhcnMuX0xlZnRfVG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJBY3RpdmUgPSAnYWN0aXZlJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyU25hcEhhbmRsZSA9ICdzbmFwSGFuZGxlJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsRHVyYXRpb25GYWN0b3IgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmNyZWFzZURlY3JlYXNlU2Nyb2xsQW1vdW50S2V5Q29kZXMgPSBbMTYsIDE3XTsgLy9zaGlmdCwgY3RybFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFja1RpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRG93blNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VEb3duT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZURvd25JbnZlcnRlZFNjYWxlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9tc2llVmVyc2lvbiAmJiBpbnNpZGVJRnJhbWUgPyBldmVudFsnc2NyZWVuJyArIFhZXSA6IENPTVBBVElCSUxJVFkucGFnZShldmVudClbeHldOyAvL3VzZSBzY3JlZW4gY29vcmRpbmF0ZXMgaW4gRURHRSAmIElFIGJlY2F1c2UgdGhlIHBhZ2UgdmFsdWVzIGFyZSBpbmNvcnJlY3QgaW4gZnJhbWVzLlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRQcmVwYXJlZFNjcm9sbGJhcnNPcHRpb24obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuc2Nyb2xsYmFyc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaW5jcmVhc2VUcmFja1Njcm9sbEFtb3VudCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRHVyYXRpb25GYWN0b3IgPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlY3JlYXNlVHJhY2tTY3JvbGxBbW91bnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbER1cmF0aW9uRmFjdG9yID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRLZXlEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KGV2ZW50LmtleUNvZGUsIGluY3JlYXNlRGVjcmVhc2VTY3JvbGxBbW91bnRLZXlDb2RlcykgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlYXNlVHJhY2tTY3JvbGxBbW91bnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRLZXlVcChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShldmVudC5rZXlDb2RlLCBpbmNyZWFzZURlY3JlYXNlU2Nyb2xsQW1vdW50S2V5Q29kZXMpID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNyZWFzZVRyYWNrU2Nyb2xsQW1vdW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uTW91c2VUb3VjaERvd25Db250aW51ZShldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1RvdWNoRXZlbnQgPSBvcmlnaW5hbEV2ZW50LnRvdWNoZXMgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zbGVlcGluZyB8fCBfZGVzdHJveWVkIHx8IG5hdGl2ZU92ZXJsYXlTY3JvbGxiYXJzQXJlQWN0aXZlKCkgfHwgIV9zY3JvbGxiYXJzRHJhZ1Njcm9sbGluZ0NhY2hlIHx8IChpc1RvdWNoRXZlbnQgJiYgIWdldFByZXBhcmVkU2Nyb2xsYmFyc09wdGlvbigndG91Y2hTdXBwb3J0JykpID8gZmFsc2UgOiBDT01QQVRJQklMSVRZLm1CdG4oZXZlbnQpID09PSAxIHx8IGlzVG91Y2hFdmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnREcmFnTW92ZShldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25Nb3VzZVRvdWNoRG93bkNvbnRpbnVlKGV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrTGVuZ3RoID0gc2Nyb2xsYmFyVmFyc0luZm8uX3RyYWNrTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUxlbmd0aCA9IHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsUmFuZ2UgPSBzY3JvbGxiYXJWYXJzSW5mby5fbWF4U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFJhdyA9IChnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpIC0gbW91c2VEb3duT2Zmc2V0KSAqIG1vdXNlRG93bkludmVydGVkU2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsRGVsdGFQZXJjZW50ID0gc2Nyb2xsUmF3IC8gKHRyYWNrTGVuZ3RoIC0gaGFuZGxlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxEZWx0YSA9IChzY3JvbGxSYW5nZSAqIHNjcm9sbERlbHRhUGVyY2VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEZWx0YSA9IGlzRmluaXRlKHNjcm9sbERlbHRhKSA/IHNjcm9sbERlbHRhIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNSVEwgJiYgaXNIb3Jpem9udGFsICYmICFfcnRsU2Nyb2xsQmVoYXZpb3IuaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEZWx0YSAqPSAtMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50W3Njcm9sbF0oTUFUSC5yb3VuZChtb3VzZURvd25TY3JvbGwgKyBzY3JvbGxEZWx0YSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChpc0hvcml6b250YWwsIG1vdXNlRG93blNjcm9sbCArIHNjcm9sbERlbHRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9zdXBwb3J0UGFzc2l2ZUV2ZW50cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50TW91c2VUb3VjaFVwKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRNb3VzZVRvdWNoVXAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudCB8fCBldmVudC5vcmlnaW5hbEV2ZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJNb3VzZVRvdWNoTW92ZUV2ZW50LCBfc3RyTW91c2VUb3VjaFVwRXZlbnQsIF9zdHJLZXlEb3duRXZlbnQsIF9zdHJLZXlVcEV2ZW50LCBfc3RyU2VsZWN0U3RhcnRFdmVudF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZG9jdW1lbnREcmFnTW92ZSwgZG9jdW1lbnRNb3VzZVRvdWNoVXAsIGRvY3VtZW50S2V5RG93biwgZG9jdW1lbnRLZXlVcCwgZG9jdW1lbnRPblNlbGVjdFN0YXJ0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoaXNIb3Jpem9udGFsLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfYm9keUVsZW1lbnQsIF9jbGFzc05hbWVEcmFnZ2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjcm9sbGJhclZhcnMuX2hhbmRsZSwgc3RyQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2Nyb2xsYmFyVmFycy5fdHJhY2ssIHN0ckFjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhciwgc3RyQWN0aXZlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93blNjcm9sbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duT2Zmc2V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25JbnZlcnRlZFNjYWxlID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY3JlYXNlVHJhY2tTY3JvbGxBbW91bnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFja1RpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2Uuc2Nyb2xsU3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRyYWNrVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1RpbWVvdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5iQ1JdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VJbnNpZGVIb3N0ID0gZXZlbnQuY2xpZW50WCA+PSByZWN0LmxlZnQgJiYgZXZlbnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2ZW50LmNsaWVudFkgPj0gcmVjdC50b3AgJiYgZXZlbnQuY2xpZW50WSA8PSByZWN0LmJvdHRvbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIG1vdXNlIGlzIG91dHNpZGUgaG9zdCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdXNlSW5zaWRlSG9zdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0T25Nb3VzZUxlYXZlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb25IYW5kbGVNb3VzZVRvdWNoRG93bihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25Nb3VzZVRvdWNoRG93bkNvbnRpbnVlKGV2ZW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlTW91c2VUb3VjaERvd25BY3Rpb24oZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbkhhbmRsZU1vdXNlVG91Y2hEb3duQWN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93blNjcm9sbCA9IF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25TY3JvbGwgPSBpc05hTihtb3VzZURvd25TY3JvbGwpID8gMCA6IG1vdXNlRG93blNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1JUTCAmJiBpc0hvcml6b250YWwgJiYgIV9ydGxTY3JvbGxCZWhhdmlvci5uIHx8ICFfaXNSVEwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25TY3JvbGwgPSBtb3VzZURvd25TY3JvbGwgPCAwID8gMCA6IG1vdXNlRG93blNjcm9sbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bkludmVydGVkU2NhbGUgPSBnZXRIb3N0RWxlbWVudEludmVydGVkU2NhbGUoKVt4eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bk9mZnNldCA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MgPSAhZ2V0UHJlcGFyZWRTY3JvbGxiYXJzT3B0aW9uKHN0clNuYXBIYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfYm9keUVsZW1lbnQsIF9jbGFzc05hbWVEcmFnZ2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHNjcm9sbGJhclZhcnMuX2hhbmRsZSwgc3RyQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Moc2Nyb2xsYmFyVmFycy5fc2Nyb2xsYmFyLCBzdHJBY3RpdmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJNb3VzZVRvdWNoTW92ZUV2ZW50LCBfc3RyTW91c2VUb3VjaFVwRXZlbnQsIF9zdHJTZWxlY3RTdGFydEV2ZW50XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkb2N1bWVudERyYWdNb3ZlLCBkb2N1bWVudE1vdXNlVG91Y2hVcCwgZG9jdW1lbnRPblNlbGVjdFN0YXJ0XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX21zaWVWZXJzaW9uIHx8ICFfZG9jdW1lbnRNaXhlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkucHJ2RChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uVHJhY2tNb3VzZVRvdWNoRG93bihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25Nb3VzZVRvdWNoRG93bkNvbnRpbnVlKGV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbERpc3RhbmNlID0gTUFUSC5yb3VuZChfdmlld3BvcnRTaXplW3Njcm9sbGJhclZhcnMuX3dfaF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrT2Zmc2V0ID0gc2Nyb2xsYmFyVmFycy5fdHJhY2sub2Zmc2V0KClbc2Nyb2xsYmFyVmFycy5fbGVmdF90b3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0cmxLZXkgPSBldmVudC5jdHJsS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbnRTY3JvbGwgPSBldmVudC5zaGlmdEtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW50U2Nyb2xsVHJhbnNpdGlvbiA9IGluc3RhbnRTY3JvbGwgJiYgY3RybEtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0ZpcnN0SXRlcmF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlYXNpbmcgPSAnbGluZWFyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNyZWFzZVNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlZENvbmRpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxBY3Rpb25GaW5zaXNoZWQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoaXNIb3Jpem9udGFsLCB0cmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQWN0aW9uSW5zdGFudEZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFjdGlvbkZpbnNpc2hlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlTW91c2VUb3VjaERvd25BY3Rpb24oZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZU9mZnNldCA9IChtb3VzZURvd25PZmZzZXQgLSB0cmFja09mZnNldCkgKiBtb3VzZURvd25JbnZlcnRlZFNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlT2Zmc2V0ID0gc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrTGVuZ3RoID0gc2Nyb2xsYmFyVmFyc0luZm8uX3RyYWNrTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlTGVuZ3RoID0gc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFJhbmdlID0gc2Nyb2xsYmFyVmFyc0luZm8uX21heFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJTY3JvbGwgPSBzY3JvbGxiYXJWYXJzSW5mby5fY3VycmVudFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbER1cmF0aW9uID0gMjcwICogc2Nyb2xsRHVyYXRpb25GYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0RGVsYXkgPSBpc0ZpcnN0SXRlcmF0aW9uID8gTUFUSC5tYXgoNDAwLCBzY3JvbGxEdXJhdGlvbikgOiBzY3JvbGxEdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbnRTY3JvbGxQb3NpdGlvbiA9IHNjcm9sbFJhbmdlICogKChtb3VzZU9mZnNldCAtIChoYW5kbGVMZW5ndGggLyAyKSkgLyAodHJhY2tMZW5ndGggLSBoYW5kbGVMZW5ndGgpKTsgLy8gMTAwJSAqIHBvc2l0aW9uUGVyY2VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnRsSXNOb3JtYWwgPSBfaXNSVEwgJiYgaXNIb3Jpem9udGFsICYmICgoIV9ydGxTY3JvbGxCZWhhdmlvci5pICYmICFfcnRsU2Nyb2xsQmVoYXZpb3IubikgfHwgX25vcm1hbGl6ZVJUTENhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlYXNlU2Nyb2xsQ29uZGl0aW9uID0gcnRsSXNOb3JtYWwgPyBoYW5kbGVPZmZzZXQgPCBtb3VzZU9mZnNldCA6IGhhbmRsZU9mZnNldCA+IG1vdXNlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsT2JqID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25PYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IGVhc2luZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IGZ1bmN0aW9uIChub3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNIYW5kbGVzRGVmaW5lU2Nyb2xsUG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXShub3cpOyAvL2h0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2lzc3Vlcy80MzQwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoaXNIb3Jpem9udGFsLCBub3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudFNjcm9sbFBvc2l0aW9uID0gaXNGaW5pdGUoaW5zdGFudFNjcm9sbFBvc2l0aW9uKSA/IGluc3RhbnRTY3JvbGxQb3NpdGlvbiA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRTY3JvbGxQb3NpdGlvbiA9IF9pc1JUTCAmJiBpc0hvcml6b250YWwgJiYgIV9ydGxTY3JvbGxCZWhhdmlvci5pID8gKHNjcm9sbFJhbmdlIC0gaW5zdGFudFNjcm9sbFBvc2l0aW9uKSA6IGluc3RhbnRTY3JvbGxQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vX2Jhc2Uuc2Nyb2xsU3RvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbnRTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXShpbnN0YW50U2Nyb2xsUG9zaXRpb24pOyAvL3Njcm9sbCBpbnN0YW50bHkgdG8gbmV3IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFudFNjcm9sbFRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFmdGVyIGluc3RhbnQgc2Nyb2xsIChpbiBjYXNlIENTUyBTbmFwIFBvaW50cyBhcmUgdXNlZCkgdG8gZ2V0IHRoZSBjb3JyZWN0IHNuYXBwZWQgc2Nyb2xsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hbmQgdGhlIGFuaW1hdGlvbiBzdG9wcyBhdCB0aGUgY29ycmVjdCBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRTY3JvbGxQb3NpdGlvbiA9IF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsIGJhY2sgdG8gdGhlIHBvc2l0aW9uIGJlZm9yZSBpbnN0YW50IHNjcm9sbGluZyBzbyBhbmltYXRpb24gY2FuIGJlIHBlcmZvcm1lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXShjdXJyU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudFNjcm9sbFBvc2l0aW9uID0gcnRsSXNOb3JtYWwgJiYgX3J0bFNjcm9sbEJlaGF2aW9yLmkgPyAoc2Nyb2xsUmFuZ2UgLSBpbnN0YW50U2Nyb2xsUG9zaXRpb24pIDogaW5zdGFudFNjcm9sbFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRTY3JvbGxQb3NpdGlvbiA9IHJ0bElzTm9ybWFsICYmIF9ydGxTY3JvbGxCZWhhdmlvci5uID8gLWluc3RhbnRTY3JvbGxQb3NpdGlvbiA6IGluc3RhbnRTY3JvbGxQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsT2JqW3h5XSA9IGluc3RhbnRTY3JvbGxQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS5zY3JvbGwoc2Nyb2xsT2JqLCBleHRlbmREZWVwKGFuaW1hdGlvbk9iaiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTMwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogc2Nyb2xsQWN0aW9uSW5zdGFudEZpbmlzaGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFjdGlvbkluc3RhbnRGaW5pc2hlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVhc2VTY3JvbGwgPSBpc0ZpcnN0SXRlcmF0aW9uID8gZGVjcmVhc2VTY3JvbGxDb25kaXRpb24gOiBkZWNyZWFzZVNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkQ29uZGl0aW9uID0gcnRsSXNOb3JtYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChkZWNyZWFzZVNjcm9sbCA/IGhhbmRsZU9mZnNldCArIGhhbmRsZUxlbmd0aCA+PSBtb3VzZU9mZnNldCA6IGhhbmRsZU9mZnNldCA8PSBtb3VzZU9mZnNldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChkZWNyZWFzZVNjcm9sbCA/IGhhbmRsZU9mZnNldCA8PSBtb3VzZU9mZnNldCA6IGhhbmRsZU9mZnNldCArIGhhbmRsZUxlbmd0aCA+PSBtb3VzZU9mZnNldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkQ29uZGl0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRyYWNrVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2Uuc2Nyb2xsU3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVGltZW91dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBY3Rpb25GaW5zaXNoZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KHNjcm9sbEFjdGlvbiwgdGltZW91dERlbGF5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsT2JqW3h5XSA9IChkZWNyZWFzZVNjcm9sbCA/ICctPScgOiAnKz0nKSArIHNjcm9sbERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnNjcm9sbChzY3JvbGxPYmosIGV4dGVuZERlZXAoYW5pbWF0aW9uT2JqLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBzY3JvbGxEdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmlyc3RJdGVyYXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybEtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNyZWFzZVRyYWNrU2Nyb2xsQW1vdW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duSW52ZXJ0ZWRTY2FsZSA9IGdldEhvc3RFbGVtZW50SW52ZXJ0ZWRTY2FsZSgpW3h5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bk9mZnNldCA9IENPTVBBVElCSUxJVFkucGFnZShldmVudClbeHldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcyA9ICFnZXRQcmVwYXJlZFNjcm9sbGJhcnNPcHRpb24oc3RyU25hcEhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfYm9keUVsZW1lbnQsIF9jbGFzc05hbWVEcmFnZ2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhzY3JvbGxiYXJWYXJzLl90cmFjaywgc3RyQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhciwgc3RyQWN0aXZlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF9kb2N1bWVudEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJNb3VzZVRvdWNoVXBFdmVudCwgX3N0cktleURvd25FdmVudCwgX3N0cktleVVwRXZlbnQsIF9zdHJTZWxlY3RTdGFydEV2ZW50XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZG9jdW1lbnRNb3VzZVRvdWNoVXAsIGRvY3VtZW50S2V5RG93biwgZG9jdW1lbnRLZXlVcCwgZG9jdW1lbnRPblNlbGVjdFN0YXJ0XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvblRyYWNrTW91c2VUb3VjaEVudGVyKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIGJvdGggc2Nyb2xsYmFycyB3aWxsIHN0YXkgdmlzaWJsZSBpZiBvbmUgc2Nyb2xsYmFyIGlzIGhvdmVyZWQgaWYgYXV0b0hpZGUgaXMgXCJzY3JvbGxcIiBvciBcIm1vdmVcIi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNIYW5kbGVIb3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvblRyYWNrTW91c2VUb3VjaExlYXZlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzSGFuZGxlSG92ZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbCB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvblNjcm9sbGJhck1vdXNlVG91Y2hEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihzY3JvbGxiYXJWYXJzLl9oYW5kbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNb3VzZVRvdWNoRG93bkV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZU1vdXNlVG91Y2hEb3duKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihzY3JvbGxiYXJWYXJzLl90cmFjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJNb3VzZVRvdWNoRG93bkV2ZW50LCBfc3RyTW91c2VFbnRlciwgX3N0ck1vdXNlTGVhdmVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbb25UcmFja01vdXNlVG91Y2hEb3duLCBvblRyYWNrTW91c2VUb3VjaEVudGVyLCBvblRyYWNrTW91c2VUb3VjaExlYXZlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoc2Nyb2xsYmFyVmFycy5fc2Nyb2xsYmFyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTW91c2VUb3VjaERvd25FdmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TY3JvbGxiYXJNb3VzZVRvdWNoRG93bik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoc2Nyb2xsYmFyVmFycy5fc2Nyb2xsYmFyLCBfc3RyVHJhbnNpdGlvbkVuZEV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhclswXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlTGVuZ3RoKGlzSG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KGlzSG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNob3dzIG9yIGhpZGVzIHRoZSBnaXZlbiBzY3JvbGxiYXIgYW5kIGFwcGxpZWQgYSBjbGFzcyBuYW1lIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgc2Nyb2xsYmFyIGlzIHNjcm9sbGFibGUgb3Igbm90LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGlzSG9yaXpvbnRhbCBUcnVlIGlmIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhciBpcyB0aGUgdGFyZ2V0LCBmYWxzZSBpZiB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIGlzIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc2hhbGxCZVZpc2libGUgVHJ1ZSBpZiB0aGUgc2Nyb2xsYmFyIHNoYWxsIGJlIHNob3duLCBmYWxzZSBpZiBoaWRkZW4uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY2FuU2Nyb2xsIFRydWUgaWYgdGhlIHNjcm9sbGJhciBpcyBzY3JvbGxhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlZnJlc2hTY3JvbGxiYXJBcHBlYXJhbmNlKGlzSG9yaXpvbnRhbCwgc2hhbGxCZVZpc2libGUsIGNhblNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJIaWRkZW5DbGFzc05hbWUgPSBpc0hvcml6b250YWwgPyBfY2xhc3NOYW1lSG9zdFNjcm9sbGJhckhvcml6b250YWxIaWRkZW4gOiBfY2xhc3NOYW1lSG9zdFNjcm9sbGJhclZlcnRpY2FsSGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJFbGVtZW50ID0gaXNIb3Jpem9udGFsID8gX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50IDogX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBzY3JvbGxiYXJIaWRkZW5DbGFzc05hbWUsICFzaGFsbEJlVmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3Moc2Nyb2xsYmFyRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhclVudXNhYmxlLCAhY2FuU2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEF1dG9zaG93cyAvIGF1dG9oaWRlcyBib3RoIHNjcm9sbGJhcnMgd2l0aC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzaGFsbEJlVmlzaWJsZSBUcnVlIGlmIHRoZSBzY3JvbGxiYXJzIHNoYWxsIGJlIGF1dG9zaG93biAob25seSB0aGUgY2FzZSBpZiB0aGV5IGFyZSBoaWRkZW4gYnkgYSBhdXRvaGlkZSksIGZhbHNlIGlmIHRoZSBzaGFsbCBiZSBhdXRvIGhpZGRlbi5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZWxheWZyZWUgVHJ1ZSBpZiB0aGUgc2Nyb2xsYmFycyBzaGFsbCBiZSBoaWRkZW4gd2l0aG91dCBhIGRlbGF5LCBmYWxzZSBvciB1bmRlZmluZWQgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKHNoYWxsQmVWaXNpYmxlLCBkZWxheWZyZWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3Njcm9sbGJhcnNBdXRvSGlkZVRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYWxsQmVWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYoX2hhc092ZXJmbG93Q2FjaGUueCAmJiBfaGlkZU92ZXJmbG93Q2FjaGUueHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckF1dG9IaWRkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmKF9oYXNPdmVyZmxvd0NhY2hlLnkgJiYgX2hpZGVPdmVyZmxvd0NhY2hlLnlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW55QWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQWN0aXZlID0gJ2FjdGl2ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfc2Nyb2xsYmFyc0hhbmRsZUhvdmVyZWQgJiYgIV9kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnlBY3RpdmUgPSBfc2Nyb2xsYmFySG9yaXpvbnRhbEhhbmRsZUVsZW1lbnQuaGFzQ2xhc3Moc3RyQWN0aXZlKSB8fCBfc2Nyb2xsYmFyVmVydGljYWxIYW5kbGVFbGVtZW50Lmhhc0NsYXNzKHN0ckFjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbnlBY3RpdmUgJiYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbnlBY3RpdmUgJiYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckF1dG9IaWRkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZURlbGF5ID4gMCAmJiBkZWxheWZyZWUgIT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0F1dG9IaWRlVGltZW91dElkID0gc2V0VGltZW91dChoaWRlLCBfc2Nyb2xsYmFyc0F1dG9IaWRlRGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmcmVzaGVzIHRoZSBoYW5kbGUgbGVuZ3RoIG9mIHRoZSBnaXZlbiBzY3JvbGxiYXIuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaXNIb3Jpem9udGFsIFRydWUgaWYgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyIGhhbmRsZSBzaGFsbCBiZSByZWZyZXNoZWQsIGZhbHNlIGlmIHRoZSB2ZXJ0aWNhbCBvbmUgc2hhbGwgYmUgcmVmcmVzaGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWZyZXNoU2Nyb2xsYmFySGFuZGxlTGVuZ3RoKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaXNIb3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFyc0luZm8gPSBzY3JvbGxiYXJWYXJzLl9pbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWdpdCA9IDEwMDAwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgYW5kIGFwcGx5IGludGVuZGVkIGhhbmRsZSBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlUmF0aW8gPSBNQVRILm1pbigxLCAoX2hvc3RTaXplQ2FjaGVbc2Nyb2xsYmFyVmFycy5fd19oXSAtIChfcGFkZGluZ0Fic29sdXRlQ2FjaGUgPyAoaXNIb3Jpem9udGFsID8gX3BhZGRpbmdYIDogX3BhZGRpbmdZKSA6IDApKSAvIF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlW3Njcm9sbGJhclZhcnMuX3dfaF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNTU1tzY3JvbGxiYXJWYXJzLl93aWR0aF9oZWlnaHRdID0gKE1BVEguZmxvb3IoaGFuZGxlUmF0aW8gKiAxMDAgKiBkaWdpdCkgLyBkaWdpdCkgKyAnJSc7IC8vdGhlIGxhc3QgKiBkaWdpdCAvIGRpZ2l0IGlzIGZvciBmbG9vcmluZyB0byB0aGUgNHRoIGRpZ2l0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlT3ZlcmxheVNjcm9sbGJhcnNBcmVBY3RpdmUoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFycy5faGFuZGxlLmNzcyhoYW5kbGVDU1MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmUgdGhlIGhhbmRsZSBsZW5ndGggdG8gcmVzcGVjdCBtaW4gJiBtYXggbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZUxlbmd0aCA9IHNjcm9sbGJhclZhcnMuX2hhbmRsZVswXVsnb2Zmc2V0JyArIHNjcm9sbGJhclZhcnMuX1dpZHRoX0hlaWdodF07XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZUxlbmd0aFJhdGlvID0gaGFuZGxlUmF0aW87XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZyZXNoZXMgdGhlIGhhbmRsZSBvZmZzZXQgb2YgdGhlIGdpdmVuIHNjcm9sbGJhci5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpc0hvcml6b250YWwgVHJ1ZSBpZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaGFuZGxlIHNoYWxsIGJlIHJlZnJlc2hlZCwgZmFsc2UgaWYgdGhlIHZlcnRpY2FsIG9uZSBzaGFsbCBiZSByZWZyZXNoZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc2Nyb2xsT3JUcmFuc2l0aW9uIFRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGdpdmVuIHNjcm9sbGJhciBheGlzIHRvIHdoaWNoIHRoZSBoYW5kbGUgc2hhbGwgYmUgbW92ZWQgb3IgYSBib29sZWFuIHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIGEgdHJhbnNpdGlvbiBzaGFsbCBiZSBhcHBsaWVkLiBJZiB1bmRlZmluZWQgb3IgYm9vbGVhbiBpZiB0aGUgY3VycmVudCBzY3JvbGwtb2Zmc2V0IGlzIHRha2VuLiAoaWYgaXNIb3Jpem9udGFsID8gc2Nyb2xsTGVmdCA6IHNjcm9sbFRvcClcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChpc0hvcml6b250YWwsIHNjcm9sbE9yVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gdHlwZShzY3JvbGxPclRyYW5zaXRpb24pID09IFRZUEVTLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSVExpc0hvcml6b250YWwgPSBfaXNSVEwgJiYgaXNIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhpc0hvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzSW5mbyA9IHNjcm9sbGJhclZhcnMuX2luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clRyYW5zbGF0ZUJyYWNlID0gJ3RyYW5zbGF0ZSgnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJUcmFuc2Zvcm0gPSBWRU5ET1JTLl9jc3NQcm9wZXJ0eSgndHJhbnNmb3JtJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clRyYW5zaXRpb24gPSBWRU5ET1JTLl9jc3NQcm9wZXJ0eSgndHJhbnNpdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVTY3JvbGwgPSBpc0hvcml6b250YWwgPyBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XSgpIDogX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsVG9wXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2Nyb2xsID0gc2Nyb2xsT3JUcmFuc2l0aW9uID09PSB1bmRlZmluZWQgfHwgdHJhbnNpdGlvbiA/IG5hdGl2ZVNjcm9sbCA6IHNjcm9sbE9yVHJhbnNpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9tZWFzdXJlIHRoZSBoYW5kbGUgbGVuZ3RoIHRvIHJlc3BlY3QgbWluICYgbWF4IGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVMZW5ndGggPSBzY3JvbGxiYXJWYXJzSW5mby5faGFuZGxlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFja0xlbmd0aCA9IHNjcm9sbGJhclZhcnMuX3RyYWNrWzBdWydvZmZzZXQnICsgc2Nyb2xsYmFyVmFycy5fV2lkdGhfSGVpZ2h0XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlVHJhY2tEaWZmID0gdHJhY2tMZW5ndGggLSBoYW5kbGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUNTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1PZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0RPTlQgdXNlIHRoZSB2YXJpYWJsZSAnX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGVbc2Nyb2xsYmFyVmFycy5fd19oXScgaW5zdGVhZCBvZiAnX3ZpZXdwb3J0RWxlbWVudFswXVsnc2Nyb2xsJyArIHNjcm9sbGJhclZhcnMuX1dpZHRoX0hlaWdodF0nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYSBiaXQgYmVoaW5kIGR1cmluZyB0aGUgc21hbGwgZGVsYXkgd2hlbiBjb250ZW50IHNpemUgdXBkYXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vKGRlbGF5ID0gbXV0YXRpb25PYnNlcnZlckNvbnRlbnRMYWcsIGlmIGl0cyAwIHRoZW4gdGhpcyB2YXIgY291bGQgYmUgdXNlZClcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4U2Nyb2xsID0gKF92aWV3cG9ydEVsZW1lbnROYXRpdmVbX3N0clNjcm9sbCArIHNjcm9sbGJhclZhcnMuX1dpZHRoX0hlaWdodF0gLSBfdmlld3BvcnRFbGVtZW50TmF0aXZlWydjbGllbnQnICsgc2Nyb2xsYmFyVmFycy5fV2lkdGhfSGVpZ2h0XSkgKiAoX3J0bFNjcm9sbEJlaGF2aW9yLm4gJiYgaXNSVExpc0hvcml6b250YWwgPyAtMSA6IDEpOyAvLyogLTEgaWYgcnRsIHNjcm9sbCBtYXggaXMgbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0U2Nyb2xsUmF0aW8gPSBmdW5jdGlvbiAoYmFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNOYU4oYmFzZSAvIG1heFNjcm9sbCkgPyAwIDogTUFUSC5tYXgoMCwgTUFUSC5taW4oMSwgYmFzZSAvIG1heFNjcm9sbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldEhhbmRsZU9mZnNldCA9IGZ1bmN0aW9uIChzY3JvbGxSYXRpbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaGFuZGxlVHJhY2tEaWZmICogc2Nyb2xsUmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGlzTmFOKG9mZnNldCkgPyAwIDogb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAoaXNSVExpc0hvcml6b250YWwgJiYgIV9ydGxTY3JvbGxCZWhhdmlvci5pKSA/ICh0cmFja0xlbmd0aCAtIGhhbmRsZUxlbmd0aCAtIG9mZnNldCkgOiBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IE1BVEgubWF4KDAsIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsUmF0aW8gPSBnZXRTY3JvbGxSYXRpbyhuYXRpdmVTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bnNuYXBwZWRTY3JvbGxSYXRpbyA9IGdldFNjcm9sbFJhdGlvKGN1cnJlbnRTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVPZmZzZXQgPSBnZXRIYW5kbGVPZmZzZXQodW5zbmFwcGVkU2Nyb2xsUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwcGVkSGFuZGxlT2Zmc2V0ID0gZ2V0SGFuZGxlT2Zmc2V0KHNjcm9sbFJhdGlvKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX21heFNjcm9sbCA9IG1heFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzSW5mby5fY3VycmVudFNjcm9sbCA9IG5hdGl2ZVNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzSW5mby5fY3VycmVudFNjcm9sbFJhdGlvID0gc2Nyb2xsUmF0aW87XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PZmZzZXQgPSBpc1JUTGlzSG9yaXpvbnRhbCA/IC0odHJhY2tMZW5ndGggLSBoYW5kbGVMZW5ndGggLSBoYW5kbGVPZmZzZXQpIDogaGFuZGxlT2Zmc2V0OyAvL2luIHB4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJhbnNmb3JtT2Zmc2V0ID0gKHRyYW5zZm9ybU9mZnNldCAvIHRyYWNrTGVuZ3RoICogMTAwKSAqICh0cmFja0xlbmd0aCAvIGhhbmRsZUxlbmd0aCk7IC8vaW4gJVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVWYWx1ZSA9IGlzSG9yaXpvbnRhbCA/IHN0clRyYW5zbGF0ZUJyYWNlICsgdHJhbnNmb3JtT2Zmc2V0ICsgJ3B4LCAwKScgOiBzdHJUcmFuc2xhdGVCcmFjZSArICcwLCAnICsgdHJhbnNmb3JtT2Zmc2V0ICsgJ3B4KSc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVDU1Nbc3RyVHJhbnNmb3JtXSA9IHRyYW5zbGF0ZVZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBseSBvciBjbGVhciB1cCB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFRyYW5zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVDU1Nbc3RyVHJhbnNpdGlvbl0gPSB0cmFuc2l0aW9uICYmIE1BVEguYWJzKGhhbmRsZU9mZnNldCAtIHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVPZmZzZXQpID4gMSA/IGdldENTU1RyYW5zaXRpb25TdHJpbmcoc2Nyb2xsYmFyVmFycy5faGFuZGxlKSArICcsICcgKyAoc3RyVHJhbnNmb3JtICsgX3N0clNwYWNlICsgdHJhbnNpdGlvbkR1cmF0aW9uICsgJ21zJykgOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ1NTW3Njcm9sbGJhclZhcnMuX2xlZnRfdG9wXSA9IGhhbmRsZU9mZnNldDtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vb25seSBhcHBseSBjc3MgaWYgb2Zmc2V0IGhhcyBjaGFuZ2VkIGFuZCBvdmVyZmxvdyBleGlzdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVPdmVybGF5U2Nyb2xsYmFyc0FyZUFjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnMuX2hhbmRsZS5jc3MoaGFuZGxlQ1NTKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2xlYXIgdXAgdHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRUcmFuc2Zvcm0gJiYgX3N1cHBvcnRUcmFuc2l0aW9uICYmIHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnMuX2hhbmRsZS5vbmUoX3N0clRyYW5zaXRpb25FbmRFdmVudCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2Rlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFycy5faGFuZGxlLmNzcyhzdHJUcmFuc2l0aW9uLCBfc3RyRW1wdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVPZmZzZXQgPSBoYW5kbGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX3NuYXBwZWRIYW5kbGVPZmZzZXQgPSBzbmFwcGVkSGFuZGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnNJbmZvLl90cmFja0xlbmd0aCA9IHRyYWNrTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmcmVzaGVzIHRoZSBpbnRlcmFjdGl2aXR5IG9mIHRoZSBnaXZlbiBzY3JvbGxiYXIgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpc1RyYWNrIFRydWUgaWYgdGhlIHRyYWNrIGVsZW1lbnQgaXMgdGhlIHRhcmdldCwgZmFsc2UgaWYgdGhlIGhhbmRsZSBlbGVtZW50IGlzIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVHJ1ZSBmb3IgaW50ZXJhY3Rpdml0eSBmYWxzZSBmb3Igbm8gaW50ZXJhY3Rpdml0eS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFNjcm9sbGJhcnNJbnRlcmFjdGl2ZShpc1RyYWNrLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSB2YWx1ZSA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50MSA9IGlzVHJhY2sgPyBfc2Nyb2xsYmFySG9yaXpvbnRhbFRyYWNrRWxlbWVudCA6IF9zY3JvbGxiYXJIb3Jpem9udGFsSGFuZGxlRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudDIgPSBpc1RyYWNrID8gX3Njcm9sbGJhclZlcnRpY2FsVHJhY2tFbGVtZW50IDogX3Njcm9sbGJhclZlcnRpY2FsSGFuZGxlRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gaXNUcmFjayA/IF9jbGFzc05hbWVTY3JvbGxiYXJUcmFja09mZiA6IF9jbGFzc05hbWVTY3JvbGxiYXJIYW5kbGVPZmY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQxW2FjdGlvbl0oY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50MlthY3Rpb25dKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGEgb2JqZWN0IHdoaWNoIGlzIHVzZWQgZm9yIGZhc3QgYWNjZXNzIGZvciBzcGVjaWZpYyB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaXNIb3Jpem9udGFsIFRydWUgaWYgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyIHZhcnMgc2hhbGwgYmUgYWNjZXNzZWQsIGZhbHNlIGlmIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIgdmFycyBzaGFsbCBiZSBhY2Nlc3NlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7d2g6IHN0cmluZywgV0g6IHN0cmluZywgbHQ6IHN0cmluZywgX3doOiBzdHJpbmcsIF9sdDogc3RyaW5nLCB0OiAqLCBoOiAqLCBjOiB7fSwgczogKn19XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNjcm9sbGJhclZhcnMoaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3dpZHRoX2hlaWdodDogaXNIb3Jpem9udGFsID8gX3N0cldpZHRoIDogX3N0ckhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX1dpZHRoX0hlaWdodDogaXNIb3Jpem9udGFsID8gJ1dpZHRoJyA6ICdIZWlnaHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGVmdF90b3A6IGlzSG9yaXpvbnRhbCA/IF9zdHJMZWZ0IDogX3N0clRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX0xlZnRfVG9wOiBpc0hvcml6b250YWwgPyAnTGVmdCcgOiAnVG9wJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3hfeTogaXNIb3Jpem9udGFsID8gX3N0clggOiBfc3RyWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX1hfWTogaXNIb3Jpem9udGFsID8gJ1gnIDogJ1knLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfd19oOiBpc0hvcml6b250YWwgPyAndycgOiAnaCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sX3Q6IGlzSG9yaXpvbnRhbCA/ICdsJyA6ICd0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RyYWNrOiBpc0hvcml6b250YWwgPyBfc2Nyb2xsYmFySG9yaXpvbnRhbFRyYWNrRWxlbWVudCA6IF9zY3JvbGxiYXJWZXJ0aWNhbFRyYWNrRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hhbmRsZTogaXNIb3Jpem9udGFsID8gX3Njcm9sbGJhckhvcml6b250YWxIYW5kbGVFbGVtZW50IDogX3Njcm9sbGJhclZlcnRpY2FsSGFuZGxlRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcjogaXNIb3Jpem9udGFsID8gX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50IDogX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2luZm86IGlzSG9yaXpvbnRhbCA/IF9zY3JvbGxIb3Jpem9udGFsSW5mbyA6IF9zY3JvbGxWZXJ0aWNhbEluZm9cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gU2Nyb2xsYmFyIENvcm5lciA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEJ1aWxkcyBvciBkZXN0cm95cyB0aGUgc2Nyb2xsYmFyIGNvcm5lciBET00gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZXN0cm95IEluZGljYXRlcyB3aGV0aGVyIHRoZSBET00gc2hhbGwgYmUgYnVpbGQgb3IgZGVzdHJveWVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFNjcm9sbGJhckNvcm5lckRPTShkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhckNvcm5lckVsZW1lbnQgPSBfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCB8fCBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2RvbUV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50LmFwcGVuZChfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZG9tRXhpc3RzICYmIF9pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQucmVtb3ZlQXR0cihMRVhJQ09OLnMpLCBfY2xhc3NOYW1lc0R5bmFtaWNEZXN0cm95KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhbGwgc2Nyb2xsYmFyIGNvcm5lciBpbnRlcmFjdGl2aXR5IGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBTY3JvbGxiYXJDb3JuZXJFdmVudHMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc2lkZUlGcmFtZSA9IF93aW5kb3dFbGVtZW50TmF0aXZlLnRvcCAhPT0gX3dpbmRvd0VsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRG93blBvc2l0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRG93blNpemUgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VEb3duSW52ZXJ0ZWRTY2FsZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvbm5lY3RNdXRhdGlvbk9ic2VydmVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb2N1bWVudERyYWdNb3ZlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbk1vdXNlVG91Y2hEb3duQ29udGludWUoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGdldENvb3JkaW5hdGVzKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob3N0RWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXNpemVIb3Jpem9udGFsIHx8IF9yZXNpemVCb3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSAobW91c2VEb3duU2l6ZS53ICsgKHBhZ2VPZmZzZXQueCAtIG1vdXNlRG93blBvc2l0aW9uLngpICogbW91c2VEb3duSW52ZXJ0ZWRTY2FsZS54KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcmVzaXplVmVydGljYWwgfHwgX3Jlc2l6ZUJvdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdEVsZW1lbnRDU1NbX3N0ckhlaWdodF0gPSAobW91c2VEb3duU2l6ZS5oICsgKHBhZ2VPZmZzZXQueSAtIG1vdXNlRG93blBvc2l0aW9uLnkpICogbW91c2VEb3duSW52ZXJ0ZWRTY2FsZS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudC5jc3MoaG9zdEVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50TW91c2VUb3VjaFVwKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb2N1bWVudE1vdXNlVG91Y2hVcChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRJc1RydXN0ZWQgPSBldmVudCAhPT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJTZWxlY3RTdGFydEV2ZW50LCBfc3RyTW91c2VUb3VjaE1vdmVFdmVudCwgX3N0ck1vdXNlVG91Y2hVcEV2ZW50XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkb2N1bWVudE9uU2VsZWN0U3RhcnQsIGRvY3VtZW50RHJhZ01vdmUsIGRvY3VtZW50TW91c2VUb3VjaFVwXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2JvZHlFbGVtZW50LCBfY2xhc3NOYW1lRHJhZ2dpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQucmVsZWFzZUNhcHR1cmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudC5yZWxlYXNlQ2FwdHVyZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SXNUcnVzdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjb25uZWN0TXV0YXRpb25PYnNlcnZlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0TXV0YXRpb25PYnNlcnZlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZShfc3RyQXV0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb25uZWN0TXV0YXRpb25PYnNlcnZlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbk1vdXNlVG91Y2hEb3duQ29udGludWUoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNUb3VjaEV2ZW50ID0gb3JpZ2luYWxFdmVudC50b3VjaGVzICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2xlZXBpbmcgfHwgX2Rlc3Ryb3llZCA/IGZhbHNlIDogQ09NUEFUSUJJTElUWS5tQnRuKGV2ZW50KSA9PT0gMSB8fCBpc1RvdWNoRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfbXNpZVZlcnNpb24gJiYgaW5zaWRlSUZyYW1lID8geyB4OiBldmVudC5zY3JlZW5YLCB5OiBldmVudC5zY3JlZW5ZIH0gOiBDT01QQVRJQklMSVRZLnBhZ2UoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQsIF9zdHJNb3VzZVRvdWNoRG93bkV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uTW91c2VUb3VjaERvd25Db250aW51ZShldmVudCkgJiYgIV9yZXNpemVOb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb25uZWN0TXV0YXRpb25PYnNlcnZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duUG9zaXRpb24gPSBnZXRDb29yZGluYXRlcyhldmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duU2l6ZS53ID0gX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddIC0gKCFfaXNCb3JkZXJCb3ggPyBfcGFkZGluZ1ggOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93blNpemUuaCA9IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9IXSAtICghX2lzQm9yZGVyQm94ID8gX3BhZGRpbmdZIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25JbnZlcnRlZFNjYWxlID0gZ2V0SG9zdEVsZW1lbnRJbnZlcnRlZFNjYWxlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyU2VsZWN0U3RhcnRFdmVudCwgX3N0ck1vdXNlVG91Y2hNb3ZlRXZlbnQsIF9zdHJNb3VzZVRvdWNoVXBFdmVudF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RvY3VtZW50T25TZWxlY3RTdGFydCwgZG9jdW1lbnREcmFnTW92ZSwgZG9jdW1lbnRNb3VzZVRvdWNoVXBdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfYm9keUVsZW1lbnQsIF9jbGFzc05hbWVEcmFnZ2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQuc2V0Q2FwdHVyZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudC5zZXRDYXB0dXJlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5wcnZEKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFV0aWxzID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2FsbHMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIGdpdmVuIG5hbWUuIFRoZSBDb250ZXh0IG9mIHRoaXMgY2FsbGJhY2sgaXMgYWx3YXlzIF9iYXNlICh0aGlzKS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgd2hpY2ggc2hhbGwgYmUgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3Mgd2l0aCB3aGljaCB0aGUgY2FsbGJhY2sgc2hhbGwgYmUgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGRlcGVuZGVudCBCb29sZWFuIHdoaWNoIGRlY2lkZXMgd2hldGhlciB0aGUgY2FsbGJhY2sgc2hhbGwgYmUgZmlyZWQsIHVuZGVmaW5lZCBpcyBsaWtlIGEgXCJ0cnVlXCIgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRpc3BhdGNoQ2FsbGJhY2sobmFtZSwgYXJncywgZGVwZW5kZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVudCA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLmNhbGxiYWNrc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuc2lvbk9uTmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uT25OYW1lLnN1YnN0cigwLCAyKSA9PT0gJ29uJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbk9uTmFtZSA9IGV4dGVuc2lvbk9uTmFtZS5zdWJzdHIoMiwgMSkudG9Mb3dlckNhc2UoKSArIGV4dGVuc2lvbk9uTmFtZS5zdWJzdHIoMyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShjYWxsYmFjaykgPT0gVFlQRVMuZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoX2Jhc2UsIGFyZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChfZXh0ZW5zaW9ucywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKGV4dC5vbikgPT0gVFlQRVMuZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHQub24oZXh0ZW5zaW9uT25OYW1lLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFfZGVzdHJveWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2tzSW5pdFFldWV1ZS5wdXNoKHsgbjogbmFtZSwgYTogYXJncyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIFwidG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XCIgcHJvcGVydGllcywgd2l0aCBhIGdpdmVuIHByZWZpeCwgb2YgdGhlIGdpdmVuIGNzcyBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0Q1NTT2JqZWN0IFRoZSBjc3Mgb2JqZWN0IHRvIHdoaWNoIHRoZSB2YWx1ZXMgc2hhbGwgYmUgYXBwbGllZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBwcmVmaXggVGhlIHByZWZpeCBvZiB0aGUgXCJ0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcIiBjc3MgcHJvcGVydGllcy4gKGV4YW1wbGU6ICdwYWRkaW5nLScgaXMgYSB2YWxpZCBwcmVmaXgpXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWVzIEEgYXJyYXkgb2YgdmFsdWVzIHdoaWNoIHNoYWxsIGJlIGFwcGxpZWQgdG8gdGhlIFwidG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XCIgLXByb3BlcnRpZXMuIFRoZSBhcnJheSBvcmRlciBpcyBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5cclxuICAgICAgICAgICAgICAgICAqIElmIHRoaXMgYXJndW1lbnQgaXMgdW5kZWZpbmVkIHRoZSB2YWx1ZSAnJyAoZW1wdHkgc3RyaW5nKSB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFRvcFJpZ2h0Qm90dG9tTGVmdCh0YXJnZXRDU1NPYmplY3QsIHByZWZpeCwgdmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4IHx8IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwgW19zdHJFbXB0eSwgX3N0ckVtcHR5LCBfc3RyRW1wdHksIF9zdHJFbXB0eV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENTU09iamVjdFtwcmVmaXggKyBfc3RyVG9wXSA9IHZhbHVlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDU1NPYmplY3RbcHJlZml4ICsgX3N0clJpZ2h0XSA9IHZhbHVlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDU1NPYmplY3RbcHJlZml4ICsgX3N0ckJvdHRvbV0gPSB2YWx1ZXNbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q1NTT2JqZWN0W3ByZWZpeCArIF9zdHJMZWZ0XSA9IHZhbHVlc1szXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIFwidG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XCIgQ1NTIHByb3BlcnRpZXMgb2YgdGhlIENTUyBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBwcmVmaXggZnJvbSB0aGUgaG9zdCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHByZWZpeCBUaGUgcHJlZml4IG9mIHRoZSBcInRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFwiIGNzcyBwcm9wZXJ0aWVzLiAoZXhhbXBsZTogJ3BhZGRpbmctJyBpcyBhIHZhbGlkIHByZWZpeClcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzdWZmaXggVGhlIHN1ZmZpeCBvZiB0aGUgXCJ0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcIiBjc3MgcHJvcGVydGllcy4gKGV4YW1wbGU6ICdib3JkZXItJyBpcyBhIHZhbGlkIHByZWZpeCB3aXRoICctd2lkdGgnIGlzIGEgdmFsaWQgc3VmZml4KVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHplcm9YIFRydWUgaWYgdGhlIHggYXhpcyBzaGFsbCBiZSAwLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHplcm9ZIFRydWUgaWYgdGhlIHkgYXhpcyBzaGFsbCBiZSAwLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3t9fSBUaGUgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBudW1iZXJzIG9mIHRoZSByZWFkIENTUyBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRUb3BSaWdodEJvdHRvbUxlZnRIb3N0KHByZWZpeCwgc3VmZml4LCB6ZXJvWCwgemVyb1kpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSBzdWZmaXggfHwgX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeCB8fCBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdDogemVyb1kgPyAwIDogcGFyc2VUb1plcm9Pck51bWJlcihfaG9zdEVsZW1lbnQuY3NzKHByZWZpeCArIF9zdHJUb3AgKyBzdWZmaXgpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcjogemVyb1ggPyAwIDogcGFyc2VUb1plcm9Pck51bWJlcihfaG9zdEVsZW1lbnQuY3NzKHByZWZpeCArIF9zdHJSaWdodCArIHN1ZmZpeCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiOiB6ZXJvWSA/IDAgOiBwYXJzZVRvWmVyb09yTnVtYmVyKF9ob3N0RWxlbWVudC5jc3MocHJlZml4ICsgX3N0ckJvdHRvbSArIHN1ZmZpeCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsOiB6ZXJvWCA/IDAgOiBwYXJzZVRvWmVyb09yTnVtYmVyKF9ob3N0RWxlbWVudC5jc3MocHJlZml4ICsgX3N0ckxlZnQgKyBzdWZmaXgpKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCBDU1MgdHJhbnNpdGlvbiBzdHJpbmcgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdGhlIHRyYW5zaXRpb24gc3RyaW5nIHNoYWxsIGJlIHJldHVybmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIENTUyB0cmFuc2l0aW9uIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRDU1NUcmFuc2l0aW9uU3RyaW5nKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvblN0ciA9IFZFTkRPUlMuX2Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFzc2VtYmxlZFZhbHVlID0gZWxlbWVudC5jc3ModHJhbnNpdGlvblN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VtYmxlZFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXNzZW1ibGVkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ0V4cFN0cmluZyA9ICdcXFxccyooJyArICcoW14sKF0rKFxcXFwoLis/XFxcXCkpPykrJyArICcpW1xcXFxzLF0qJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnRXhwTWFpbiA9IG5ldyBSZWdFeHAocmVnRXhwU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnRXhwVmFsaWRhdGUgPSBuZXcgUmVnRXhwKCdeKCcgKyByZWdFeHBTdHJpbmcgKyAnKSskJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSAncHJvcGVydHkgZHVyYXRpb24gdGltaW5nLWZ1bmN0aW9uIGRlbGF5Jy5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyUmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZUFycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgajtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXRDc3NTdHlsZUJ5Q29tbWEgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0ci5tYXRjaChyZWdFeHBWYWxpZGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLm1hdGNoKHJlZ0V4cE1haW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJSZXN1bHQucHVzaChSZWdFeHAuJDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UocmVnRXhwTWFpbiwgX3N0ckVtcHR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0clJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgcHJvcGVydGllc1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVBcnJheSA9IHNwbGl0Q3NzU3R5bGVCeUNvbW1hKGVsZW1lbnQuY3NzKHRyYW5zaXRpb25TdHIgKyAnLScgKyBwcm9wZXJ0aWVzW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2YWx1ZUFycmF5W0xFWElDT04ubF07IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtqXSA9IChyZXN1bHRbal0gPyByZXN1bHRbal0gKyBfc3RyU3BhY2UgOiBfc3RyRW1wdHkpICsgdmFsdWVBcnJheVtqXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2VuZXJhdGVzIGEgUmVndWxhciBFeHByZXNzaW9uIHdoaWNoIG1hdGNoZXMgd2l0aCBhIHN0cmluZyB3aGljaCBzdGFydHMgd2l0aCAnb3MtaG9zdCcuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhDdXJyQ2xhc3NOYW1lT3B0aW9uIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gYWxzbyBtYXRjaGVzIGlmIHRoZSBzdHJpbmcgaXMgdGhlIGN1cnJlbnQgQ2xhc3NOYW1lIG9wdGlvbiAobXVsdGlwbGUgdmFsdWVzIHNwbGl0dGVkIGJ5IHNwYWNlIHBvc3NpYmxlKS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aE9sZENsYXNzTmFtZU9wdGlvbiBUaGUgUmVndWxhciBFeHByZXNzaW9uIGFsc28gbWF0Y2hlcyBpZiB0aGUgc3RyaW5nIGlzIHRoZSBvbGQgQ2xhc3NOYW1lIG9wdGlvbiAobXVsdGlwbGUgdmFsdWVzIHNwbGl0dGVkIGJ5IHNwYWNlIHBvc3NpYmxlKS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlSG9zdENsYXNzTmFtZVJlZ0V4cCh3aXRoQ3VyckNsYXNzTmFtZU9wdGlvbiwgd2l0aE9sZENsYXNzTmFtZU9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXBwZW5kaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwcGVuZENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NlcywgY29uZGl0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZGl4ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24gJiYgdHlwZW9mIGNsYXNzZXMgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSBjbGFzc2VzLnNwbGl0KF9zdHJTcGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BsaXRbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZGl4ICs9ICd8JyArIHNwbGl0W2ldICsgJyQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXRbaV0ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSBmb3IgZXNjYXBpbmcgcmVnZXggY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBlbmRpeDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyheJyArIF9jbGFzc05hbWVIb3N0RWxlbWVudCArICcoWy1fXS4rfCkkKScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRDbGFzc2VzKF9jbGFzc05hbWVDYWNoZSwgd2l0aEN1cnJDbGFzc05hbWVPcHRpb24pICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2xhc3Nlcyhfb2xkQ2xhc3NOYW1lLCB3aXRoT2xkQ2xhc3NOYW1lT3B0aW9uKSwgJ2cnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGhvc3QtZWxlbWVudHMgaW52ZXJ0ZWQgc2NhbGUuIChpbnZlcnRlZFNjYWxlID0gMSAvIHNjYWxlKVxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IFRoZSBzY2FsZSBvZiB0aGUgaG9zdC1lbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRIb3N0RWxlbWVudEludmVydGVkU2NhbGUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBfcGFkZGluZ0VsZW1lbnROYXRpdmVbTEVYSUNPTi5iQ1JdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogX3N1cHBvcnRUcmFuc2Zvcm0gPyAxIC8gKE1BVEgucm91bmQocmVjdC53aWR0aCkgLyBfcGFkZGluZ0VsZW1lbnROYXRpdmVbTEVYSUNPTi5vV10pIHx8IDEgOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBfc3VwcG9ydFRyYW5zZm9ybSA/IDEgLyAoTUFUSC5yb3VuZChyZWN0LmhlaWdodCkgLyBfcGFkZGluZ0VsZW1lbnROYXRpdmVbTEVYSUNPTi5vSF0pIHx8IDEgOiAxXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBIVE1MRWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvIFRoZSBvYmplY3Qgd2hpY2ggc2hhbGwgYmUgY2hlY2tlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBIVE1MRWxlbWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc0hUTUxFbGVtZW50KG8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyT3duZXJEb2N1bWVudCA9ICdvd25lckRvY3VtZW50JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RySFRNTEVsZW1lbnQgPSAnSFRNTEVsZW1lbnQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3bmQgPSBvICYmIG9bc3RyT3duZXJEb2N1bWVudF0gPyAob1tzdHJPd25lckRvY3VtZW50XS5wYXJlbnRXaW5kb3cgfHwgd2luZG93KSA6IHdpbmRvdztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygd25kW3N0ckhUTUxFbGVtZW50XSA9PSBUWVBFUy5vID8gbyBpbnN0YW5jZW9mIHduZFtzdHJIVE1MRWxlbWVudF0gOiAvL0RPTTJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gJiYgdHlwZW9mIG8gPT0gVFlQRVMubyAmJiBvICE9PSBudWxsICYmIG8ubm9kZVR5cGUgPT09IDEgJiYgdHlwZW9mIG8ubm9kZU5hbWUgPT0gVFlQRVMuc1xyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb21wYXJlcyAyIGFycmF5cyBhbmQgcmV0dXJucyB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGVtIGFzIGEgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gYTEgVGhlIGZpcnN0IGFycmF5IHdoaWNoIHNoYWxsIGJlIGNvbXBhcmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGEyIFRoZSBzZWNvbmQgYXJyYXkgd2hpY2ggc2hhbGwgYmUgY29tcGFyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gYXJyYXlzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRBcnJheURpZmZlcmVuY2VzKGExLCBhMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYTEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbYTFbaV1dID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYTIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbYTJbaV1dKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFbYTJbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2EyW2ldXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayBpbiBhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmLnB1c2goayk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmY7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIFplcm8gb3IgdGhlIG51bWJlciB0byB3aGljaCB0aGUgdmFsdWUgY2FuIGJlIHBhcnNlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggc2hhbGwgYmUgcGFyc2VkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHRvRmxvYXQgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG51bWJlciBzaGFsbCBiZSBwYXJzZWQgdG8gYSBmbG9hdC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VUb1plcm9Pck51bWJlcih2YWx1ZSwgdG9GbG9hdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSB0b0Zsb2F0ID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiBwYXJzZUludCh2YWx1ZSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc05hTihudW0pID8gMCA6IG51bTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgc2V2ZXJhbCBpbmZvcm1hdGlvbiBvZiB0aGUgdGV4dGFyZWEgYW5kIHJldHVybnMgdGhlbSBhcyBhIG9iamVjdCBvciB1bmRlZmluZWQgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGl0LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3tjdXJzb3JSb3c6IE51bWJlciwgY3Vyc29yQ29sLCByb3dzOiBOdW1iZXIsIGNvbHM6IG51bWJlciwgd1JvdzogbnVtYmVyLCBwb3M6IG51bWJlciwgbWF4IDogbnVtYmVyfX0gb3IgdW5kZWZpbmVkIGlmIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRleHRhcmVhSW5mbygpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JlYWQgbmVlZGVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUN1cnNvclBvc2l0aW9uID0gX3RhcmdldEVsZW1lbnROYXRpdmUuc2VsZWN0aW9uU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRhcmVhQ3Vyc29yUG9zaXRpb24gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFWYWx1ZSA9IF90YXJnZXRFbGVtZW50LnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUxlbmd0aCA9IHRleHRhcmVhVmFsdWVbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFSb3dTcGxpdCA9IHRleHRhcmVhVmFsdWUuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUxhc3RSb3cgPSB0ZXh0YXJlYVJvd1NwbGl0W0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhQ3VycmVudEN1cnNvclJvd1NwbGl0ID0gdGV4dGFyZWFWYWx1ZS5zdWJzdHIoMCwgdGV4dGFyZWFDdXJzb3JQb3NpdGlvbikuc3BsaXQoJ1xcbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWRlc3RSb3cgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUxhc3RDb2wgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JSb3cgPSB0ZXh0YXJlYUN1cnJlbnRDdXJzb3JSb3dTcGxpdFtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JDb2wgPSB0ZXh0YXJlYUN1cnJlbnRDdXJzb3JSb3dTcGxpdFt0ZXh0YXJlYUN1cnJlbnRDdXJzb3JSb3dTcGxpdFtMRVhJQ09OLmxdIC0gMV1bTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm93Q29scztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgd2lkZXN0IFJvdyBhbmQgdGhlIGxhc3QgY29sdW1uIG9mIHRoZSB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZXh0YXJlYVJvd1NwbGl0W0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb2xzID0gdGV4dGFyZWFSb3dTcGxpdFtpXVtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93Q29scyA+IHRleHRhcmVhTGFzdENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZXN0Um93ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYUxhc3RDb2wgPSByb3dDb2xzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3Vyc29yUm93OiBjdXJzb3JSb3csIC8vY3Vyc29yUm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJzb3JDb2x1bW46IGN1cnNvckNvbCwgLy9jdXJzb3JDb2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Jvd3M6IHRleHRhcmVhTGFzdFJvdywgLy9yb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb2x1bW5zOiB0ZXh0YXJlYUxhc3RDb2wsIC8vY29sc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfd2lkZXN0Um93OiB3aWRlc3RSb3csIC8vd1Jvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3Vyc29yUG9zaXRpb246IHRleHRhcmVhQ3Vyc29yUG9zaXRpb24sIC8vcG9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jdXJzb3JNYXg6IHRleHRhcmVhTGVuZ3RoIC8vbWF4XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBuYXRpdmUgb3ZlcmxheSBzY3JvbGxiYXJzIGFyZSBhY3RpdmUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBuYXRpdmUgb3ZlcmxheSBzY3JvbGxiYXJzIGFyZSBhY3RpdmUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbmF0aXZlT3ZlcmxheVNjcm9sbGJhcnNBcmVBY3RpdmUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NhY2hlICYmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGVsZW1lbnQgd2hpY2ggaXMgdXNlZCB0byBtZWFzdXJlIHRoZSBjb250ZW50IHNpemUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGV4dGFyZWFDb3ZlciBpZiB0YXJnZXQgZWxlbWVudCBpcyB0ZXh0YXJlYSBlbHNlIHRoZSBDb250ZW50RWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGVudE1lYXN1cmVFbGVtZW50KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaXNUZXh0YXJlYSA/IF90ZXh0YXJlYUNvdmVyRWxlbWVudFswXSA6IF9jb250ZW50RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdlbmVyYXRlcyBhIHN0cmluZyB3aGljaCByZXByZXNlbnRzIGEgSFRNTCBkaXYgd2l0aCB0aGUgZ2l2ZW4gY2xhc3NlcyBvciBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNsYXNzZXNPckF0dHJzIFRoZSBjbGFzcyBvZiB0aGUgZGl2IGFzIHN0cmluZyBvciBhIG9iamVjdCB3aGljaCByZXByZXNlbnRzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBkaXYuIChUaGUgY2xhc3MgYXR0cmlidXRlIGNhbiBhbHNvIGJlIHdyaXR0ZW4gYXMgXCJjbGFzc05hbWVcIi4pXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgY29udGVudCBvZiB0aGUgZGl2IGFzIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb25jYXRlZCBzdHJpbmcgd2hpY2ggcmVwcmVzZW50cyBhIEhUTUwgZGl2IGFuZCBpdHMgY29udGVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVEaXYoY2xhc3Nlc09yQXR0cnMsIGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgJyArIChjbGFzc2VzT3JBdHRycyA/IHR5cGUoY2xhc3Nlc09yQXR0cnMpID09IFRZUEVTLnMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3M9XCInICsgY2xhc3Nlc09yQXR0cnMgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRlJBTUVXT1JLLmlzUGxhaW5PYmplY3QoY2xhc3Nlc09yQXR0cnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gY2xhc3Nlc09yQXR0cnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzICs9IChrZXkgPT09ICdjJyA/ICdjbGFzcycgOiBrZXkpICsgJz1cIicgKyBjbGFzc2VzT3JBdHRyc1trZXldICsgJ1wiICc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyRW1wdHkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnQgfHwgX3N0ckVtcHR5KSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2VsZWN0cyBvciBnZW5lcmF0ZXMgYSBkaXYgd2l0aCB0aGUgZ2l2ZW4gY2xhc3MgYXR0cmlidXRlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZXMgKGRpdmlkZWQgYnkgc3BhY2VzKSBvZiB0aGUgZGl2IHdoaWNoIHNoYWxsIGJlIHNlbGVjdGVkIG9yIGdlbmVyYXRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzZWxlY3RQYXJlbnRPck9ubHlDaGlsZHJlbiBUaGUgcGFyZW50IGVsZW1lbnQgZnJvbSB3aGljaCBvZiB0aGUgZWxlbWVudCBzaGFsbCBiZSBzZWxlY3RlZC4gKGlmIHVuZGVmaW5lZCBvciBib29sZWFuIGl0cyBob3N0RWxlbWVudClcclxuICAgICAgICAgICAgICAgICAqIElmIGl0cyBhIGJvb2xlYW4gaXQgZGVjaWRlcyB3aGV0aGVyIG9ubHkgdGhlIGNoaWxkcmVuIG9mIHRoZSBob3N0IGVsZW1lbnQgc2hhbGwgYmUgc2VsZWN0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIGdlbmVyYXRlZCBvciBzZWxlY3RlZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhjbGFzc05hbWUsIHNlbGVjdFBhcmVudE9yT25seUNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9ubHlDaGlsZHJlbiA9IHR5cGUoc2VsZWN0UGFyZW50T3JPbmx5Q2hpbGRyZW4pID09IFRZUEVTLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdFBhcmVudCA9IG9ubHlDaGlsZHJlbiA/IF9ob3N0RWxlbWVudCA6IChzZWxlY3RQYXJlbnRPck9ubHlDaGlsZHJlbiB8fCBfaG9zdEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9kb21FeGlzdHMgJiYgIXNlbGVjdFBhcmVudFtMRVhJQ09OLmxdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfZG9tRXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdFBhcmVudFtvbmx5Q2hpbGRyZW4gPyAnY2hpbGRyZW4nIDogJ2ZpbmQnXShfc3RyRG90ICsgY2xhc3NOYW1lLnJlcGxhY2UoL1xccy9nLCBfc3RyRG90KSkuZXEoMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogRlJBTUVXT1JLKGdlbmVyYXRlRGl2KGNsYXNzTmFtZSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdGhlIHByb3BlcnR5IHZhbHVlIHNoYWxsIGJlIGdvdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwcm9wZXJ0eSBvZiB3aGljaCB0aGUgdmFsdWUgc2hhbGwgYmUgZ290LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzZWFyY2hlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWQgb2YgdGhlIHByb3BlcnR5IHdhc24ndCBmb3VuZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0T2JqZWN0UHJvcFZhbChvYmosIHBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXRzID0gcGF0aC5zcGxpdChfc3RyRG90KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHNwbGl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ialtMRVhJQ09OLmhPUF0oc3BsaXRzW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gb2JqW3NwbGl0c1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgc3BsaXRzLmxlbmd0aCAmJiB0eXBlKHZhbCkgPT0gVFlQRVMubylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBwcm9wZXJ0eSBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgZnJvbSB3aGljaCB0aGUgcHJvcGVydHkgdmFsdWUgc2hhbGwgYmUgc2V0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHBhdGggVGhlIHByb3BlcnR5IG9mIHdoaWNoIHRoZSB2YWx1ZSBzaGFsbCBiZSBzZXQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2hpY2ggc2hhbGwgYmUgc2V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRPYmplY3RQcm9wVmFsKG9iaiwgcGF0aCwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0cyA9IHBhdGguc3BsaXQoX3N0ckRvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0c0xlbmd0aCA9IHNwbGl0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRlbmRPYmogPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kT2JqUm9vdCA9IGV4dGVuZE9iajtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHNwbGl0c0xlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRPYmogPSBleHRlbmRPYmpbc3BsaXRzW2ldXSA9IGkgKyAxIDwgc3BsaXRzTGVuZ3RoID8ge30gOiB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLmV4dGVuZChvYmosIGV4dGVuZE9ialJvb3QsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlx0XHJcbiAgICAgICAgICAgICAgICAgKiBSdW5zIGEgYWN0aW9uIGZvciBlYWNoIHNlbGVjdG9yIGluc2lkZSB0aGUgdXBkYXRlT25Mb2FkIG9wdGlvbi5cdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIFRoZSBhY3Rpb24gZm9yIGVhY2ggdXBkYXRlT25Mb2FkIHNlbGVjdG9yLCB0aGUgYXJndW1lbnRzIHRoZSBmdW5jdGlvbiB0YWtlcyBpcyB0aGUgaW5kZXggYW5kIHRoZSB2YWx1ZSAodGhlIHNlbGVjdG9yKS5cdFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlYWNoVXBkYXRlT25Mb2FkKGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVPbkxvYWQgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy51cGRhdGVPbkxvYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlT25Mb2FkID0gdHlwZSh1cGRhdGVPbkxvYWQpID09IFRZUEVTLnMgPyB1cGRhdGVPbkxvYWQuc3BsaXQoX3N0clNwYWNlKSA6IHVwZGF0ZU9uTG9hZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaXNBKHVwZGF0ZU9uTG9hZCkgJiYgIV9kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCh1cGRhdGVPbkxvYWQsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gVXRpbHMgQ2FjaGUgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIG9yIG9iamVjdHMgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGV5IGFyZW4ndCBlcXVhbC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjdXJyZW50IFRoZSBmaXJzdCB2YWx1ZSBvciBvYmplY3Qgd2hpY2ggc2hhbGwgYmUgY29tcGFyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY2FjaGUgVGhlIHNlY29uZCB2YWx1ZSBvciBvYmplY3Qgd2hpY2ggc2hhbGwgYmUgY29tcGFyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZm9yY2UgSWYgdHJ1ZSB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgYWx3YXlzIHRydWUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBib3RoIHZhbHVlcyBvciBvYmplY3RzIGFyZW4ndCBlcXVhbCBvciBmb3JjZSBpcyB0cnVlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrQ2FjaGUoY3VycmVudCwgY2FjaGUsIGZvcmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9yY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUoY3VycmVudCkgPT0gVFlQRVMubyAmJiB0eXBlKGNhY2hlKSA9PSBUWVBFUy5vKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgIT09ICdjJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50W0xFWElDT04uaE9QXShwcm9wKSAmJiBjYWNoZVtMRVhJQ09OLmhPUF0ocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrQ2FjaGUoY3VycmVudFtwcm9wXSwgY2FjaGVbcHJvcF0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50ICE9PSBjYWNoZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gU2hvcnRjdXRzID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogalF1ZXJ5IGV4dGVuZCBtZXRob2Qgc2hvcnRjdXQgd2l0aCBhIGFwcGVuZGVkIFwidHJ1ZVwiIGFzIGZpcnN0IGFyZ3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBleHRlbmREZWVwKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGUkFNRVdPUksuZXh0ZW5kLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBqUXVlcnkgYWRkQ2xhc3MgbWV0aG9kIHNob3J0Y3V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xhc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWV3b3JrUHJvdG8uYWRkQ2xhc3MuY2FsbChlbCwgY2xhc3Nlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBqUXVlcnkgcmVtb3ZlQ2xhc3MgbWV0aG9kIHNob3J0Y3V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xhc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWV3b3JrUHJvdG8ucmVtb3ZlQ2xhc3MuY2FsbChlbCwgY2xhc3Nlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIG9yIHJlbW92ZXMgdGhlIGdpdmVuIGNsYXNzZXMgZGVwZW5kZW50IG9uIHRoZSBib29sZWFuIHZhbHVlLiBUcnVlIGZvciBhZGQsIGZhbHNlIGZvciByZW1vdmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFJlbW92ZUNsYXNzKGVsLCBjbGFzc2VzLCBkb0FkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb0FkZCA/IGFkZENsYXNzKGVsLCBjbGFzc2VzKSA6IHJlbW92ZUNsYXNzKGVsLCBjbGFzc2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIGpRdWVyeSByZW1vdmUgbWV0aG9kIHNob3J0Y3V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1ld29ya1Byb3RvLnJlbW92ZS5jYWxsKGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpbmRzIHRoZSBmaXJzdCBjaGlsZCBlbGVtZW50IHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGVsIFRoZSByb290IGVsZW1lbnQgZnJvbSB3aGljaCB0aGUgc2VsZWN0b3Igc2hhbGwgYmUgdmFsaWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIG9mIHRoZSBzZWFyY2hlZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFRoZSBmaXJzdCBlbGVtZW50IHdoaWNoIGlzIGEgY2hpbGQgb2YgdGhlIGdpdmVuIGVsZW1lbnQgYW5kIG1hdGNoZXMgdGhlIGdpdmVucyBzZWxlY3Rvci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmluZEZpcnN0KGVsLCBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWV3b3JrUHJvdG8uZmluZC5jYWxsKGVsLCBzZWxlY3RvcikuZXEoMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBBUEkgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBQdXRzIHRoZSBpbnN0YW5jZSB0byBzbGVlcC4gSXQgd29udCByZXNwb25kIHRvIGFueSBjaGFuZ2VzIGluIHRoZSBET00gYW5kIHdvbid0IHVwZGF0ZS4gU2Nyb2xsYmFyIEludGVyYWN0aXZpdHkgaXMgYWxzbyBkaXNhYmxlZCBhcyB3ZWxsIGFzIHRoZSByZXNpemUgaGFuZGxlLlxyXG4gICAgICAgICAgICAgICAgICogVGhpcyBiZWhhdmlvciBjYW4gYmUgcmVzZXQgYnkgY2FsbGluZyB0aGUgdXBkYXRlIG1ldGhvZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2Uuc2xlZXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NsZWVwaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVcGRhdGVzIHRoZSBwbHVnaW4gYW5kIERPTSB0byB0aGUgY3VycmVudCBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIGEgdXBkYXRlIGlzIDEwMCUgcmVxdWlyZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZm9yY2UgVHJ1ZSBpZiBldmVyeSBwcm9wZXJ0eSBzaGFsbCBiZSB1cGRhdGVkIGFuZCB0aGUgY2FjaGUgc2hhbGwgYmUgaWdub3JlZC5cclxuICAgICAgICAgICAgICAgICAqICFJTlRFUk5BTCBVU0FHRSEgOiBmb3JjZSBjYW4gYmUgYSBzdHJpbmcgXCJhdXRvXCIsIFwic3luY1wiIG9yIFwiem9vbVwiIHRvb1xyXG4gICAgICAgICAgICAgICAgICogaWYgXCJhdXRvXCIgdGhlbiBiZWZvcmUgYSByZWFsIHVwZGF0ZSB0aGUgY29udGVudCBzaXplIGFuZCBob3N0IGVsZW1lbnQgYXR0cmlidXRlcyBnZXRzIGNoZWNrZWQsIGFuZCBpZiB0aGV5IGNoYW5nZWQgb25seSB0aGVuIHRoZSB1cGRhdGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkLlxyXG4gICAgICAgICAgICAgICAgICogaWYgXCJzeW5jXCIgdGhlbiB0aGUgYXN5bmMgdXBkYXRlIHByb2Nlc3MgKE11dGF0aW9uT2JzZXJ2ZXIgb3IgVXBkYXRlTG9vcCkgZ2V0cyBzeW5jaHJvbml6ZWQgYW5kIGEgY29ycmVzcG9uZGluZyB1cGRhdGUgdGFrZXMgcGxhY2UgaWYgb25lIHdhcyBuZWVkZWQgZHVlIHRvIHBlbmRpbmcgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqIGlmIFwiem9vbVwiIHRoZW4gYSB1cGRhdGUgdGFrZXMgcGxhY2Ugd2hlcmUgaXQncyBhc3N1bWVkIHRoYXQgY29udGVudCBhbmQgaG9zdCBzaXplIGNoYW5nZWRcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gXHJcbiAgICAgICAgICAgICAgICAgKiBJZiBmb3JjZSBpcyBcInN5bmNcIiB0aGVuIGEgYm9vbGVhbiBpcyByZXR1cm5lZCB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciBhIHVwZGF0ZSB3YXMgbmVlZGVkIGR1ZSB0byBwZW5kaW5nIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBJZiBmb3JjZSBpcyBcImF1dG9cIiB0aGVuIGEgYm9vbGVhbiBpcyByZXR1cm5lZCB3aGV0aGVyIGEgdXBkYXRlIHdhcyBuZWVkZWQgZHVlIHRvIGF0dHJpYnV0ZSBvciBzaXplIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAgKiB1bmRlZmluZWQgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS51cGRhdGUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2Rlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnNDaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50U2l6ZUM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZShmb3JjZSkgPT0gVFlQRVMucztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9VcGRhdGVBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtdXRIb3N0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtdXRDb250ZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlID09PSBfc3RyQXV0bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNDaGFuZ2VkID0gbWVhbmluZ2Z1bEF0dHJzQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFNpemVDID0gdXBkYXRlQXV0b0NvbnRlbnRTaXplQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9VcGRhdGVBdXRvID0gYXR0cnNDaGFuZ2VkIHx8IGNvbnRlbnRTaXplQztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1VwZGF0ZUF1dG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudFNpemVDaGFuZ2VkOiBjb250ZW50U2l6ZUMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jaGFuZ2VkT3B0aW9uczogX2luaXRpYWxpemVkID8gdW5kZWZpbmVkIDogX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JjZSA9PT0gX3N0clN5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRIb3N0ID0gX211dGF0aW9uT2JzZXJ2ZXJIb3N0Q2FsbGJhY2soX211dGF0aW9uT2JzZXJ2ZXJIb3N0LnRha2VSZWNvcmRzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dENvbnRlbnQgPSBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnRDYWxsYmFjayhfbXV0YXRpb25PYnNlcnZlckNvbnRlbnQudGFrZVJlY29yZHMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRIb3N0ID0gX2Jhc2UudXBkYXRlKF9zdHJBdXRvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JjZSA9PT0gJ3pvb20nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0U2l6ZUNoYW5nZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRTaXplQ2hhbmdlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlID0gX3NsZWVwaW5nIHx8IGZvcmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2xlZXBpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfYmFzZS51cGRhdGUoX3N0clN5bmMpIHx8IGZvcmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHsgX2ZvcmNlOiBmb3JjZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUVsZW1lbnRzT25Mb2FkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb1VwZGF0ZUF1dG8gfHwgbXV0SG9zdCB8fCBtdXRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgb3B0aW9ucy4gVGhlIHVwZGF0ZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSBpZiBuZXcgb3B0aW9ucyB3ZXJlIHNldC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuZXdPcHRpb25zIElmIG5ldyBvcHRpb25zIGFyZSBnaXZlbiwgdGhlbiB0aGUgbmV3IG9wdGlvbnMgd2lsbCBiZSBzZXQsIGlmIG5ldyBvcHRpb25zIGFyZW4ndCBnaXZlbiAodW5kZWZpbmVkIG9yIGEgbm90IGEgcGxhaW4gb2JqZWN0KSB0aGVuIHRoZSBjdXJyZW50IG9wdGlvbnMgd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZSBJZiBuZXcgb3B0aW9ucyBpcyBhIHByb3BlcnR5IHBhdGggc3RyaW5nLCB0aGVuIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkIHRvIHNldCB0aGUgb3B0aW9uIHRvIHdoaWNoIHRoZSBwcm9wZXJ0eSBwYXRoIHN0cmluZyBsZWFkcy5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5vcHRpb25zID0gZnVuY3Rpb24gKG5ld09wdGlvbnMsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkT3BzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBjdXJyZW50IG9wdGlvbnMgaWYgbmV3T3B0aW9ucyBhcmUgdW5kZWZpbmVkIG9yIGVtcHR5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZSQU1FV09SSy5pc0VtcHR5T2JqZWN0KG5ld09wdGlvbnMpIHx8ICFGUkFNRVdPUksuaXNQbGFpbk9iamVjdChuZXdPcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShuZXdPcHRpb25zKSA9PSBUWVBFUy5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRPYmplY3RQcm9wVmFsKG9wdGlvbiwgbmV3T3B0aW9ucywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRPcHMgPSBzZXRPcHRpb25zKG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE9iamVjdFByb3BWYWwoX2N1cnJlbnRPcHRpb25zLCBuZXdPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2N1cnJlbnRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZE9wcyA9IHNldE9wdGlvbnMobmV3T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUZSQU1FV09SSy5pc0VtcHR5T2JqZWN0KGNoYW5nZWRPcHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSh7IF9jaGFuZ2VkT3B0aW9uczogY2hhbmdlZE9wcyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVzdG9yZSB0aGUgRE9NLCBkaXNjb25uZWN0cyBhbGwgb2JzZXJ2ZXJzLCByZW1vdmUgYWxsIHJlc2l6ZSBvYnNlcnZlcnMgYW5kIHB1dCB0aGUgaW5zdGFuY2UgdG8gc2xlZXAuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhpcyBpbnN0YW5jZSBmcm9tIGF1dG8gdXBkYXRlIGxvb3BcclxuICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlTG9vcC5yZW1vdmUoX2Jhc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2Rpc2Nvbm5lY3QgYWxsIG11dGF0aW9uIG9ic2VydmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RNdXRhdGlvbk9ic2VydmVycygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgcmVzaXplIG9ic2VydmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzaXplT2JzZXJ2ZXIoX3NpemVPYnNlcnZlckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzaXplT2JzZXJ2ZXIoX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYWxsIGV4dGVuc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBleHROYW1lIGluIF9leHRlbnNpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS5yZW1vdmVFeHQoZXh0TmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCAnZGVzdHJveScgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKF9kZXN0cm95RXZlbnRzW0xFWElDT04ubF0gPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGVzdHJveUV2ZW50cy5wb3AoKSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgZXZlbnRzIGZyb20gaG9zdCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBIb3N0TW91c2VUb3VjaEV2ZW50cyh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYWxsIGhlbHBlciAvIGRldGVjdGlvbiBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfY29udGVudEdsdWVFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoX2NvbnRlbnRHbHVlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250ZW50QXJyYW5nZUVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfY29udGVudEFycmFuZ2VFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKF9zaXplQXV0b09ic2VydmVyRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCBnZW5lcmF0ZWQgRE9NXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTY3JvbGxiYXJzRE9NKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyQ29ybmVyRE9NKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU3RydWN0dXJlRE9NKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgZ2VuZXJhdGVkIGltYWdlIGxvYWQgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdXBkYXRlT25Mb2FkRWxtc1tMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSyhfdXBkYXRlT25Mb2FkRWxtc1tpXSkub2ZmKF91cGRhdGVPbkxvYWRFdmVudE5hbWUsIHVwZGF0ZU9uTG9hZENhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICBfdXBkYXRlT25Mb2FkRWxtcyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2Rlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NsZWVwaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhpcyBpbnN0YW5jZSBmcm9tIHRoZSBpbnN0YW5jZXMgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIElOU1RBTkNFUyhwbHVnaW5UYXJnZXRFbGVtZW50LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbkRlc3Ryb3llZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgcHJvcGVydGllcyBhbmQgbWV0aG9kc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZm9yICh2YXIgcHJvcGVydHkgaW4gX2Jhc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgZGVsZXRlIF9iYXNlW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgICAgICAvL19iYXNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNjcm9sbHMgdG8gYSBnaXZlbiBwb3NpdGlvbiBvciBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgICAgICAgKiAxLiBDYW4gYmUgXCJjb29yZGluYXRlc1wiIHdoaWNoIGxvb2tzIGxpa2U6XHJcbiAgICAgICAgICAgICAgICAgKiAgICB7IHggOiA/LCB5IDogPyB9IE9SICAgICAgICAgIE9iamVjdCB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICogICAgeyBsZWZ0IDogPywgdG9wIDogPyB9IE9SICAgICBPYmplY3Qgd2l0aCBsZWZ0IGFuZCB0b3AgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICogICAgeyBsIDogPywgdCA6ID8gfSBPUiAgICAgICAgICBPYmplY3Qgd2l0aCBsIGFuZCB0IHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAqICAgIFsgPywgPyBdIE9SICAgICAgICAgICAgICAgICAgQXJyYXkgd2hlcmUgdGhlIGZpcnN0IHR3byBlbGVtZW50IGFyZSB0aGUgY29vcmRpbmF0ZXMgKGZpcnN0IGlzIHgsIHNlY29uZCBpcyB5KVxyXG4gICAgICAgICAgICAgICAgICogICAgPyAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHNpbmdsZSB2YWx1ZSB3aGljaCBzdGF5cyBmb3IgYm90aCBheGlzXHJcbiAgICAgICAgICAgICAgICAgKiAgICBBIHZhbHVlIGNhbiBiZSBhIG51bWJlciwgYSBzdHJpbmcgb3IgYSBjYWxjdWxhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgICBPcGVyYXRvcnM6XHJcbiAgICAgICAgICAgICAgICAgKiAgICBbTk9ORV0gIFRoZSBjdXJyZW50IHNjcm9sbCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqICAgICcrPScgICAgVGhlIHZhbHVlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgc2Nyb2xsIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICogICAgJy09JyAgICBUaGUgdmFsdWUgd2lsbCBiZSBzdWJ0cmFjdGVkIGZyb20gdGhlIGN1cnJlbnQgc2Nyb2xsIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICogICAgJyo9JyAgICBUaGUgY3VycmVudCBzY3JvbGwgd2lsIGJlIG11bHRpcGxpY2F0ZWQgYnkgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICogICAgJy89JyAgICBUaGUgY3VycmVudCBzY3JvbGwgd2lsIGJlIGRpdmlkZWQgYnkgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICAgIFVuaXRzOlxyXG4gICAgICAgICAgICAgICAgICogICAgW05PTkVdICBUaGUgdmFsdWUgaXMgdGhlIGZpbmFsIHNjcm9sbCBhbW91bnQuICAgICAgICAgICAgICAgICAgIGZpbmFsID0gKHZhbHVlICogMSlcclxuICAgICAgICAgICAgICAgICAqICAgICdweCcgICAgU2FtZSBhcyBub25lXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnJScgICAgIFRoZSB2YWx1ZSBpcyBkZXBlbmRlbnQgb24gdGhlIGN1cnJlbnQgc2Nyb2xsIHZhbHVlLiAgICAgZmluYWwgPSAoKGN1cnJlbnRTY3JvbGxWYWx1ZSAvIDEwMCkgKiB2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAqICAgICd2dycgICAgVGhlIHZhbHVlIGlzIG11bHRpcGxpY2F0ZWQgYnkgdGhlIHZpZXdwb3J0IHdpZHRoLiAgICAgICBmaW5hbCA9ICh2YWx1ZSAqIHZpZXdwb3J0V2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgKiAgICAndmgnICAgIFRoZSB2YWx1ZSBpcyBtdWx0aXBsaWNhdGVkIGJ5IHRoZSB2aWV3cG9ydCBoZWlnaHQuICAgICAgZmluYWwgPSAodmFsdWUgKiB2aWV3cG9ydEhlaWdodClcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgICBleGFtcGxlIGZpbmFsIHZhbHVlczpcclxuICAgICAgICAgICAgICAgICAqICAgIDIwMCwgJzIwMHB4JywgJzUwJScsICcxdncnLCAnMXZoJywgJys9MjAwJywgJy89MXZ3JywgJyo9MnB4JywgJy09NXZoJywgJys9MzMlJywgJys9IDUwJSAtIDJweCcsICctPSAxdncgLSA1MCUnXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogMi4gQ2FuIGJlIGEgSFRNTCBvciBqUXVlcnkgZWxlbWVudDpcclxuICAgICAgICAgICAgICAgICAqICAgIFRoZSBmaW5hbCBzY3JvbGwgb2Zmc2V0IGlzIHRoZSBvZmZzZXQgKHdpdGhvdXQgbWFyZ2luKSBvZiB0aGUgZ2l2ZW4gSFRNTCAvIGpRdWVyeSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIDMuIENhbiBiZSBhIG9iamVjdCB3aXRoIGEgSFRNTCBvciBqUXVlcnkgZWxlbWVudCB3aXRoIGFkZGl0aW9uYWwgc2V0dGluZ3M6XHJcbiAgICAgICAgICAgICAgICAgKiAgICB7XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIGVsIDogW0hUTUxFbGVtZW50LCBqUXVlcnkgZWxlbWVudF0sICAgICAgICAgICAgIE1VU1QgYmUgc3BlY2lmaWVkLCBlbHNlIHRoaXMgb2JqZWN0IGlzbid0IHZhbGlkLlxyXG4gICAgICAgICAgICAgICAgICogICAgICBzY3JvbGwgOiBbc3RyaW5nLCBhcnJheSwgb2JqZWN0XSwgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzICdhbHdheXMnLlxyXG4gICAgICAgICAgICAgICAgICogICAgICBibG9jayA6IFtzdHJpbmcsIGFycmF5LCBvYmplY3RdLCAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzICdiZWdpbicuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIG1hcmdpbiA6IFtudW1iZXIsIGJvb2xlYW4sIGFycmF5LCBvYmplY3RdICAgICAgIERlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXHJcbiAgICAgICAgICAgICAgICAgKiAgICB9XHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogICAgUG9zc2libGUgc2Nyb2xsIHNldHRpbmdzIGFyZTpcclxuICAgICAgICAgICAgICAgICAqICAgICdhbHdheXMnICAgICAgU2Nyb2xscyBhbHdheXMuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnaWZuZWVkZWQnICAgIFNjcm9sbHMgb25seSBpZiB0aGUgZWxlbWVudCBpc250IGZ1bGx5IGluIHZpZXcuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnbmV2ZXInICAgICAgIFNjcm9sbHMgbmV2ZXIuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogICAgUG9zc2libGUgYmxvY2sgc2V0dGluZ3MgYXJlOlxyXG4gICAgICAgICAgICAgICAgICogICAgJ2JlZ2luJyAgIEJvdGggYXhpcyBzaGFsbCBiZSBkb2NrZWQgdG8gdGhlIFwiYmVnaW5cIiBlZGdlLiAtIFRoZSBlbGVtZW50IHdpbGwgYmUgZG9ja2VkIHRvIHRoZSB0b3AgYW5kIGxlZnQgZWRnZSBvZiB0aGUgdmlld3BvcnQuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnZW5kJyAgICAgQm90aCBheGlzIHNoYWxsIGJlIGRvY2tlZCB0byB0aGUgXCJlbmRcIiBlZGdlLiAtIFRoZSBlbGVtZW50IHdpbGwgYmUgZG9ja2VkIHRvIHRoZSBib3R0b20gYW5kIHJpZ2h0IGVkZ2Ugb2YgdGhlIHZpZXdwb3J0LiAoSWYgZGlyZWN0aW9uIGlzIFJUTCB0byB0aGUgYm90dG9tIGFuZCBsZWZ0IGVkZ2UuKVxyXG4gICAgICAgICAgICAgICAgICogICAgJ2NlbnRlcicgIEJvdGggYXhpcyBzaGFsbCBiZSBkb2NrZWQgdG8gXCJjZW50ZXJcIi4gLSBUaGUgZWxlbWVudCB3aWxsIGJlIGNlbnRlcmVkIGluIHRoZSB2aWV3cG9ydC5cclxuICAgICAgICAgICAgICAgICAqICAgICduZWFyZXN0JyBUaGUgZWxlbWVudCB3aWxsIGJlIGRvY2tlZCB0byB0aGUgbmVhcmVzdCBlZGdlKHMpLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICAgIFBvc3NpYmxlIG1hcmdpbiBzZXR0aW5ncyBhcmU6IC0tIFRoZSBhY3R1YWwgbWFyZ2luIG9mIHRoZSBlbGVtZW50IHdvbnQgYmUgYWZmZWN0LCB0aGlzIG9wdGlvbiBhZmZlY3RzIG9ubHkgdGhlIGZpbmFsIHNjcm9sbCBvZmZzZXQuXHJcbiAgICAgICAgICAgICAgICAgKiAgICBbQk9PTEVBTl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgdGhlIGNzcyBtYXJnaW4gb2YgdGhlIGVsZW1lbnQgd2lsbCBiZSB1c2VkLCBpZiBmYWxzZSBubyBtYXJnaW4gd2lsbCBiZSB1c2VkLlxyXG4gICAgICAgICAgICAgICAgICogICAgW05VTUJFUl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbWFyZ2luIHdpbGwgYmUgdXNlZCBmb3IgYWxsIGVkZ2VzLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHNjcm9sbCBhbmltYXRpb24sIE9SIGEgalF1ZXJ5IGFuaW1hdGlvbiBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlYXNpbmcgVGhlIGFuaW1hdGlvbiBlYXNpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29tcGxldGUgVGhlIGFuaW1hdGlvbiBjb21wbGV0ZSBjYWxsYmFjay5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7XHJcbiAgICAgICAgICAgICAgICAgKiAgIHBvc2l0aW9uOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LFxyXG4gICAgICAgICAgICAgICAgICogICByYXRpbzoge3g6IG51bWJlciwgeTogbnVtYmVyfSxcclxuICAgICAgICAgICAgICAgICAqICAgbWF4OiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LFxyXG4gICAgICAgICAgICAgICAgICogICBoYW5kbGVPZmZzZXQ6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sXHJcbiAgICAgICAgICAgICAgICAgKiAgIGhhbmRsZUxlbmd0aDoge3g6IG51bWJlciwgeTogbnVtYmVyfSxcclxuICAgICAgICAgICAgICAgICAqICAgaGFuZGxlTGVuZ3RoUmF0aW86IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sIHRcclxuICAgICAgICAgICAgICAgICAqICAgcmFja0xlbmd0aDoge3g6IG51bWJlciwgeTogbnVtYmVyfSxcclxuICAgICAgICAgICAgICAgICAqICAgaXNSVEw6IGJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICAgKiAgIGlzUlRMTm9ybWFsaXplZDogYm9vbGVhblxyXG4gICAgICAgICAgICAgICAgICogIH19XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLnNjcm9sbCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgZHVyYXRpb24sIGVhc2luZywgY29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBjb29yZGluYXRlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvWCA9IF9zY3JvbGxIb3Jpem9udGFsSW5mbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm9ZID0gX3Njcm9sbFZlcnRpY2FsSW5mbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZUludmVydCA9IF9ub3JtYWxpemVSVExDYWNoZSAmJiBfaXNSVEwgJiYgX3J0bFNjcm9sbEJlaGF2aW9yLmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVOZWdhdGUgPSBfbm9ybWFsaXplUlRMQ2FjaGUgJiYgX2lzUlRMICYmIF9ydGxTY3JvbGxCZWhhdmlvci5uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWCA9IGluZm9YLl9jdXJyZW50U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWFJhdGlvID0gaW5mb1guX2N1cnJlbnRTY3JvbGxSYXRpbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFNjcm9sbFggPSBpbmZvWC5fbWF4U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYUmF0aW8gPSBub3JtYWxpemVJbnZlcnQgPyAxIC0gc2Nyb2xsWFJhdGlvIDogc2Nyb2xsWFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYID0gbm9ybWFsaXplSW52ZXJ0ID8gbWF4U2Nyb2xsWCAtIHNjcm9sbFggOiBzY3JvbGxYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYICo9IG5vcm1hbGl6ZU5lZ2F0ZSA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4U2Nyb2xsWCAqPSBub3JtYWxpemVOZWdhdGUgPyAtMSA6IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzY3JvbGxYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl9jdXJyZW50U2Nyb2xsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0aW86IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzY3JvbGxYUmF0aW8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX2N1cnJlbnRTY3JvbGxSYXRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IG1heFNjcm9sbFgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX21heFNjcm9sbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU9mZnNldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGluZm9YLl9oYW5kbGVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX2hhbmRsZU9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUxlbmd0aDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGluZm9YLl9oYW5kbGVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX2hhbmRsZUxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUxlbmd0aFJhdGlvOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaW5mb1guX2hhbmRsZUxlbmd0aFJhdGlvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl9oYW5kbGVMZW5ndGhSYXRpb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrTGVuZ3RoOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaW5mb1guX3RyYWNrTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl90cmFja0xlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBwZWRIYW5kbGVPZmZzZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpbmZvWC5fc25hcHBlZEhhbmRsZU9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbmZvWS5fc25hcHBlZEhhbmRsZU9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUlRMOiBfaXNSVEwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JUTE5vcm1hbGl6ZWQ6IF9ub3JtYWxpemVSVExDYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKF9zdHJTeW5jKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZVJUTCA9IF9ub3JtYWxpemVSVExDYWNoZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXNYQXhpc1Byb3BzID0gW19zdHJYLCBfc3RyTGVmdCwgJ2wnXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXNZQXhpc1Byb3BzID0gW19zdHJZLCBfc3RyVG9wLCAndCddO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlc09wZXJhdG9ycyA9IFsnKz0nLCAnLT0nLCAnKj0nLCAnLz0nXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb25Jc09iamVjdCA9IHR5cGUoZHVyYXRpb24pID09IFRZUEVTLm87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlQ2FsbGJhY2sgPSBkdXJhdGlvbklzT2JqZWN0ID8gZHVyYXRpb24uY29tcGxldGUgOiBjb21wbGV0ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxTY3JvbGwgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BlY2lhbEVhc2luZyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb1Njcm9sbExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvU2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25PcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJFbmQgPSAnZW5kJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQmVnaW4gPSAnYmVnaW4nO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJDZW50ZXIgPSAnY2VudGVyJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyTmVhcmVzdCA9ICduZWFyZXN0JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQWx3YXlzID0gJ2Fsd2F5cyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ck5ldmVyID0gJ25ldmVyJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RySWZOZWVkZWQgPSAnaWZuZWVkZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJMZW5ndGggPSBMRVhJQ09OLmw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzQXhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3NTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzQmxvY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzTWFyZ2luO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRPYmpTZXR0aW5nc0F4aXNWYWx1ZXMgPSBbX3N0clgsIF9zdHJZLCAneHknLCAneXgnXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE9ialNldHRpbmdzQmxvY2tWYWx1ZXMgPSBbc3RyQmVnaW4sIHN0ckVuZCwgc3RyQ2VudGVyLCBzdHJOZWFyZXN0XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE9ialNldHRpbmdzU2Nyb2xsVmFsdWVzID0gW3N0ckFsd2F5cywgc3RyTmV2ZXIsIHN0cklmTmVlZGVkXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXNJc0VsZW1lbnRPYmogPSBjb29yZGluYXRlc1tMRVhJQ09OLmhPUF0oJ2VsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlRWxlbWVudCA9IGNvb3JkaW5hdGVzSXNFbGVtZW50T2JqID8gY29vcmRpbmF0ZXMuZWwgOiBjb29yZGluYXRlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVFbGVtZW50SXNKUXVlcnkgPSBwb3NzaWJsZUVsZW1lbnQgaW5zdGFuY2VvZiBGUkFNRVdPUksgfHwgSlFVRVJZID8gcG9zc2libGVFbGVtZW50IGluc3RhbmNlb2YgSlFVRVJZIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlRWxlbWVudElzSFRNTEVsZW1lbnQgPSBwb3NzaWJsZUVsZW1lbnRJc0pRdWVyeSA/IGZhbHNlIDogaXNIVE1MRWxlbWVudChwb3NzaWJsZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVTY3JvbGxiYXJJbmZvcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvU2Nyb2xsTGVmdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1Njcm9sbFRvcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3h5Q29tcGxldGVDYWxsYmFjayA9IHR5cGUoY29tcGxldGVDYWxsYmFjaykgIT0gVFlQRVMuZiA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2Nyb2xsYmFySW5mb3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVDYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tTZXR0aW5nc1N0cmluZ1ZhbHVlKGN1cnJWYWx1ZSwgYWxsb3dlZFZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsb3dlZFZhbHVlc1tzdHJMZW5ndGhdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyVmFsdWUgPT09IGFsbG93ZWRWYWx1ZXNbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRSYXdTY3JvbGwoaXNYLCBjb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZVByb3BzID0gaXNYID8gY29vcmRpbmF0ZXNYQXhpc1Byb3BzIDogY29vcmRpbmF0ZXNZQXhpc1Byb3BzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA9IHR5cGUoY29vcmRpbmF0ZXMpID09IFRZUEVTLnMgfHwgdHlwZShjb29yZGluYXRlcykgPT0gVFlQRVMubiA/IFtjb29yZGluYXRlcywgY29vcmRpbmF0ZXNdIDogY29vcmRpbmF0ZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pc0EoY29vcmRpbmF0ZXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzWCA/IGNvb3JkaW5hdGVzWzBdIDogY29vcmRpbmF0ZXNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUoY29vcmRpbmF0ZXMpID09IFRZUEVTLm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVjaWRlcyBSVEwgbm9ybWFsaXphdGlvbiBcImhhY2tcIiB3aXRoIC5uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vcm1hbGl6ZVJUTCA9IHR5cGUoY29vcmRpbmF0ZXMubikgPT0gVFlQRVMuYiA/IGNvb3JkaW5hdGVzLm4gOiBub3JtYWxpemVSVEw7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3JkaW5hdGVQcm9wc1tzdHJMZW5ndGhdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVQcm9wc1tpXSBpbiBjb29yZGluYXRlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVQcm9wc1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RmluYWxTY3JvbGwoaXNYLCByYXdTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZShyYXdTY3JvbGwpID09IFRZUEVTLnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbEluZm8gPSBpc1ggPyBfc2Nyb2xsSG9yaXpvbnRhbEluZm8gOiBfc2Nyb2xsVmVydGljYWxJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclNjcm9sbCA9IHNjcm9sbEluZm8uX2N1cnJlbnRTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhTY3JvbGwgPSBzY3JvbGxJbmZvLl9tYXhTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0ID0gJyAqICc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNSVExpc1ggPSBfaXNSVEwgJiYgaXNYO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplU2hvcnRjdXRzID0gaXNSVExpc1ggJiYgX3J0bFNjcm9sbEJlaGF2aW9yLm4gJiYgIW5vcm1hbGl6ZVJUTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0clJlcGxhY2UgPSAncmVwbGFjZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmFsRnVuYyA9IGV2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZU9wZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgb3BlcmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdTY3JvbGxbc3RyTGVuZ3RoXSA+IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZU9wZXJhdG9yID0gcmF3U2Nyb2xsLnN1YnN0cigwLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShwb3NzaWJsZU9wZXJhdG9yLCBjb29yZGluYXRlc09wZXJhdG9ycykgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBwb3NzaWJsZU9wZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FsY3VsYXRlIHVuaXRzIGFuZCBzaG9ydGN1dHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1Njcm9sbCA9IG9wZXJhdG9yID8gcmF3U2Nyb2xsLnN1YnN0cigyKSA6IHJhd1Njcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1Njcm9sbCA9IHJhd1Njcm9sbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0clJlcGxhY2VdKC9taW4vZywgMCkgLy8nbWluJyA9IDAlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oLzwvZywgMCkgICAvLyc8JyAgID0gMCVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHJSZXBsYWNlXSgvbWF4L2csIChub3JtYWxpemVTaG9ydGN1dHMgPyAnLScgOiBfc3RyRW1wdHkpICsgX3N0ckh1bmRyZWRQZXJjZW50KSAgICAvLydtYXgnID0gMTAwJVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0clJlcGxhY2VdKC8+L2csIChub3JtYWxpemVTaG9ydGN1dHMgPyAnLScgOiBfc3RyRW1wdHkpICsgX3N0ckh1bmRyZWRQZXJjZW50KSAgICAgIC8vJz4nICAgPSAxMDAlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oL3B4L2csIF9zdHJFbXB0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHJSZXBsYWNlXSgvJS9nLCBtdWx0ICsgKG1heFNjcm9sbCAqIChpc1JUTGlzWCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IubiA/IC0xIDogMSkgLyAxMDAuMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oL3Z3L2csIG11bHQgKyBfdmlld3BvcnRTaXplLncpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oL3ZoL2csIG11bHQgKyBfdmlld3BvcnRTaXplLmgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gcGFyc2VUb1plcm9Pck51bWJlcihpc05hTihyYXdTY3JvbGwpID8gcGFyc2VUb1plcm9Pck51bWJlcihldmFsRnVuYyhyYXdTY3JvbGwpLCB0cnVlKS50b0ZpeGVkKCkgOiByYXdTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gcmF3U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1vdW50ICE9PSB1bmRlZmluZWQgJiYgIWlzTmFOKGFtb3VudCkgJiYgdHlwZShhbW91bnQpID09IFRZUEVTLm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVJc1JUTGlzWCA9IG5vcm1hbGl6ZVJUTCAmJiBpc1JUTGlzWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvckN1cnJTY3JvbGwgPSBjdXJyU2Nyb2xsICogKG5vcm1hbGl6ZUlzUlRMaXNYICYmIF9ydGxTY3JvbGxCZWhhdmlvci5uID8gLTEgOiAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnZlcnQgPSBub3JtYWxpemVJc1JUTGlzWCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IuaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZWdhdGUgPSBub3JtYWxpemVJc1JUTGlzWCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IubjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yQ3VyclNjcm9sbCA9IGludmVydCA/IChtYXhTY3JvbGwgLSBvcGVyYXRvckN1cnJTY3JvbGwpIDogb3BlcmF0b3JDdXJyU2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJys9JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IG9wZXJhdG9yQ3VyclNjcm9sbCArIGFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLT0nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gb3BlcmF0b3JDdXJyU2Nyb2xsIC0gYW1vdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcqPSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBvcGVyYXRvckN1cnJTY3JvbGwgKiBhbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy89JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IG9wZXJhdG9yQ3VyclNjcm9sbCAvIGFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gaW52ZXJ0ID8gbWF4U2Nyb2xsIC0gZmluYWxWYWx1ZSA6IGZpbmFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlICo9IG5lZ2F0ZSA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBpc1JUTGlzWCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IubiA/IE1BVEgubWluKDAsIE1BVEgubWF4KG1heFNjcm9sbCwgZmluYWxWYWx1ZSkpIDogTUFUSC5tYXgoMCwgTUFUSC5taW4obWF4U2Nyb2xsLCBmaW5hbFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsVmFsdWUgPT09IGN1cnJTY3JvbGwgPyB1bmRlZmluZWQgOiBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRQZXJBeGlzVmFsdWUodmFsdWUsIHZhbHVlSW50ZXJuYWxUeXBlLCBkZWZhdWx0VmFsdWUsIGFsbG93ZWRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdERlZmF1bHQgPSBbZGVmYXVsdFZhbHVlLCBkZWZhdWx0VmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVUeXBlID0gdHlwZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZUFyckxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlQXJySXRlbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgY2FuIGJlIFsgc3RyaW5nLCBvciBhcnJheSBvZiB0d28gc3RyaW5ncyBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT0gdmFsdWVJbnRlcm5hbFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlLCB2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVUeXBlID09IFRZUEVTLmEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQXJyTGVuZ3RoID0gdmFsdWVbc3RyTGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUFyckxlbmd0aCA+IDIgfHwgdmFsdWVBcnJMZW5ndGggPCAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0RGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUFyckxlbmd0aCA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbMV0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlQXJyTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVBcnJJdGVtID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKHZhbHVlQXJySXRlbSkgIT0gdmFsdWVJbnRlcm5hbFR5cGUgfHwgIWNoZWNrU2V0dGluZ3NTdHJpbmdWYWx1ZSh2YWx1ZUFyckl0ZW0sIGFsbG93ZWRWYWx1ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdERlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZVR5cGUgPT0gVFlQRVMubylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlW19zdHJYXSB8fCBkZWZhdWx0VmFsdWUsIHZhbHVlW19zdHJZXSB8fCBkZWZhdWx0VmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdERlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IHZhbHVlWzBdLCB5OiB2YWx1ZVsxXSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZU1hcmdpbihtYXJnaW5Ub3BSaWdodEJvdHRvbUxlZnRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyVmFsdWVUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVEaXJlY3Rpb25zID0gW19zdHJUb3AsIF9zdHJSaWdodCwgX3N0ckJvdHRvbSwgX3N0ckxlZnRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWFyZ2luVG9wUmlnaHRCb3R0b21MZWZ0QXJyYXlbc3RyTGVuZ3RoXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdmFsdWVEaXJlY3Rpb25zW3N0ckxlbmd0aF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyVmFsdWUgPSBtYXJnaW5Ub3BSaWdodEJvdHRvbUxlZnRBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJWYWx1ZVR5cGUgPSB0eXBlKGN1cnJWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyclZhbHVlVHlwZSA9PSBUWVBFUy5iKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJWYWx1ZSA/IHBhcnNlVG9aZXJvT3JOdW1iZXIoZmluYWxFbGVtZW50LmNzcyhfc3RyTWFyZ2luTWludXMgKyB2YWx1ZURpcmVjdGlvbnNbaV0pKSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJWYWx1ZVR5cGUgPT0gVFlQRVMubiA/IGN1cnJWYWx1ZSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zc2libGVFbGVtZW50SXNKUXVlcnkgfHwgcG9zc2libGVFbGVtZW50SXNIVE1MRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luID0gY29vcmRpbmF0ZXNJc0VsZW1lbnRPYmogPyBjb29yZGluYXRlcy5tYXJnaW4gOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IGNvb3JkaW5hdGVzSXNFbGVtZW50T2JqID8gY29vcmRpbmF0ZXMuYXhpcyA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGwgPSBjb29yZGluYXRlc0lzRWxlbWVudE9iaiA/IGNvb3JkaW5hdGVzLnNjcm9sbCA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGNvb3JkaW5hdGVzSXNFbGVtZW50T2JqID8gY29vcmRpbmF0ZXMuYmxvY2sgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luRGVmYXVsdCA9IFswLCAwLCAwLCAwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpblR5cGUgPSB0eXBlKG1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJnaW5MZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsRWxlbWVudCA9IHBvc3NpYmxlRWxlbWVudElzSlF1ZXJ5ID8gcG9zc2libGVFbGVtZW50IDogRlJBTUVXT1JLKHBvc3NpYmxlRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxFbGVtZW50W3N0ckxlbmd0aF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21hcmdpbiBjYW4gYmUgWyBib29sZWFuLCBudW1iZXIsIGFycmF5IG9mIDIsIGFycmF5IG9mIDQsIG9iamVjdCBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2luVHlwZSA9PSBUWVBFUy5uIHx8IG1hcmdpblR5cGUgPT0gVFlQRVMuYilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBnZW5lcmF0ZU1hcmdpbihbbWFyZ2luLCBtYXJnaW4sIG1hcmdpbiwgbWFyZ2luXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXJnaW5UeXBlID09IFRZUEVTLmEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZW5ndGggPSBtYXJnaW5bc3RyTGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2luTGVuZ3RoID09PSAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBnZW5lcmF0ZU1hcmdpbihbbWFyZ2luWzBdLCBtYXJnaW5bMV0sIG1hcmdpblswXSwgbWFyZ2luWzFdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWFyZ2luTGVuZ3RoID49IDQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IGdlbmVyYXRlTWFyZ2luKG1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBtYXJnaW5EZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWFyZ2luVHlwZSA9PSBUWVBFUy5vKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IGdlbmVyYXRlTWFyZ2luKFttYXJnaW5bX3N0clRvcF0sIG1hcmdpbltfc3RyUmlnaHRdLCBtYXJnaW5bX3N0ckJvdHRvbV0sIG1hcmdpbltfc3RyTGVmdF1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBtYXJnaW5EZWZhdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmxvY2sgPSB0eXBlKGJsb2NrKSA9PT0gVFlQRVMuYiA/IGJsb2NrID8gWyBzdHJOZWFyZXN0LCBzdHJCZWdpbiBdIDogWyBzdHJOZWFyZXN0LCBzdHJFbmQgXSA6IGJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NBeGlzID0gY2hlY2tTZXR0aW5nc1N0cmluZ1ZhbHVlKGF4aXMsIGVsZW1lbnRPYmpTZXR0aW5nc0F4aXNWYWx1ZXMpID8gYXhpcyA6ICd4eSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1Njcm9sbCA9IGdldFBlckF4aXNWYWx1ZShzY3JvbGwsIFRZUEVTLnMsIHN0ckFsd2F5cywgZWxlbWVudE9ialNldHRpbmdzU2Nyb2xsVmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQmxvY2sgPSBnZXRQZXJBeGlzVmFsdWUoYmxvY2ssIFRZUEVTLnMsIHN0ckJlZ2luLCBlbGVtZW50T2JqU2V0dGluZ3NCbG9ja1ZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc01hcmdpbiA9IG1hcmdpbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRTY3JvbGwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbDogX3Njcm9sbEhvcml6b250YWxJbmZvLl9jdXJyZW50U2Nyb2xsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ6IF9zY3JvbGxWZXJ0aWNhbEluZm8uX2N1cnJlbnRTY3JvbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgcGFkZGluZyBlbGVtZW50IGluc3RlYWQgb2Ygdmlld3BvcnQgZWxlbWVudCBiZWNhdXNlIHBhZGRpbmcgZWxlbWVudCBoYXMgbmV2ZXIgcGFkZGluZywgbWFyZ2luIG9yIHBvc2l0aW9uIGFwcGxpZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRPZmZzZXQgPSBfcGFkZGluZ0VsZW1lbnQub2Zmc2V0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50T2Zmc2V0ID0gZmluYWxFbGVtZW50Lm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvTm90U2Nyb2xsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNldHRpbmdzU2Nyb2xsLnggPT0gc3RyTmV2ZXIgfHwgc2V0dGluZ3NBeGlzID09IF9zdHJZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNldHRpbmdzU2Nyb2xsLnkgPT0gc3RyTmV2ZXIgfHwgc2V0dGluZ3NBeGlzID09IF9zdHJYXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE9mZnNldFtfc3RyVG9wXSAtPSBzZXR0aW5nc01hcmdpblswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRPZmZzZXRbX3N0ckxlZnRdIC09IHNldHRpbmdzTWFyZ2luWzNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRTY3JvbGxDb29yZGluYXRlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBNQVRILnJvdW5kKGVsZW1lbnRPZmZzZXRbX3N0ckxlZnRdIC0gdmlld3BvcnRPZmZzZXRbX3N0ckxlZnRdICsgdmlld3BvcnRTY3JvbGwubCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogTUFUSC5yb3VuZChlbGVtZW50T2Zmc2V0W19zdHJUb3BdIC0gdmlld3BvcnRPZmZzZXRbX3N0clRvcF0gKyB2aWV3cG9ydFNjcm9sbC50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNSVEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9ydGxTY3JvbGxCZWhhdmlvci5uICYmICFfcnRsU2Nyb2xsQmVoYXZpb3IuaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzLnggPSBNQVRILnJvdW5kKHZpZXdwb3J0T2Zmc2V0W19zdHJMZWZ0XSAtIGVsZW1lbnRPZmZzZXRbX3N0ckxlZnRdICsgdmlld3BvcnRTY3JvbGwubCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9ydGxTY3JvbGxCZWhhdmlvci5uICYmIG5vcm1hbGl6ZVJUTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzLnggKj0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9ydGxTY3JvbGxCZWhhdmlvci5pICYmIG5vcm1hbGl6ZVJUTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzLnggPSBNQVRILnJvdW5kKHZpZXdwb3J0T2Zmc2V0W19zdHJMZWZ0XSAtIGVsZW1lbnRPZmZzZXRbX3N0ckxlZnRdICsgKF9zY3JvbGxIb3Jpem9udGFsSW5mby5fbWF4U2Nyb2xsIC0gdmlld3BvcnRTY3JvbGwubCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyaW5nIGlzIHJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NCbG9jay54ICE9IHN0ckJlZ2luIHx8IHNldHRpbmdzQmxvY2sueSAhPSBzdHJCZWdpbiB8fCBzZXR0aW5nc1Njcm9sbC54ID09IHN0cklmTmVlZGVkIHx8IHNldHRpbmdzU2Nyb2xsLnkgPT0gc3RySWZOZWVkZWQgfHwgX2lzUlRMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lYXN1cmluZ0VsbSA9IGZpbmFsRWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3RWxlbWVudFNpemUgPSBfc3VwcG9ydFRyYW5zZm9ybSA/IG1lYXN1cmluZ0VsbVtMRVhJQ09OLmJDUl0oKSA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG1lYXN1cmluZ0VsbVtMRVhJQ09OLm9XXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBtZWFzdXJpbmdFbG1bTEVYSUNPTi5vSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50U2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogcmF3RWxlbWVudFNpemVbX3N0cldpZHRoXSArIHNldHRpbmdzTWFyZ2luWzNdICsgc2V0dGluZ3NNYXJnaW5bMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IHJhd0VsZW1lbnRTaXplW19zdHJIZWlnaHRdICsgc2V0dGluZ3NNYXJnaW5bMF0gKyBzZXR0aW5nc01hcmdpblsyXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsaXplQmxvY2sgPSBmdW5jdGlvbiAoaXNYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhpc1gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2ggPSB2YXJzLl93X2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsdCA9IHZhcnMuX2xlZnRfdG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeHkgPSB2YXJzLl94X3k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0lzRW5kID0gc2V0dGluZ3NCbG9ja1t4eV0gPT0gKGlzWCA/IF9pc1JUTCA/IHN0ckJlZ2luIDogc3RyRW5kIDogc3RyRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrSXNDZW50ZXIgPSBzZXR0aW5nc0Jsb2NrW3h5XSA9PSBzdHJDZW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0lzTmVhcmVzdCA9IHNldHRpbmdzQmxvY2tbeHldID09IHN0ck5lYXJlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxOZXZlciA9IHNldHRpbmdzU2Nyb2xsW3h5XSA9PSBzdHJOZXZlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbElmTmVlZGVkID0gc2V0dGluZ3NTY3JvbGxbeHldID09IHN0cklmTmVlZGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdnBTaXplID0gX3ZpZXdwb3J0U2l6ZVt3aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2cE9mZnNldCA9IHZpZXdwb3J0T2Zmc2V0W2x0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsU2l6ZSA9IGVsZW1lbnRTaXplW3doXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsT2Zmc2V0ID0gZWxlbWVudE9mZnNldFtsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXZpZGUgPSBibG9ja0lzQ2VudGVyID8gMiA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50Q2VudGVyT2Zmc2V0ID0gZWxPZmZzZXQgKyAoZWxTaXplIC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydENlbnRlck9mZnNldCA9IHZwT2Zmc2V0ICsgKHZwU2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNJblZpZXcgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxTaXplIDw9IHZwU2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgZWxPZmZzZXQgPj0gdnBPZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGVsT2Zmc2V0ICsgZWxTaXplIDw9IHZwT2Zmc2V0ICsgdnBTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbE5ldmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9Ob3RTY3JvbGxbeHldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRvTm90U2Nyb2xsW3h5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrSXNOZWFyZXN0IHx8IHNjcm9sbElmTmVlZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9Ob3RTY3JvbGxbeHldID0gc2Nyb2xsSWZOZWVkZWQgPyBpc0luVmlldyA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrSXNFbmQgPSBlbFNpemUgPCB2cFNpemUgPyBlbGVtZW50Q2VudGVyT2Zmc2V0ID4gdmlld3BvcnRDZW50ZXJPZmZzZXQgOiBlbGVtZW50Q2VudGVyT2Zmc2V0IDwgdmlld3BvcnRDZW50ZXJPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXNbeHldIC09IGJsb2NrSXNFbmQgfHwgYmxvY2tJc0NlbnRlciA/ICgodnBTaXplIC8gZGl2aWRlKSAtIChlbFNpemUgLyBkaXZpZGUpKSAqIChpc1ggJiYgX2lzUlRMICYmIG5vcm1hbGl6ZVJUTCA/IC0xIDogMSkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZUJsb2NrKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplQmxvY2soZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb05vdFNjcm9sbC55KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXMueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb05vdFNjcm9sbC54KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXMueDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA9IGVsZW1lbnRTY3JvbGxDb29yZGluYXRlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTY3JvbGxbX3N0clNjcm9sbExlZnRdID0gZ2V0RmluYWxTY3JvbGwodHJ1ZSwgZ2V0UmF3U2Nyb2xsKHRydWUsIGNvb3JkaW5hdGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTY3JvbGxbX3N0clNjcm9sbFRvcF0gPSBnZXRGaW5hbFNjcm9sbChmYWxzZSwgZ2V0UmF3U2Nyb2xsKGZhbHNlLCBjb29yZGluYXRlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2Nyb2xsTGVmdCA9IGZpbmFsU2Nyb2xsW19zdHJTY3JvbGxMZWZ0XSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvU2Nyb2xsVG9wID0gZmluYWxTY3JvbGxbX3N0clNjcm9sbFRvcF0gIT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkb1Njcm9sbExlZnQgfHwgZG9TY3JvbGxUb3ApICYmIChkdXJhdGlvbiA+IDAgfHwgZHVyYXRpb25Jc09iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uSXNPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uLmNvbXBsZXRlID0gcHJveHlDb21wbGV0ZUNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5hbmltYXRlKGZpbmFsU2Nyb2xsLCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogcHJveHlDb21wbGV0ZUNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaXNBKGVhc2luZykgfHwgRlJBTUVXT1JLLmlzUGxhaW5PYmplY3QoZWFzaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbX3N0clNjcm9sbExlZnRdID0gZWFzaW5nWzBdIHx8IGVhc2luZy54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbX3N0clNjcm9sbFRvcF0gPSBlYXNpbmdbMV0gfHwgZWFzaW5nLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9ucy5zcGVjaWFsRWFzaW5nID0gc3BlY2lhbEVhc2luZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMuZWFzaW5nID0gZWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5hbmltYXRlKGZpbmFsU2Nyb2xsLCBhbmltYXRpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvU2Nyb2xsTGVmdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKGZpbmFsU2Nyb2xsW19zdHJTY3JvbGxMZWZ0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1Njcm9sbFRvcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbX3N0clNjcm9sbFRvcF0oZmluYWxTY3JvbGxbX3N0clNjcm9sbFRvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTY3JvbGxiYXJJbmZvcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTdG9wcyBhbGwgc2Nyb2xsIGFuaW1hdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIGN1cnJlbnQgT3ZlcmxheVNjcm9sbGJhcnMgaW5zdGFuY2UgKGZvciBjaGFpbmluZykuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLnNjcm9sbFN0b3AgPSBmdW5jdGlvbiAocGFyYW0xLCBwYXJhbTIsIHBhcmFtMykge1xyXG4gICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuc3RvcChwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Jhc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBhbGwgcmVsZXZhbnQgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZWxlbWVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQgd2hpY2ggc2hhbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e3RhcmdldDogKiwgaG9zdDogKiwgcGFkZGluZzogKiwgdmlld3BvcnQ6ICosIGNvbnRlbnQ6ICosIHNjcm9sbGJhckhvcml6b250YWw6IHtzY3JvbGxiYXI6ICosIHRyYWNrOiAqLCBoYW5kbGU6ICp9LCBzY3JvbGxiYXJWZXJ0aWNhbDoge3Njcm9sbGJhcjogKiwgdHJhY2s6ICosIGhhbmRsZTogKn0sIHNjcm9sbGJhckNvcm5lcjogKn0gfCAqfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogX3RhcmdldEVsZW1lbnROYXRpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IF9ob3N0RWxlbWVudE5hdGl2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogX3BhZGRpbmdFbGVtZW50TmF0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydDogX3ZpZXdwb3J0RWxlbWVudE5hdGl2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogX2NvbnRlbnRFbGVtZW50TmF0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJIb3Jpem9udGFsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXI6IF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrOiBfc2Nyb2xsYmFySG9yaXpvbnRhbFRyYWNrRWxlbWVudFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZTogX3Njcm9sbGJhckhvcml6b250YWxIYW5kbGVFbGVtZW50WzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZlcnRpY2FsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXI6IF9zY3JvbGxiYXJWZXJ0aWNhbEVsZW1lbnRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjazogX3Njcm9sbGJhclZlcnRpY2FsVHJhY2tFbGVtZW50WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlOiBfc2Nyb2xsYmFyVmVydGljYWxIYW5kbGVFbGVtZW50WzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhckNvcm5lcjogX3Njcm9sbGJhckNvcm5lckVsZW1lbnRbMF1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlKGVsZW1lbnROYW1lKSA9PSBUWVBFUy5zID8gZ2V0T2JqZWN0UHJvcFZhbChvYmosIGVsZW1lbnROYW1lKSA6IG9iajtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGEgb2JqZWN0IHdoaWNoIGRlc2NyaWJlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHN0YXRlUHJvcGVydHkgQSBzcGVjaWZpYyBwcm9wZXJ0eSBmcm9tIHRoZSBzdGF0ZSBvYmplY3Qgd2hpY2ggc2hhbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e3dpZHRoQXV0bywgaGVpZ2h0QXV0bywgb3ZlcmZsb3dBbW91bnQsIGhpZGVPdmVyZmxvdywgaGFzT3ZlcmZsb3csIGNvbnRlbnRTY3JvbGxTaXplLCB2aWV3cG9ydFNpemUsIGhvc3RTaXplLCBhdXRvVXBkYXRlfSB8ICp9XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLmdldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlUHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcmVwYXJlKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUZSQU1FV09SSy5pc1BsYWluT2JqZWN0KG9iaikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kZWQgPSBleHRlbmREZWVwKHt9LCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kZWRbTEVYSUNPTi5oT1BdKGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRbdG9dID0gZXh0ZW5kZWRbZnJvbV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV4dGVuZGVkW2Zyb21dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VQcm9wZXJ0eU5hbWUoJ3cnLCBfc3RyV2lkdGgpOyAvL2NoYW5nZSB3IHRvIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVByb3BlcnR5TmFtZSgnaCcsIF9zdHJIZWlnaHQpOyAvL2NoYW5nZSBoIHRvIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXh0ZW5kZWQuYzsgLy9kZWxldGUgYyAodGhlICdjaGFuZ2VkJyBwcm9wKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5kZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95ZWQ6ICEhcHJlcGFyZShfZGVzdHJveWVkKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xlZXBpbmc6ICEhcHJlcGFyZShfc2xlZXBpbmcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlOiBwcmVwYXJlKCFfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aEF1dG86IHByZXBhcmUoX3dpZHRoQXV0b0NhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0QXV0bzogcHJlcGFyZShfaGVpZ2h0QXV0b0NhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogcHJlcGFyZShfY3NzUGFkZGluZ0NhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dBbW91bnQ6IHByZXBhcmUoX292ZXJmbG93QW1vdW50Q2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlT3ZlcmZsb3c6IHByZXBhcmUoX2hpZGVPdmVyZmxvd0NhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3ZlcmZsb3c6IHByZXBhcmUoX2hhc092ZXJmbG93Q2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50U2Nyb2xsU2l6ZTogcHJlcGFyZShfY29udGVudFNjcm9sbFNpemVDYWNoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0U2l6ZTogcHJlcGFyZShfdmlld3BvcnRTaXplKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFNpemU6IHByZXBhcmUoX2hvc3RTaXplQ2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudE1peGVkOiBwcmVwYXJlKF9kb2N1bWVudE1peGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUoc3RhdGVQcm9wZXJ0eSkgPT0gVFlQRVMucyA/IGdldE9iamVjdFByb3BWYWwob2JqLCBzdGF0ZVByb3BlcnR5KSA6IG9iajtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIGFsbCBvciBzcGVjaWZpYyBleHRlbnNpb24gaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXh0TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uIGZyb20gd2hpY2ggdGhlIGluc3RhbmNlIHNoYWxsIGJlIGdvdC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7fX0gVGhlIGluc3RhbmNlIG9mIHRoZSBleHRlbnNpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZSBvciB1bmRlZmluZWQgaWYgdGhlIGluc3RhbmNlIGNvdWxkbid0IGJlIGZvdW5kLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5leHQgPSBmdW5jdGlvbiAoZXh0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByaXZhdGVNZXRob2RzID0gX2V4dGVuc2lvbnNQcml2YXRlTWV0aG9kcy5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShleHROYW1lKSA9PSBUWVBFUy5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZXh0ZW5zaW9uc1tMRVhJQ09OLmhPUF0oZXh0TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV4dGVuZERlZXAoe30sIF9leHRlbnNpb25zW2V4dE5hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgcHJpdmF0ZU1ldGhvZHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtwcml2YXRlTWV0aG9kc1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gX2V4dGVuc2lvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBleHRlbmREZWVwKHt9LCBfYmFzZS5leHQoaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgYSBleHRlbnNpb24gdG8gdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHROYW1lIFRoZSBuYW1lIG9mIHRoZSBleHRlbnNpb24gd2hpY2ggc2hhbGwgYmUgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9uT3B0aW9ucyBUaGUgZXh0ZW5zaW9uIG9wdGlvbnMgd2hpY2ggc2hhbGwgYmUgdXNlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7fX0gVGhlIGluc3RhbmNlIG9mIHRoZSBhZGRlZCBleHRlbnNpb24gb3IgdW5kZWZpbmVkIGlmIHRoZSBleHRlbnNpb24gY291bGRuJ3QgYmUgYWRkZWQgcHJvcGVybHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLmFkZEV4dCA9IGZ1bmN0aW9uIChleHROYW1lLCBleHRlbnNpb25PcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2lzdGVyZWRFeHRlbnNpb25PYmogPSBfcGx1Z2luLmV4dGVuc2lvbihleHROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQWRkZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQ29udHJhY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyYWN0UmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cmFjdEZ1bGZpbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2lzdGVyZWRFeHRlbnNpb25PYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXh0ZW5zaW9uc1tMRVhJQ09OLmhPUF0oZXh0TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gcmVnaXN0ZXJlZEV4dGVuc2lvbk9iai5leHRlbnNpb25GYWN0b3J5LmNhbGwoX2Jhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kRGVlcCh7fSwgcmVnaXN0ZXJlZEV4dGVuc2lvbk9iai5kZWZhdWx0T3B0aW9ucyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlQ29udHJhY3QgPSBpbnN0YW5jZS5jb250cmFjdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShpbnN0YW5jZUNvbnRyYWN0KSA9PSBUWVBFUy5mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0UmVzdWx0ID0gaW5zdGFuY2VDb250cmFjdCh3aW5kb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEZ1bGZpbGxlZCA9IHR5cGUoY29udHJhY3RSZXN1bHQpID09IFRZUEVTLmIgPyBjb250cmFjdFJlc3VsdCA6IGNvbnRyYWN0RnVsZmlsbGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJhY3RGdWxmaWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4dGVuc2lvbnNbZXh0TmFtZV0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VBZGRlZCA9IGluc3RhbmNlLmFkZGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShpbnN0YW5jZUFkZGVkKSA9PSBUWVBFUy5mKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VBZGRlZChleHRlbnNpb25PcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYmFzZS5leHQoZXh0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYmFzZS5leHQoZXh0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQSBleHRlbnNpb24gd2l0aCB0aGUgbmFtZSBcXFwiXCIgKyBleHROYW1lICsgXCJcXFwiIGlzbid0IHJlZ2lzdGVyZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYSBleHRlbnNpb24gZnJvbSB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV4dGVuc2lvbiB3aGljaCBzaGFsbCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4dGVuc2lvbiB3YXMgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlIGUuZy4gaWYgdGhlIGV4dGVuc2lvbiB3YXNuJ3QgYWRkZWQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5yZW1vdmVFeHQgPSBmdW5jdGlvbiAoZXh0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IF9leHRlbnNpb25zW2V4dE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZVJlbW92ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfZXh0ZW5zaW9uc1tleHROYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlUmVtb3ZlZCA9IGluc3RhbmNlLnJlbW92ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKGluc3RhbmNlUmVtb3ZlZCkgPT0gVFlQRVMuZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlUmVtb3ZlZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIHRoZSBwbHVnaW4uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0RWxlbWVudCBUaGUgZWxlbWVudCB0byB3aGljaCB0aGUgcGx1Z2luIHNoYWxsIGJlIGFwcGxpZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5pdGlhbCBvcHRpb25zIG9mIHRoZSBwbHVnaW4uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgZXh0ZW5zaW9uKHMpIHdoaWNoIHNoYWxsIGJlIGFkZGVkIHJpZ2h0IGFmdGVyIHRoZSBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwbHVnaW4gd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWFsaXplZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjb25zdHJ1Y3QodGFyZ2V0RWxlbWVudCwgb3B0aW9ucywgZXh0ZW5zaW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9kZWZhdWx0T3B0aW9ucyA9IGdsb2JhbHMuZGVmYXVsdE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcgPSBnbG9iYWxzLm5hdGl2ZVNjcm9sbGJhclN0eWxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhclNpemUgPSBleHRlbmREZWVwKHt9LCBnbG9iYWxzLm5hdGl2ZVNjcm9sbGJhclNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkID0gZXh0ZW5kRGVlcCh7fSwgZ2xvYmFscy5uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkKTtcclxuICAgICAgICAgICAgICAgICAgICBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZSA9IGV4dGVuZERlZXAoe30sIGdsb2JhbHMub3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3J0bFNjcm9sbEJlaGF2aW9yID0gZXh0ZW5kRGVlcCh7fSwgZ2xvYmFscy5ydGxTY3JvbGxCZWhhdmlvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcGFyc2UgJiBzZXQgb3B0aW9ucyBidXQgZG9uJ3QgdXBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9ucyhleHRlbmREZWVwKHt9LCBfZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2Nzc0NhbGMgPSBnbG9iYWxzLmNzc0NhbGM7XHJcbiAgICAgICAgICAgICAgICAgICAgX21zaWVWZXJzaW9uID0gZ2xvYmFscy5tc2llO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hdXRvVXBkYXRlUmVjb21tZW5kZWQgPSBnbG9iYWxzLmF1dG9VcGRhdGVSZWNvbW1lbmRlZDtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwcG9ydFRyYW5zaXRpb24gPSBnbG9iYWxzLnN1cHBvcnRUcmFuc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBwb3J0VHJhbnNmb3JtID0gZ2xvYmFscy5zdXBwb3J0VHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBwb3J0UGFzc2l2ZUV2ZW50cyA9IGdsb2JhbHMuc3VwcG9ydFBhc3NpdmVFdmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cHBvcnRSZXNpemVPYnNlcnZlciA9IGdsb2JhbHMuc3VwcG9ydFJlc2l6ZU9ic2VydmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBwb3J0TXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbHMuc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3RyaWN0ZWRNZWFzdXJpbmcgPSBnbG9iYWxzLnJlc3RyaWN0ZWRNZWFzdXJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50RWxlbWVudCA9IEZSQU1FV09SSyh0YXJnZXRFbGVtZW50Lm93bmVyRG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudEVsZW1lbnROYXRpdmUgPSBfZG9jdW1lbnRFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIF93aW5kb3dFbGVtZW50ID0gRlJBTUVXT1JLKF9kb2N1bWVudEVsZW1lbnROYXRpdmUuZGVmYXVsdFZpZXcgfHwgX2RvY3VtZW50RWxlbWVudE5hdGl2ZS5wYXJlbnRXaW5kb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIF93aW5kb3dFbGVtZW50TmF0aXZlID0gX3dpbmRvd0VsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgX2h0bWxFbGVtZW50ID0gZmluZEZpcnN0KF9kb2N1bWVudEVsZW1lbnQsICdodG1sJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2JvZHlFbGVtZW50ID0gZmluZEZpcnN0KF9odG1sRWxlbWVudCwgJ2JvZHknKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudCA9IEZSQU1FV09SSyh0YXJnZXRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudE5hdGl2ZSA9IF90YXJnZXRFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pc1RleHRhcmVhID0gX3RhcmdldEVsZW1lbnQuaXMoJ3RleHRhcmVhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2lzQm9keSA9IF90YXJnZXRFbGVtZW50LmlzKCdib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50TWl4ZWQgPSBfZG9jdW1lbnRFbGVtZW50TmF0aXZlICE9PSBkb2N1bWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyogT24gYSBkaXYgRWxlbWVudCBUaGUgaWYgY2hlY2tzIG9ubHkgd2hldGhlcjpcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIHRoZSB0YXJnZXRFbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJvcy1ob3N0XCJcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIHRoZSB0YXJnZXRFbGVtZW50IGhhcyBhIGEgY2hpbGQgd2l0aCB0aGUgY2xhc3MgXCJvcy1wYWRkaW5nXCJcclxuICAgICAgICAgICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGF0J3MgdGhlIGNhc2UsIGl0cyBhc3N1bWVkIHRoZSBET00gaGFzIGFscmVhZHkgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XHJcbiAgICAgICAgICAgICAgICAgICAgICogKFRoZSBcIi5vcy1ob3N0XCIgZWxlbWVudCBpcyB0aGUgdGFyZ2V0RWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqICA8ZGl2IGNsYXNzPVwib3MtaG9zdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0XCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3MtcGFkZGluZ1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy12aWV3cG9ydFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3MtY29udGVudFwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyIG9zLXNjcm9sbGJhci1ob3Jpem9udGFsIFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItdHJhY2tcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci1oYW5kbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhciBvcy1zY3JvbGxiYXItdmVydGljYWxcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLXRyYWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItaGFuZGxlXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItY29ybmVyXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgICAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgICAgICAgICAqIE9uIGEgVGV4dGFyZWEgRWxlbWVudCBUaGUgaWYgY2hlY2tzIG9ubHkgd2hldGhlcjpcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIHRoZSB0YXJnZXRFbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJvcy10ZXh0YXJlYVwiIFxyXG4gICAgICAgICAgICAgICAgICAgICAqIC0gdGhlIHRhcmdldEVsZW1lbnQgaXMgaW5zaWRlIGEgZWxlbWVudCB3aXRoIHRoZSBjbGFzcyBcIm9zLWNvbnRlbnRcIiBcclxuICAgICAgICAgICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGF0J3MgdGhlIGNhc2UsIGl0cyBhc3N1bWVkIHRoZSBET00gaGFzIGFscmVhZHkgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XHJcbiAgICAgICAgICAgICAgICAgICAgICogKFRoZSBcIi5vcy10ZXh0YXJlYVwiICh0ZXh0YXJlYSkgZWxlbWVudCBpcyB0aGUgdGFyZ2V0RWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqICA8ZGl2IGNsYXNzPVwib3MtaG9zdC10ZXh0YXJlYVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXJlc2l6ZS1vYnNlcnZlci1ob3N0XCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3MtcGFkZGluZyBvcy10ZXh0LWluaGVyaXRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtdmlld3BvcnQgb3MtdGV4dC1pbmhlcml0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1jb250ZW50IG9zLXRleHQtaW5oZXJpdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXRleHRhcmVhLWNvdmVyXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJvcy10ZXh0YXJlYSBvcy10ZXh0LWluaGVyaXRcIj48L3RleHRhcmVhPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhciBvcy1zY3JvbGxiYXItaG9yaXpvbnRhbCBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLXRyYWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItaGFuZGxlXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXIgb3Mtc2Nyb2xsYmFyLXZlcnRpY2FsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci10cmFja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLWhhbmRsZVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLWNvcm5lclwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBfZG9tRXhpc3RzID0gX2lzVGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBfdGFyZ2V0RWxlbWVudC5oYXNDbGFzcyhfY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50KSAmJiBfdGFyZ2V0RWxlbWVudC5wYXJlbnQoKS5oYXNDbGFzcyhfY2xhc3NOYW1lQ29udGVudEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX3RhcmdldEVsZW1lbnQuaGFzQ2xhc3MoX2NsYXNzTmFtZUhvc3RFbGVtZW50KSAmJiBfdGFyZ2V0RWxlbWVudC5jaGlsZHJlbihfc3RyRG90ICsgX2NsYXNzTmFtZVBhZGRpbmdFbGVtZW50KVtMRVhJQ09OLmxdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdEJvZHlTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlNb3VzZVRvdWNoRG93bkxpc3RlbmVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHRoZSBwbHVnaW4gaGFzbid0IHRvIGJlIGluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSAmJiAhX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMubmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkLmluaXRpYWxpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25Jbml0aWFsaXphdGlvbldpdGhkcmF3bicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RvbUV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBTdHJ1Y3R1cmVET00odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhcnNET00odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhckNvcm5lckRPTSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Rlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zbGVlcGluZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Jhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0Qm9keVNjcm9sbCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0Qm9keVNjcm9sbC5sID0gTUFUSC5tYXgoX3RhcmdldEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKCksIF9odG1sRWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oKSwgX3dpbmRvd0VsZW1lbnRbX3N0clNjcm9sbExlZnRdKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0Qm9keVNjcm9sbC50ID0gTUFUSC5tYXgoX3RhcmdldEVsZW1lbnRbX3N0clNjcm9sbFRvcF0oKSwgX2h0bWxFbGVtZW50W19zdHJTY3JvbGxUb3BdKCksIF93aW5kb3dFbGVtZW50W19zdHJTY3JvbGxUb3BdKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keU1vdXNlVG91Y2hEb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LnJlbW92ZUF0dHIoTEVYSUNPTi50aSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF92aWV3cG9ydEVsZW1lbnQsIF9zdHJNb3VzZVRvdWNoRG93bkV2ZW50LCBib2R5TW91c2VUb3VjaERvd25MaXN0ZW5lciwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYnVpbGQgT3ZlcmxheVNjcm9sbGJhcnMgRE9NXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTdHJ1Y3R1cmVET00oKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhcnNET00oKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhckNvcm5lckRPTSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZSBPdmVybGF5U2Nyb2xsYmFycyBldmVudHNcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFN0cnVjdHVyZUV2ZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyRXZlbnRzKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyRXZlbnRzKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhckNvcm5lckV2ZW50cygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZSBtdXRhdGlvbiBvYnNlcnZlcnNcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVNdXRhdGlvbk9ic2VydmVycygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2J1aWxkIHJlc2l6ZSBvYnNlcnZlciBmb3IgdGhlIGhvc3QgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzaXplT2JzZXJ2ZXIoX3NpemVPYnNlcnZlckVsZW1lbnQsIGhvc3RPblJlc2l6ZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQm9keSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IHRoZSBib2R5IHNjcm9sbCB0byBoYW5kbGUgaXQgcmlnaHQgaW4gdGhlIHVwZGF0ZSBtZXRob2RcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oaW5pdEJvZHlTY3JvbGwubClbX3N0clNjcm9sbFRvcF0oaW5pdEJvZHlTY3JvbGwudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NldCB0aGUgZm9jdXMgb24gdGhlIHZpZXdwb3J0IGVsZW1lbnQgc28geW91IGRvbnQgaGF2ZSB0byBjbGljayBvbiB0aGUgcGFnZSB0byB1c2Uga2V5Ym9hcmQga2V5cyAodXAgLyBkb3duIC8gc3BhY2UpIGZvciBzY3JvbGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gdGFyZ2V0RWxlbWVudCAmJiBfdmlld3BvcnRFbGVtZW50TmF0aXZlLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NldCBhIHRhYmluZGV4IHRvIG1ha2UgdGhlIHZpZXdwb3J0RWxlbWVudCBmb2N1c2FibGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuYXR0cihMRVhJQ09OLnRpLCAnLTEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnROYXRpdmUuZm9jdXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiB0aGUgdGFiaW5kZXggaGFzIHRvIGJlIHJlbW92ZWQgZHVlIHRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgeW91IHNldCB0aGUgdGFiaW5kZXggYXR0cmlidXRlIG9uIGFuIDxkaXY+LCB0aGVuIGl0cyBjaGlsZCBjb250ZW50IGNhbm5vdCBiZSBzY3JvbGxlZCB3aXRoIHRoZSBhcnJvdyBrZXlzIHVubGVzcyB5b3Ugc2V0IHRhYmluZGV4IG9uIHRoZSBjb250ZW50LCB0b29cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfdmlld3BvcnRFbGVtZW50LCBfc3RyTW91c2VUb3VjaERvd25FdmVudCwgYm9keU1vdXNlVG91Y2hEb3duTGlzdGVuZXIsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgZm9yIHRoZSBmaXJzdCB0aW1lICYgaW5pdGlhbGl6ZSBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZShfc3RyQXV0byk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIHBsdWdpbiBpcyBpbml0aWFsaXplZCBub3chXHJcbiAgICAgICAgICAgICAgICAgICAgX2luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbkluaXRpYWxpemVkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2FsbCBhbGwgY2FsbGJhY2tzIHdoaWNoIHdvdWxkIGZpcmUgYmVmb3JlIHRoZSBpbml0aWFsaXplZCB3YXMgY29tcGxldGVcclxuICAgICAgICAgICAgICAgICAgICBlYWNoKF9jYWxsYmFja3NJbml0UWV1ZXVlLCBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7IGRpc3BhdGNoQ2FsbGJhY2sodmFsdWUubiwgdmFsdWUuYSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFja3NJbml0UWV1ZXVlID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkIGV4dGVuc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShleHRlbnNpb25zKSA9PSBUWVBFUy5zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zID0gW2V4dGVuc2lvbnNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChDT01QQVRJQklMSVRZLmlzQShleHRlbnNpb25zKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChleHRlbnNpb25zLCBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7IF9iYXNlLmFkZEV4dCh2YWx1ZSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEZSQU1FV09SSy5pc1BsYWluT2JqZWN0KGV4dGVuc2lvbnMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKGV4dGVuc2lvbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7IF9iYXNlLmFkZEV4dChrZXksIHZhbHVlKTsgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkIHRoZSB0cmFuc2l0aW9uIGNsYXNzIGZvciB0cmFuc2l0aW9ucyBBRlRFUiB0aGUgZmlyc3QgdXBkYXRlICYgQUZURVIgdGhlIGFwcGxpZWQgZXh0ZW5zaW9ucyAoZm9yIHByZXZlbnRpbmcgdW53YW50ZWQgdHJhbnNpdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFRyYW5zaXRpb24gJiYgIV9kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0VHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgMzMzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9iYXNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfcGx1Z2luLnZhbGlkKGNvbnN0cnVjdChwbHVnaW5UYXJnZXRFbGVtZW50LCBvcHRpb25zLCBleHRlbnNpb25zKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBJTlNUQU5DRVMocGx1Z2luVGFyZ2V0RWxlbWVudCwgX2Jhc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfYmFzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3IE92ZXJsYXlTY3JvbGxiYXJzSW5zdGFuY2Ugb2JqZWN0IG9yIGNoYW5nZXMgb3B0aW9ucyBpZiBhbHJlYWR5IGluaXRpYWxpemVkIG9yIHJldHVybnMgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBwbHVnaW5UYXJnZXRFbGVtZW50cyBUaGUgZWxlbWVudHMgdG8gd2hpY2ggdGhlIFBsdWdpbiBzaGFsbCBiZSBpbml0aWFsaXplZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGN1c3RvbSBvcHRpb25zIHdpdGggd2hpY2ggdGhlIHBsdWdpbiBzaGFsbCBiZSBpbml0aWFsaXplZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbihzKSB3aGljaCBzaGFsbCBiZSBhZGRlZCByaWdodCBhZnRlciBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfcGx1Z2luID0gd2luZG93W1BMVUdJTk5BTUVdID0gZnVuY3Rpb24gKHBsdWdpblRhcmdldEVsZW1lbnRzLCBvcHRpb25zLCBleHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW0xFWElDT04ubF0gPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdHNJc1BsYWluT2JqID0gRlJBTUVXT1JLLmlzUGxhaW5PYmplY3Qob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdDtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9wbHVnaW5UYXJnZXRFbGVtZW50cyBpcyBudWxsIG9yIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFwbHVnaW5UYXJnZXRFbGVtZW50cylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0c0lzUGxhaW5PYmogfHwgIW9wdGlvbnMgPyByZXN1bHQgOiBhcnI7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgIHBsdWdpblRhcmdldEVsZW1lbnRzIHdpbGwgYmUgY29udmVydGVkIHRvOlxyXG4gICAgICAgICAgICAgICAgICAgMS4gQSBqUXVlcnlFbGVtZW50IEFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAyLiBBIEhUTUxFbGVtZW50IEFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAzLiBBIEFycmF5IHdpdGggYSBzaW5nbGUgSFRNTCBFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICBzbyBwbHVnaW5UYXJnZXRFbGVtZW50cyBpcyBhbHdheXMgYSBhcnJheS5cclxuICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5UYXJnZXRFbGVtZW50cyA9IHBsdWdpblRhcmdldEVsZW1lbnRzW0xFWElDT04ubF0gIT0gdW5kZWZpbmVkID8gcGx1Z2luVGFyZ2V0RWxlbWVudHMgOiBbcGx1Z2luVGFyZ2V0RWxlbWVudHNbMF0gfHwgcGx1Z2luVGFyZ2V0RWxlbWVudHNdO1xyXG4gICAgICAgICAgICAgICAgaW5pdE92ZXJsYXlTY3JvbGxiYXJzU3RhdGljcygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5UYXJnZXRFbGVtZW50c1tMRVhJQ09OLmxdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzSXNQbGFpbk9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksuZWFjaChwbHVnaW5UYXJnZXRFbGVtZW50cywgZnVuY3Rpb24gKGksIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3QgPSB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3QgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChPdmVybGF5U2Nyb2xsYmFyc0luc3RhbmNlKGluc3QsIG9wdGlvbnMsIGV4dGVuc2lvbnMsIF9wbHVnaW5zR2xvYmFscywgX3BsdWdpbnNBdXRvVXBkYXRlTG9vcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSy5lYWNoKHBsdWdpblRhcmdldEVsZW1lbnRzLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdCA9IElOU1RBTkNFUyh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob3B0aW9ucyA9PT0gJyEnICYmIF9wbHVnaW4udmFsaWQoaW5zdCkpIHx8IChDT01QQVRJQklMSVRZLnR5cGUob3B0aW9ucykgPT0gVFlQRVMuZiAmJiBvcHRpb25zKHYsIGluc3QpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChpbnN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChpbnN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFycltMRVhJQ09OLmxdID09PSAxID8gYXJyWzBdIDogYXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGx1Z2luIGFuZCBlYWNoIGluc3RhbmNlIG9mIGl0LlxyXG4gICAgICAgICAgICAgKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGlzIGp1c3QgYSBjb3B5LCB0aGF0IG1lYW5zIHRoYXQgY2hhbmdlcyB0byB0aGUgcmV0dXJuZWQgb2JqZWN0IHdvbid0IGhhdmUgYW55IGVmZmVjdCB0byB0aGUgb3JpZ2luYWwgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3BsdWdpbi5nbG9iYWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdE92ZXJsYXlTY3JvbGxiYXJzU3RhdGljcygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdsb2JhbHMgPSBGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHt9LCBfcGx1Z2luc0dsb2JhbHMpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbHNbJ21zaWUnXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxzO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgb3IgU2V0cyB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciBlYWNoIG5ldyBwbHVnaW4gaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBuZXdEZWZhdWx0T3B0aW9ucyBUaGUgb2JqZWN0IHdpdGggd2hpY2ggdGhlIGRlZmF1bHQgb3B0aW9ucyBzaGFsbCBiZSBleHRlbmRlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9wbHVnaW4uZGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiAobmV3RGVmYXVsdE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGluaXRPdmVybGF5U2Nyb2xsYmFyc1N0YXRpY3MoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyRGVmYXVsdE9wdGlvbnMgPSBfcGx1Z2luc0dsb2JhbHMuZGVmYXVsdE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RGVmYXVsdE9wdGlvbnMgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB7fSwgY3VyckRlZmF1bHRPcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3NldCB0aGUgbmV3IGRlZmF1bHQgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgX3BsdWdpbnNHbG9iYWxzLmRlZmF1bHRPcHRpb25zID0gRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB7fSwgY3VyckRlZmF1bHRPcHRpb25zLCBfcGx1Z2luc09wdGlvbnMuX3ZhbGlkYXRlKG5ld0RlZmF1bHRPcHRpb25zLCBfcGx1Z2luc09wdGlvbnMuX3RlbXBsYXRlLCB0cnVlLCBjdXJyRGVmYXVsdE9wdGlvbnMpLl9kZWZhdWx0KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgcGFzc2VkIGluc3RhbmNlIGlzIGEgbm9uLWRlc3Ryb3llZCBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIG9zSW5zdGFuY2UgVGhlIHBvdGVudGlhbCBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSB3aGljaCBzaGFsbCBiZSBjaGVja2VkLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgbm9uLWRlc3Ryb3llZCBPdmVybGF5U2Nyb2xsYmFycyBpbnN0YW5jZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3BsdWdpbi52YWxpZCA9IGZ1bmN0aW9uIChvc0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3NJbnN0YW5jZSBpbnN0YW5jZW9mIF9wbHVnaW4gJiYgIW9zSW5zdGFuY2UuZ2V0U3RhdGUoKS5kZXN0cm95ZWQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVnaXN0ZXJzLCBVbnJlZ2lzdGVycyBvciByZXR1cm5zIGEgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcjogUGFzcyB0aGUgbmFtZSBhbmQgdGhlIGV4dGVuc2lvbi4gKGRlZmF1bHRPcHRpb25zIGlzIG9wdGlvbmFsKVxyXG4gICAgICAgICAgICAgKiBVbnJlZ2lzdGVyOiBQYXNzIHRoZSBuYW1lIGFuZCBhbnl0aGluZyBleGNlcHQgYSBmdW5jdGlvbiBhcyBleHRlbnNpb24gcGFyYW1ldGVyLlxyXG4gICAgICAgICAgICAgKiBHZXQgZXh0ZW5zaW9uOiBQYXNzIHRoZSBuYW1lIG9mIHRoZSBleHRlbnNpb24gd2hpY2ggc2hhbGwgYmUgZ290LlxyXG4gICAgICAgICAgICAgKiBHZXQgYWxsIGV4dGVuc2lvbnM6IFBhc3Mgbm8gYXJndW1lbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9uTmFtZSBUaGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uIHdoaWNoIHNoYWxsIGJlIHJlZ2lzdGVyZWQsIHVucmVnaXN0ZXJlZCBvciByZXR1cm5lZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIGV4dGVuc2lvbiBBIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyB0aGUgaW5zdGFuY2Ugb2YgdGhlIGV4dGVuc2lvbiBvciBhbnl0aGluZyBvdGhlciB0byByZW1vdmUgYSBhbHJlYWR5IHJlZ2lzdGVyZWQgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGVmYXVsdE9wdGlvbnMgVGhlIGRlZmF1bHQgb3B0aW9ucyB3aGljaCBzaGFsbCBiZSB1c2VkIGZvciB0aGUgcmVnaXN0ZXJlZCBleHRlbnNpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfcGx1Z2luLmV4dGVuc2lvbiA9IGZ1bmN0aW9uIChleHRlbnNpb25OYW1lLCBleHRlbnNpb24sIGRlZmF1bHRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXh0TmFtZVR5cGVTdHJpbmcgPSBDT01QQVRJQklMSVRZLnR5cGUoZXh0ZW5zaW9uTmFtZSkgPT0gVFlQRVMucztcclxuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmd1bWVudHNbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPCAxIHx8ICFleHROYW1lVHlwZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGEgY29weSBvZiBhbGwgZXh0ZW5zaW9uIG9iamVjdHNcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB7IGxlbmd0aDogX3BsdWdpbnNFeHRlbnNpb25zW0xFWElDT04ubF0gfSwgX3BsdWdpbnNFeHRlbnNpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4dE5hbWVUeXBlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkudHlwZShleHRlbnNpb24pID09IFRZUEVTLmYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWdpc3RlciBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3BsdWdpbnNFeHRlbnNpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbkZhY3Rvcnk6IGV4dGVuc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgX3BsdWdpbnNFeHRlbnNpb25zW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9wbHVnaW5zRXh0ZW5zaW9uc1tpXS5uYW1lID09PSBleHRlbnNpb25OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wbHVnaW5zRXh0ZW5zaW9ucy5zcGxpY2UoaSwgMSk7IC8vcmVtb3ZlIGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZSQU1FV09SSy5leHRlbmQodHJ1ZSwge30sIF9wbHVnaW5zRXh0ZW5zaW9uc1tpXSk7IC8vcmV0dXJuIGV4dGVuc2lvbiB3aXRoIHRoZSBnaXZlbiBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX3BsdWdpbjtcclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICBpZiAoSlFVRVJZICYmIEpRVUVSWS5mbikge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGpRdWVyeSBpbml0aWFsaXphdGlvbiBpbnRlcmZhY2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBpbml0aWFsIG9wdGlvbnMgZm9yIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIHBsdWdpbi4gVG8gaW5pdGlhbGl6ZSB0aGUgcGx1Z2luLCB0aGlzIG9wdGlvbiBoYXMgdG8gYmUgYSBvYmplY3QhIElmIGl0IGlzbid0IGEgb2JqZWN0LCB0aGUgaW5zdGFuY2UocykgYXJlIHJldHVybmVkIGFuZCB0aGUgcGx1Z2luIHdvbnQgYmUgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb24ocykgd2hpY2ggc2hhbGwgYmUgYWRkZWQgcmlnaHQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBBZnRlciBpbml0aWFsaXphdGlvbiBpdCByZXR1cm5zIHRoZSBqUXVlcnkgZWxlbWVudCBhcnJheSwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnN0YW5jZShzKSBvZiB0aGUgZWxlbWVudHMgd2hpY2ggYXJlIHNlbGVjdGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSlFVRVJZLmZuLm92ZXJsYXlTY3JvbGxiYXJzID0gZnVuY3Rpb24gKG9wdGlvbnMsIGV4dGVuc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfZWxlbWVudHMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKEpRVUVSWS5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgSlFVRVJZLmVhY2goX2VsZW1lbnRzLCBmdW5jdGlvbiAoKSB7IFBMVUdJTih0aGlzLCBvcHRpb25zLCBleHRlbnNpb25zKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbGVtZW50cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUExVR0lOKF9lbGVtZW50cywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQTFVHSU47XHJcbiAgICB9XHJcbikpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/overlayscrollbars/js/OverlayScrollbars.js\n");

/***/ })

/******/ });